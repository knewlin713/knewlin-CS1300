(function () { const a = document.createElement("link").relList; if (a && a.supports && a.supports("modulepreload")) return; for (const c of document.querySelectorAll('link[rel="modulepreload"]')) o(c); new MutationObserver(c => { for (const f of c) if (f.type === "childList") for (const h of f.addedNodes) h.tagName === "LINK" && h.rel === "modulepreload" && o(h) }).observe(document, { childList: !0, subtree: !0 }); function s(c) { const f = {}; return c.integrity && (f.integrity = c.integrity), c.referrerPolicy && (f.referrerPolicy = c.referrerPolicy), c.crossOrigin === "use-credentials" ? f.credentials = "include" : c.crossOrigin === "anonymous" ? f.credentials = "omit" : f.credentials = "same-origin", f } function o(c) { if (c.ep) return; c.ep = !0; const f = s(c); fetch(c.href, f) } })(); var Bu = { exports: {} }, yl = {};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Gm; function zb() { if (Gm) return yl; Gm = 1; var i = Symbol.for("react.transitional.element"), a = Symbol.for("react.fragment"); function s(o, c, f) { var h = null; if (f !== void 0 && (h = "" + f), c.key !== void 0 && (h = "" + c.key), "key" in c) { f = {}; for (var g in c) g !== "key" && (f[g] = c[g]) } else f = c; return c = f.ref, { $$typeof: i, type: o, key: h, ref: c !== void 0 ? c : null, props: f } } return yl.Fragment = a, yl.jsx = s, yl.jsxs = s, yl } var Ym; function _b() { return Ym || (Ym = 1, Bu.exports = zb()), Bu.exports } var y = _b(), Uu = { exports: {} }, se = {};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Xm; function Bb() { if (Xm) return se; Xm = 1; var i = Symbol.for("react.transitional.element"), a = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), c = Symbol.for("react.profiler"), f = Symbol.for("react.consumer"), h = Symbol.for("react.context"), g = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), m = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), x = Symbol.iterator; function S(w) { return w === null || typeof w != "object" ? null : (w = x && w[x] || w["@@iterator"], typeof w == "function" ? w : null) } var j = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, D = Object.assign, z = {}; function _(w, G, ie) { this.props = w, this.context = G, this.refs = z, this.updater = ie || j } _.prototype.isReactComponent = {}, _.prototype.setState = function (w, G) { if (typeof w != "object" && typeof w != "function" && w != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, w, G, "setState") }, _.prototype.forceUpdate = function (w) { this.updater.enqueueForceUpdate(this, w, "forceUpdate") }; function O() { } O.prototype = _.prototype; function L(w, G, ie) { this.props = w, this.context = G, this.refs = z, this.updater = ie || j } var N = L.prototype = new O; N.constructor = L, D(N, _.prototype), N.isPureReactComponent = !0; var J = Array.isArray, q = { H: null, A: null, T: null, S: null }, ae = Object.prototype.hasOwnProperty; function fe(w, G, ie, ee, K, de) { return ie = de.ref, { $$typeof: i, type: w, key: G, ref: ie !== void 0 ? ie : null, props: de } } function W(w, G) { return fe(w.type, G, void 0, void 0, void 0, w.props) } function Y(w) { return typeof w == "object" && w !== null && w.$$typeof === i } function I(w) { var G = { "=": "=0", ":": "=2" }; return "$" + w.replace(/[=:]/g, function (ie) { return G[ie] }) } var Ce = /\/+/g; function vt(w, G) { return typeof w == "object" && w !== null && w.key != null ? I("" + w.key) : G.toString(36) } function bt() { } function xt(w) { switch (w.status) { case "fulfilled": return w.value; case "rejected": throw w.reason; default: switch (typeof w.status == "string" ? w.then(bt, bt) : (w.status = "pending", w.then(function (G) { w.status === "pending" && (w.status = "fulfilled", w.value = G) }, function (G) { w.status === "pending" && (w.status = "rejected", w.reason = G) })), w.status) { case "fulfilled": return w.value; case "rejected": throw w.reason } }throw w } function nt(w, G, ie, ee, K) { var de = typeof w; (de === "undefined" || de === "boolean") && (w = null); var re = !1; if (w === null) re = !0; else switch (de) { case "bigint": case "string": case "number": re = !0; break; case "object": switch (w.$$typeof) { case i: case a: re = !0; break; case v: return re = w._init, nt(re(w._payload), G, ie, ee, K) } }if (re) return K = K(w), re = ee === "" ? "." + vt(w, 0) : ee, J(K) ? (ie = "", re != null && (ie = re.replace(Ce, "$&/") + "/"), nt(K, G, ie, "", function (Ne) { return Ne })) : K != null && (Y(K) && (K = W(K, ie + (K.key == null || w && w.key === K.key ? "" : ("" + K.key).replace(Ce, "$&/") + "/") + re)), G.push(K)), 1; re = 0; var it = ee === "" ? "." : ee + ":"; if (J(w)) for (var ve = 0; ve < w.length; ve++)ee = w[ve], de = it + vt(ee, ve), re += nt(ee, G, ie, de, K); else if (ve = S(w), typeof ve == "function") for (w = ve.call(w), ve = 0; !(ee = w.next()).done;)ee = ee.value, de = it + vt(ee, ve++), re += nt(ee, G, ie, de, K); else if (de === "object") { if (typeof w.then == "function") return nt(xt(w), G, ie, ee, K); throw G = String(w), Error("Objects are not valid as a React child (found: " + (G === "[object Object]" ? "object with keys {" + Object.keys(w).join(", ") + "}" : G) + "). If you meant to render a collection of children, use an array instead.") } return re } function X(w, G, ie) { if (w == null) return w; var ee = [], K = 0; return nt(w, ee, "", "", function (de) { return G.call(ie, de, K++) }), ee } function P(w) { if (w._status === -1) { var G = w._result; G = G(), G.then(function (ie) { (w._status === 0 || w._status === -1) && (w._status = 1, w._result = ie) }, function (ie) { (w._status === 0 || w._status === -1) && (w._status = 2, w._result = ie) }), w._status === -1 && (w._status = 0, w._result = G) } if (w._status === 1) return w._result.default; throw w._result } var F = typeof reportError == "function" ? reportError : function (w) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var G = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof w == "object" && w !== null && typeof w.message == "string" ? String(w.message) : String(w), error: w }); if (!window.dispatchEvent(G)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", w); return } console.error(w) }; function ye() { } return se.Children = { map: X, forEach: function (w, G, ie) { X(w, function () { G.apply(this, arguments) }, ie) }, count: function (w) { var G = 0; return X(w, function () { G++ }), G }, toArray: function (w) { return X(w, function (G) { return G }) || [] }, only: function (w) { if (!Y(w)) throw Error("React.Children.only expected to receive a single React element child."); return w } }, se.Component = _, se.Fragment = s, se.Profiler = c, se.PureComponent = L, se.StrictMode = o, se.Suspense = d, se.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = q, se.act = function () { throw Error("act(...) is not supported in production builds of React.") }, se.cache = function (w) { return function () { return w.apply(null, arguments) } }, se.cloneElement = function (w, G, ie) { if (w == null) throw Error("The argument must be a React element, but you passed " + w + "."); var ee = D({}, w.props), K = w.key, de = void 0; if (G != null) for (re in G.ref !== void 0 && (de = void 0), G.key !== void 0 && (K = "" + G.key), G) !ae.call(G, re) || re === "key" || re === "__self" || re === "__source" || re === "ref" && G.ref === void 0 || (ee[re] = G[re]); var re = arguments.length - 2; if (re === 1) ee.children = ie; else if (1 < re) { for (var it = Array(re), ve = 0; ve < re; ve++)it[ve] = arguments[ve + 2]; ee.children = it } return fe(w.type, K, void 0, void 0, de, ee) }, se.createContext = function (w) { return w = { $$typeof: h, _currentValue: w, _currentValue2: w, _threadCount: 0, Provider: null, Consumer: null }, w.Provider = w, w.Consumer = { $$typeof: f, _context: w }, w }, se.createElement = function (w, G, ie) { var ee, K = {}, de = null; if (G != null) for (ee in G.key !== void 0 && (de = "" + G.key), G) ae.call(G, ee) && ee !== "key" && ee !== "__self" && ee !== "__source" && (K[ee] = G[ee]); var re = arguments.length - 2; if (re === 1) K.children = ie; else if (1 < re) { for (var it = Array(re), ve = 0; ve < re; ve++)it[ve] = arguments[ve + 2]; K.children = it } if (w && w.defaultProps) for (ee in re = w.defaultProps, re) K[ee] === void 0 && (K[ee] = re[ee]); return fe(w, de, void 0, void 0, null, K) }, se.createRef = function () { return { current: null } }, se.forwardRef = function (w) { return { $$typeof: g, render: w } }, se.isValidElement = Y, se.lazy = function (w) { return { $$typeof: v, _payload: { _status: -1, _result: w }, _init: P } }, se.memo = function (w, G) { return { $$typeof: m, type: w, compare: G === void 0 ? null : G } }, se.startTransition = function (w) { var G = q.T, ie = {}; q.T = ie; try { var ee = w(), K = q.S; K !== null && K(ie, ee), typeof ee == "object" && ee !== null && typeof ee.then == "function" && ee.then(ye, F) } catch (de) { F(de) } finally { q.T = G } }, se.unstable_useCacheRefresh = function () { return q.H.useCacheRefresh() }, se.use = function (w) { return q.H.use(w) }, se.useActionState = function (w, G, ie) { return q.H.useActionState(w, G, ie) }, se.useCallback = function (w, G) { return q.H.useCallback(w, G) }, se.useContext = function (w) { return q.H.useContext(w) }, se.useDebugValue = function () { }, se.useDeferredValue = function (w, G) { return q.H.useDeferredValue(w, G) }, se.useEffect = function (w, G) { return q.H.useEffect(w, G) }, se.useId = function () { return q.H.useId() }, se.useImperativeHandle = function (w, G, ie) { return q.H.useImperativeHandle(w, G, ie) }, se.useInsertionEffect = function (w, G) { return q.H.useInsertionEffect(w, G) }, se.useLayoutEffect = function (w, G) { return q.H.useLayoutEffect(w, G) }, se.useMemo = function (w, G) { return q.H.useMemo(w, G) }, se.useOptimistic = function (w, G) { return q.H.useOptimistic(w, G) }, se.useReducer = function (w, G, ie) { return q.H.useReducer(w, G, ie) }, se.useRef = function (w) { return q.H.useRef(w) }, se.useState = function (w) { return q.H.useState(w) }, se.useSyncExternalStore = function (w, G, ie) { return q.H.useSyncExternalStore(w, G, ie) }, se.useTransition = function () { return q.H.useTransition() }, se.version = "19.0.0", se } var Km; function xc() { return Km || (Km = 1, Uu.exports = Bb()), Uu.exports } var C = xc(), Nu = { exports: {} }, vl = {}, Lu = { exports: {} }, ku = {};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Qm; function Ub() { return Qm || (Qm = 1, function (i) { function a(X, P) { var F = X.length; X.push(P); e: for (; 0 < F;) { var ye = F - 1 >>> 1, w = X[ye]; if (0 < c(w, P)) X[ye] = P, X[F] = w, F = ye; else break e } } function s(X) { return X.length === 0 ? null : X[0] } function o(X) { if (X.length === 0) return null; var P = X[0], F = X.pop(); if (F !== P) { X[0] = F; e: for (var ye = 0, w = X.length, G = w >>> 1; ye < G;) { var ie = 2 * (ye + 1) - 1, ee = X[ie], K = ie + 1, de = X[K]; if (0 > c(ee, F)) K < w && 0 > c(de, ee) ? (X[ye] = de, X[K] = F, ye = K) : (X[ye] = ee, X[ie] = F, ye = ie); else if (K < w && 0 > c(de, F)) X[ye] = de, X[K] = F, ye = K; else break e } } return P } function c(X, P) { var F = X.sortIndex - P.sortIndex; return F !== 0 ? F : X.id - P.id } if (i.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") { var f = performance; i.unstable_now = function () { return f.now() } } else { var h = Date, g = h.now(); i.unstable_now = function () { return h.now() - g } } var d = [], m = [], v = 1, x = null, S = 3, j = !1, D = !1, z = !1, _ = typeof setTimeout == "function" ? setTimeout : null, O = typeof clearTimeout == "function" ? clearTimeout : null, L = typeof setImmediate < "u" ? setImmediate : null; function N(X) { for (var P = s(m); P !== null;) { if (P.callback === null) o(m); else if (P.startTime <= X) o(m), P.sortIndex = P.expirationTime, a(d, P); else break; P = s(m) } } function J(X) { if (z = !1, N(X), !D) if (s(d) !== null) D = !0, xt(); else { var P = s(m); P !== null && nt(J, P.startTime - X) } } var q = !1, ae = -1, fe = 5, W = -1; function Y() { return !(i.unstable_now() - W < fe) } function I() { if (q) { var X = i.unstable_now(); W = X; var P = !0; try { e: { D = !1, z && (z = !1, O(ae), ae = -1), j = !0; var F = S; try { t: { for (N(X), x = s(d); x !== null && !(x.expirationTime > X && Y());) { var ye = x.callback; if (typeof ye == "function") { x.callback = null, S = x.priorityLevel; var w = ye(x.expirationTime <= X); if (X = i.unstable_now(), typeof w == "function") { x.callback = w, N(X), P = !0; break t } x === s(d) && o(d), N(X) } else o(d); x = s(d) } if (x !== null) P = !0; else { var G = s(m); G !== null && nt(J, G.startTime - X), P = !1 } } break e } finally { x = null, S = F, j = !1 } P = void 0 } } finally { P ? Ce() : q = !1 } } } var Ce; if (typeof L == "function") Ce = function () { L(I) }; else if (typeof MessageChannel < "u") { var vt = new MessageChannel, bt = vt.port2; vt.port1.onmessage = I, Ce = function () { bt.postMessage(null) } } else Ce = function () { _(I, 0) }; function xt() { q || (q = !0, Ce()) } function nt(X, P) { ae = _(function () { X(i.unstable_now()) }, P) } i.unstable_IdlePriority = 5, i.unstable_ImmediatePriority = 1, i.unstable_LowPriority = 4, i.unstable_NormalPriority = 3, i.unstable_Profiling = null, i.unstable_UserBlockingPriority = 2, i.unstable_cancelCallback = function (X) { X.callback = null }, i.unstable_continueExecution = function () { D || j || (D = !0, xt()) }, i.unstable_forceFrameRate = function (X) { 0 > X || 125 < X ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : fe = 0 < X ? Math.floor(1e3 / X) : 5 }, i.unstable_getCurrentPriorityLevel = function () { return S }, i.unstable_getFirstCallbackNode = function () { return s(d) }, i.unstable_next = function (X) { switch (S) { case 1: case 2: case 3: var P = 3; break; default: P = S }var F = S; S = P; try { return X() } finally { S = F } }, i.unstable_pauseExecution = function () { }, i.unstable_requestPaint = function () { }, i.unstable_runWithPriority = function (X, P) { switch (X) { case 1: case 2: case 3: case 4: case 5: break; default: X = 3 }var F = S; S = X; try { return P() } finally { S = F } }, i.unstable_scheduleCallback = function (X, P, F) { var ye = i.unstable_now(); switch (typeof F == "object" && F !== null ? (F = F.delay, F = typeof F == "number" && 0 < F ? ye + F : ye) : F = ye, X) { case 1: var w = -1; break; case 2: w = 250; break; case 5: w = 1073741823; break; case 4: w = 1e4; break; default: w = 5e3 }return w = F + w, X = { id: v++, callback: P, priorityLevel: X, startTime: F, expirationTime: w, sortIndex: -1 }, F > ye ? (X.sortIndex = F, a(m, X), s(d) === null && X === s(m) && (z ? (O(ae), ae = -1) : z = !0, nt(J, F - ye))) : (X.sortIndex = w, a(d, X), D || j || (D = !0, xt())), X }, i.unstable_shouldYield = Y, i.unstable_wrapCallback = function (X) { var P = S; return function () { var F = S; S = P; try { return X.apply(this, arguments) } finally { S = F } } } }(ku)), ku } var Zm; function Nb() { return Zm || (Zm = 1, Lu.exports = Ub()), Lu.exports } var Hu = { exports: {} }, Ie = {};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Pm; function Lb() { if (Pm) return Ie; Pm = 1; var i = xc(); function a(d) { var m = "https://react.dev/errors/" + d; if (1 < arguments.length) { m += "?args[]=" + encodeURIComponent(arguments[1]); for (var v = 2; v < arguments.length; v++)m += "&args[]=" + encodeURIComponent(arguments[v]) } return "Minified React error #" + d + "; visit " + m + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function s() { } var o = { d: { f: s, r: function () { throw Error(a(522)) }, D: s, C: s, L: s, m: s, X: s, S: s, M: s }, p: 0, findDOMNode: null }, c = Symbol.for("react.portal"); function f(d, m, v) { var x = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: c, key: x == null ? null : "" + x, children: d, containerInfo: m, implementation: v } } var h = i.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE; function g(d, m) { if (d === "font") return ""; if (typeof m == "string") return m === "use-credentials" ? m : "" } return Ie.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = o, Ie.createPortal = function (d, m) { var v = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!m || m.nodeType !== 1 && m.nodeType !== 9 && m.nodeType !== 11) throw Error(a(299)); return f(d, m, null, v) }, Ie.flushSync = function (d) { var m = h.T, v = o.p; try { if (h.T = null, o.p = 2, d) return d() } finally { h.T = m, o.p = v, o.d.f() } }, Ie.preconnect = function (d, m) { typeof d == "string" && (m ? (m = m.crossOrigin, m = typeof m == "string" ? m === "use-credentials" ? m : "" : void 0) : m = null, o.d.C(d, m)) }, Ie.prefetchDNS = function (d) { typeof d == "string" && o.d.D(d) }, Ie.preinit = function (d, m) { if (typeof d == "string" && m && typeof m.as == "string") { var v = m.as, x = g(v, m.crossOrigin), S = typeof m.integrity == "string" ? m.integrity : void 0, j = typeof m.fetchPriority == "string" ? m.fetchPriority : void 0; v === "style" ? o.d.S(d, typeof m.precedence == "string" ? m.precedence : void 0, { crossOrigin: x, integrity: S, fetchPriority: j }) : v === "script" && o.d.X(d, { crossOrigin: x, integrity: S, fetchPriority: j, nonce: typeof m.nonce == "string" ? m.nonce : void 0 }) } }, Ie.preinitModule = function (d, m) { if (typeof d == "string") if (typeof m == "object" && m !== null) { if (m.as == null || m.as === "script") { var v = g(m.as, m.crossOrigin); o.d.M(d, { crossOrigin: v, integrity: typeof m.integrity == "string" ? m.integrity : void 0, nonce: typeof m.nonce == "string" ? m.nonce : void 0 }) } } else m == null && o.d.M(d) }, Ie.preload = function (d, m) { if (typeof d == "string" && typeof m == "object" && m !== null && typeof m.as == "string") { var v = m.as, x = g(v, m.crossOrigin); o.d.L(d, v, { crossOrigin: x, integrity: typeof m.integrity == "string" ? m.integrity : void 0, nonce: typeof m.nonce == "string" ? m.nonce : void 0, type: typeof m.type == "string" ? m.type : void 0, fetchPriority: typeof m.fetchPriority == "string" ? m.fetchPriority : void 0, referrerPolicy: typeof m.referrerPolicy == "string" ? m.referrerPolicy : void 0, imageSrcSet: typeof m.imageSrcSet == "string" ? m.imageSrcSet : void 0, imageSizes: typeof m.imageSizes == "string" ? m.imageSizes : void 0, media: typeof m.media == "string" ? m.media : void 0 }) } }, Ie.preloadModule = function (d, m) { if (typeof d == "string") if (m) { var v = g(m.as, m.crossOrigin); o.d.m(d, { as: typeof m.as == "string" && m.as !== "script" ? m.as : void 0, crossOrigin: v, integrity: typeof m.integrity == "string" ? m.integrity : void 0 }) } else o.d.m(d) }, Ie.requestFormReset = function (d) { o.d.r(d) }, Ie.unstable_batchedUpdates = function (d, m) { return d(m) }, Ie.useFormState = function (d, m, v) { return h.H.useFormState(d, m, v) }, Ie.useFormStatus = function () { return h.H.useHostTransitionStatus() }, Ie.version = "19.0.0", Ie } var Fm; function kb() { if (Fm) return Hu.exports; Fm = 1; function i() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(i) } catch (a) { console.error(a) } } return i(), Hu.exports = Lb(), Hu.exports }/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Jm; function Hb() {
    if (Jm) return vl; Jm = 1; var i = Nb(), a = xc(), s = kb(); function o(e) { var t = "https://react.dev/errors/" + e; if (1 < arguments.length) { t += "?args[]=" + encodeURIComponent(arguments[1]); for (var n = 2; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]) } return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function c(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } var f = Symbol.for("react.element"), h = Symbol.for("react.transitional.element"), g = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), m = Symbol.for("react.strict_mode"), v = Symbol.for("react.profiler"), x = Symbol.for("react.provider"), S = Symbol.for("react.consumer"), j = Symbol.for("react.context"), D = Symbol.for("react.forward_ref"), z = Symbol.for("react.suspense"), _ = Symbol.for("react.suspense_list"), O = Symbol.for("react.memo"), L = Symbol.for("react.lazy"), N = Symbol.for("react.offscreen"), J = Symbol.for("react.memo_cache_sentinel"), q = Symbol.iterator; function ae(e) { return e === null || typeof e != "object" ? null : (e = q && e[q] || e["@@iterator"], typeof e == "function" ? e : null) } var fe = Symbol.for("react.client.reference"); function W(e) { if (e == null) return null; if (typeof e == "function") return e.$$typeof === fe ? null : e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case d: return "Fragment"; case g: return "Portal"; case v: return "Profiler"; case m: return "StrictMode"; case z: return "Suspense"; case _: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case j: return (e.displayName || "Context") + ".Provider"; case S: return (e._context.displayName || "Context") + ".Consumer"; case D: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case O: return t = e.displayName || null, t !== null ? t : W(e.type) || "Memo"; case L: t = e._payload, e = e._init; try { return W(e(t)) } catch { } }return null } var Y = a.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, I = Object.assign, Ce, vt; function bt(e) {
        if (Ce === void 0) try { throw Error() } catch (n) {
            var t = n.stack.trim().match(/\n( *(at )?)/); Ce = t && t[1] || "", vt = -1 < n.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < n.stack.indexOf("@") ? "@unknown:0:0" : ""
        } return `
`+ Ce + e + vt
    } var xt = !1; function nt(e, t) {
        if (!e || xt) return ""; xt = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try {
            var l = { DetermineComponentFrameRoot: function () { try { if (t) { var H = function () { throw Error() }; if (Object.defineProperty(H.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(H, []) } catch (B) { var V = B } Reflect.construct(e, [], H) } else { try { H.call() } catch (B) { V = B } e.call(H.prototype) } } else { try { throw Error() } catch (B) { V = B } (H = e()) && typeof H.catch == "function" && H.catch(function () { }) } } catch (B) { if (B && V && typeof B.stack == "string") return [B.stack, V.stack] } return [null, null] } }; l.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot"; var r = Object.getOwnPropertyDescriptor(l.DetermineComponentFrameRoot, "name"); r && r.configurable && Object.defineProperty(l.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" }); var u = l.DetermineComponentFrameRoot(), p = u[0], b = u[1]; if (p && b) {
                var T = p.split(`
`), E = b.split(`
`); for (r = l = 0; l < T.length && !T[l].includes("DetermineComponentFrameRoot");)l++; for (; r < E.length && !E[r].includes("DetermineComponentFrameRoot");)r++; if (l === T.length || r === E.length) for (l = T.length - 1, r = E.length - 1; 1 <= l && 0 <= r && T[l] !== E[r];)r--; for (; 1 <= l && 0 <= r; l--, r--)if (T[l] !== E[r]) {
                    if (l !== 1 || r !== 1) do if (l--, r--, 0 > r || T[l] !== E[r]) {
                        var U = `
`+ T[l].replace(" at new ", " at "); return e.displayName && U.includes("<anonymous>") && (U = U.replace("<anonymous>", e.displayName)), U
                    } while (1 <= l && 0 <= r); break
                }
            }
        } finally { xt = !1, Error.prepareStackTrace = n } return (n = e ? e.displayName || e.name : "") ? bt(n) : ""
    } function X(e) { switch (e.tag) { case 26: case 27: case 5: return bt(e.type); case 16: return bt("Lazy"); case 13: return bt("Suspense"); case 19: return bt("SuspenseList"); case 0: case 15: return e = nt(e.type, !1), e; case 11: return e = nt(e.type.render, !1), e; case 1: return e = nt(e.type, !0), e; default: return "" } } function P(e) {
        try { var t = ""; do t += X(e), e = e.return; while (e); return t } catch (n) {
            return `
Error generating stack: `+ n.message + `
`+ n.stack
        }
    } function F(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function ye(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function w(e) { if (F(e) !== e) throw Error(o(188)) } function G(e) { var t = e.alternate; if (!t) { if (t = F(e), t === null) throw Error(o(188)); return t !== e ? null : e } for (var n = e, l = t; ;) { var r = n.return; if (r === null) break; var u = r.alternate; if (u === null) { if (l = r.return, l !== null) { n = l; continue } break } if (r.child === u.child) { for (u = r.child; u;) { if (u === n) return w(r), e; if (u === l) return w(r), t; u = u.sibling } throw Error(o(188)) } if (n.return !== l.return) n = r, l = u; else { for (var p = !1, b = r.child; b;) { if (b === n) { p = !0, n = r, l = u; break } if (b === l) { p = !0, l = r, n = u; break } b = b.sibling } if (!p) { for (b = u.child; b;) { if (b === n) { p = !0, n = u, l = r; break } if (b === l) { p = !0, l = u, n = r; break } b = b.sibling } if (!p) throw Error(o(189)) } } if (n.alternate !== l) throw Error(o(190)) } if (n.tag !== 3) throw Error(o(188)); return n.stateNode.current === n ? e : t } function ie(e) { var t = e.tag; if (t === 5 || t === 26 || t === 27 || t === 6) return e; for (e = e.child; e !== null;) { if (t = ie(e), t !== null) return t; e = e.sibling } return null } var ee = Array.isArray, K = s.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, de = { pending: !1, data: null, method: null, action: null }, re = [], it = -1; function ve(e) { return { current: e } } function Ne(e) { 0 > it || (e.current = re[it], re[it] = null, it--) } function Ee(e, t) { it++, re[it] = e.current, e.current = t } var Gt = ve(null), xa = ve(null), Tn = ve(null), Gl = ve(null); function Yl(e, t) { switch (Ee(Tn, t), Ee(xa, e), Ee(Gt, null), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) && (t = t.namespaceURI) ? ym(t) : 0; break; default: if (e = e === 8 ? t.parentNode : t, t = e.tagName, e = e.namespaceURI) e = ym(e), t = vm(e, t); else switch (t) { case "svg": t = 1; break; case "math": t = 2; break; default: t = 0 } }Ne(Gt), Ee(Gt, t) } function ji() { Ne(Gt), Ne(xa), Ne(Tn) } function Er(e) { e.memoizedState !== null && Ee(Gl, e); var t = Gt.current, n = vm(t, e.type); t !== n && (Ee(xa, e), Ee(Gt, n)) } function Xl(e) { xa.current === e && (Ne(Gt), Ne(xa)), Gl.current === e && (Ne(Gl), hl._currentValue = de) } var jr = Object.prototype.hasOwnProperty, Dr = i.unstable_scheduleCallback, Mr = i.unstable_cancelCallback, fv = i.unstable_shouldYield, hv = i.unstable_requestPaint, Yt = i.unstable_now, dv = i.unstable_getCurrentPriorityLevel, sf = i.unstable_ImmediatePriority, rf = i.unstable_UserBlockingPriority, Kl = i.unstable_NormalPriority, mv = i.unstable_LowPriority, of = i.unstable_IdlePriority, pv = i.log, gv = i.unstable_setDisableYieldValue, Sa = null, ct = null; function yv(e) { if (ct && typeof ct.onCommitFiberRoot == "function") try { ct.onCommitFiberRoot(Sa, e, void 0, (e.current.flags & 128) === 128) } catch { } } function wn(e) { if (typeof pv == "function" && gv(e), ct && typeof ct.setStrictMode == "function") try { ct.setStrictMode(Sa, e) } catch { } } var ft = Math.clz32 ? Math.clz32 : xv, vv = Math.log, bv = Math.LN2; function xv(e) { return e >>>= 0, e === 0 ? 32 : 31 - (vv(e) / bv | 0) | 0 } var Ql = 128, Zl = 4194304; function Wn(e) { var t = e & 42; if (t !== 0) return t; switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: return 64; case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194176; case 4194304: case 8388608: case 16777216: case 33554432: return e & 62914560; case 67108864: return 67108864; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 0; default: return e } } function Pl(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var l = 0, r = e.suspendedLanes, u = e.pingedLanes, p = e.warmLanes; e = e.finishedLanes !== 0; var b = n & 134217727; return b !== 0 ? (n = b & ~r, n !== 0 ? l = Wn(n) : (u &= b, u !== 0 ? l = Wn(u) : e || (p = b & ~p, p !== 0 && (l = Wn(p))))) : (b = n & ~r, b !== 0 ? l = Wn(b) : u !== 0 ? l = Wn(u) : e || (p = n & ~p, p !== 0 && (l = Wn(p)))), l === 0 ? 0 : t !== 0 && t !== l && !(t & r) && (r = l & -l, p = t & -t, r >= p || r === 32 && (p & 4194176) !== 0) ? t : l } function Ta(e, t) { return (e.pendingLanes & ~(e.suspendedLanes & ~e.pingedLanes) & t) === 0 } function Sv(e, t) { switch (e) { case 1: case 2: case 4: case 8: return t + 250; case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: return -1; case 67108864: case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function uf() { var e = Ql; return Ql <<= 1, !(Ql & 4194176) && (Ql = 128), e } function cf() { var e = Zl; return Zl <<= 1, !(Zl & 62914560) && (Zl = 4194304), e } function Rr(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function wa(e, t) { e.pendingLanes |= t, t !== 268435456 && (e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0) } function Tv(e, t, n, l, r, u) { var p = e.pendingLanes; e.pendingLanes = n, e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0, e.expiredLanes &= n, e.entangledLanes &= n, e.errorRecoveryDisabledLanes &= n, e.shellSuspendCounter = 0; var b = e.entanglements, T = e.expirationTimes, E = e.hiddenUpdates; for (n = p & ~n; 0 < n;) { var U = 31 - ft(n), H = 1 << U; b[U] = 0, T[U] = -1; var V = E[U]; if (V !== null) for (E[U] = null, U = 0; U < V.length; U++) { var B = V[U]; B !== null && (B.lane &= -536870913) } n &= ~H } l !== 0 && ff(e, l, 0), u !== 0 && r === 0 && e.tag !== 0 && (e.suspendedLanes |= u & ~(p & ~t)) } function ff(e, t, n) { e.pendingLanes |= t, e.suspendedLanes &= ~t; var l = 31 - ft(t); e.entangledLanes |= t, e.entanglements[l] = e.entanglements[l] | 1073741824 | n & 4194218 } function hf(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var l = 31 - ft(n), r = 1 << l; r & t | e[l] & t && (e[l] |= t), n &= ~r } } function df(e) { return e &= -e, 2 < e ? 8 < e ? e & 134217727 ? 32 : 268435456 : 8 : 2 } function mf() { var e = K.p; return e !== 0 ? e : (e = window.event, e === void 0 ? 32 : Um(e.type)) } function wv(e, t) { var n = K.p; try { return K.p = e, t() } finally { K.p = n } } var An = Math.random().toString(36).slice(2), $e = "__reactFiber$" + An, rt = "__reactProps$" + An, Di = "__reactContainer$" + An, Cr = "__reactEvents$" + An, Av = "__reactListeners$" + An, Ev = "__reactHandles$" + An, pf = "__reactResources$" + An, Aa = "__reactMarker$" + An; function Or(e) { delete e[$e], delete e[rt], delete e[Cr], delete e[Av], delete e[Ev] } function In(e) { var t = e[$e]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[Di] || n[$e]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = Sm(e); e !== null;) { if (n = e[$e]) return n; e = Sm(e) } return t } e = n, n = e.parentNode } return null } function Mi(e) { if (e = e[$e] || e[Di]) { var t = e.tag; if (t === 5 || t === 6 || t === 13 || t === 26 || t === 27 || t === 3) return e } return null } function Ea(e) { var t = e.tag; if (t === 5 || t === 26 || t === 27 || t === 6) return e.stateNode; throw Error(o(33)) } function Ri(e) { var t = e[pf]; return t || (t = e[pf] = { hoistableStyles: new Map, hoistableScripts: new Map }), t } function Ye(e) { e[Aa] = !0 } var gf = new Set, yf = {}; function ei(e, t) { Ci(e, t), Ci(e + "Capture", t) } function Ci(e, t) { for (yf[e] = t, e = 0; e < t.length; e++)gf.add(t[e]) } var Wt = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), jv = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), vf = {}, bf = {}; function Dv(e) { return jr.call(bf, e) ? !0 : jr.call(vf, e) ? !1 : jv.test(e) ? bf[e] = !0 : (vf[e] = !0, !1) } function Fl(e, t, n) { if (Dv(t)) if (n === null) e.removeAttribute(t); else { switch (typeof n) { case "undefined": case "function": case "symbol": e.removeAttribute(t); return; case "boolean": var l = t.toLowerCase().slice(0, 5); if (l !== "data-" && l !== "aria-") { e.removeAttribute(t); return } }e.setAttribute(t, "" + n) } } function Jl(e, t, n) { if (n === null) e.removeAttribute(t); else { switch (typeof n) { case "undefined": case "function": case "symbol": case "boolean": e.removeAttribute(t); return }e.setAttribute(t, "" + n) } } function It(e, t, n, l) { if (l === null) e.removeAttribute(n); else { switch (typeof l) { case "undefined": case "function": case "symbol": case "boolean": e.removeAttribute(n); return }e.setAttributeNS(t, n, "" + l) } } function St(e) { switch (typeof e) { case "bigint": case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function xf(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function Mv(e) { var t = xf(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), l = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var r = n.get, u = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return r.call(this) }, set: function (p) { l = "" + p, u.call(this, p) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return l }, setValue: function (p) { l = "" + p }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function $l(e) { e._valueTracker || (e._valueTracker = Mv(e)) } function Sf(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), l = ""; return e && (l = xf(e) ? e.checked ? "true" : "false" : e.value), e = l, e !== n ? (t.setValue(e), !0) : !1 } function Wl(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } var Rv = /[\n"\\]/g; function Tt(e) { return e.replace(Rv, function (t) { return "\\" + t.charCodeAt(0).toString(16) + " " }) } function Vr(e, t, n, l, r, u, p, b) { e.name = "", p != null && typeof p != "function" && typeof p != "symbol" && typeof p != "boolean" ? e.type = p : e.removeAttribute("type"), t != null ? p === "number" ? (t === 0 && e.value === "" || e.value != t) && (e.value = "" + St(t)) : e.value !== "" + St(t) && (e.value = "" + St(t)) : p !== "submit" && p !== "reset" || e.removeAttribute("value"), t != null ? zr(e, p, St(t)) : n != null ? zr(e, p, St(n)) : l != null && e.removeAttribute("value"), r == null && u != null && (e.defaultChecked = !!u), r != null && (e.checked = r && typeof r != "function" && typeof r != "symbol"), b != null && typeof b != "function" && typeof b != "symbol" && typeof b != "boolean" ? e.name = "" + St(b) : e.removeAttribute("name") } function Tf(e, t, n, l, r, u, p, b) { if (u != null && typeof u != "function" && typeof u != "symbol" && typeof u != "boolean" && (e.type = u), t != null || n != null) { if (!(u !== "submit" && u !== "reset" || t != null)) return; n = n != null ? "" + St(n) : "", t = t != null ? "" + St(t) : n, b || t === e.value || (e.value = t), e.defaultValue = t } l = l ?? r, l = typeof l != "function" && typeof l != "symbol" && !!l, e.checked = b ? e.checked : !!l, e.defaultChecked = !!l, p != null && typeof p != "function" && typeof p != "symbol" && typeof p != "boolean" && (e.name = p) } function zr(e, t, n) { t === "number" && Wl(e.ownerDocument) === e || e.defaultValue === "" + n || (e.defaultValue = "" + n) } function Oi(e, t, n, l) { if (e = e.options, t) { t = {}; for (var r = 0; r < n.length; r++)t["$" + n[r]] = !0; for (n = 0; n < e.length; n++)r = t.hasOwnProperty("$" + e[n].value), e[n].selected !== r && (e[n].selected = r), r && l && (e[n].defaultSelected = !0) } else { for (n = "" + St(n), t = null, r = 0; r < e.length; r++) { if (e[r].value === n) { e[r].selected = !0, l && (e[r].defaultSelected = !0); return } t !== null || e[r].disabled || (t = e[r]) } t !== null && (t.selected = !0) } } function wf(e, t, n) { if (t != null && (t = "" + St(t), t !== e.value && (e.value = t), n == null)) { e.defaultValue !== t && (e.defaultValue = t); return } e.defaultValue = n != null ? "" + St(n) : "" } function Af(e, t, n, l) { if (t == null) { if (l != null) { if (n != null) throw Error(o(92)); if (ee(l)) { if (1 < l.length) throw Error(o(93)); l = l[0] } n = l } n == null && (n = ""), t = n } n = St(t), e.defaultValue = n, l = e.textContent, l === n && l !== "" && l !== null && (e.value = l) } function Vi(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var Cv = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")); function Ef(e, t, n) { var l = t.indexOf("--") === 0; n == null || typeof n == "boolean" || n === "" ? l ? e.setProperty(t, "") : t === "float" ? e.cssFloat = "" : e[t] = "" : l ? e.setProperty(t, n) : typeof n != "number" || n === 0 || Cv.has(t) ? t === "float" ? e.cssFloat = n : e[t] = ("" + n).trim() : e[t] = n + "px" } function jf(e, t, n) { if (t != null && typeof t != "object") throw Error(o(62)); if (e = e.style, n != null) { for (var l in n) !n.hasOwnProperty(l) || t != null && t.hasOwnProperty(l) || (l.indexOf("--") === 0 ? e.setProperty(l, "") : l === "float" ? e.cssFloat = "" : e[l] = ""); for (var r in t) l = t[r], t.hasOwnProperty(r) && n[r] !== l && Ef(e, r, l) } else for (var u in t) t.hasOwnProperty(u) && Ef(e, u, t[u]) } function _r(e) { if (e.indexOf("-") === -1) return !1; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Ov = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]]), Vv = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i; function Il(e) { return Vv.test("" + e) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : e } var Br = null; function Ur(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var zi = null, _i = null; function Df(e) { var t = Mi(e); if (t && (e = t.stateNode)) { var n = e[rt] || null; e: switch (e = t.stateNode, t.type) { case "input": if (Vr(e, n.value, n.defaultValue, n.defaultValue, n.checked, n.defaultChecked, n.type, n.name), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll('input[name="' + Tt("" + t) + '"][type="radio"]'), t = 0; t < n.length; t++) { var l = n[t]; if (l !== e && l.form === e.form) { var r = l[rt] || null; if (!r) throw Error(o(90)); Vr(l, r.value, r.defaultValue, r.defaultValue, r.checked, r.defaultChecked, r.type, r.name) } } for (t = 0; t < n.length; t++)l = n[t], l.form === e.form && Sf(l) } break e; case "textarea": wf(e, n.value, n.defaultValue); break e; case "select": t = n.value, t != null && Oi(e, !!n.multiple, t, !1) } } } var Nr = !1; function Mf(e, t, n) { if (Nr) return e(t, n); Nr = !0; try { var l = e(t); return l } finally { if (Nr = !1, (zi !== null || _i !== null) && (Us(), zi && (t = zi, e = _i, _i = zi = null, Df(t), e))) for (t = 0; t < e.length; t++)Df(e[t]) } } function ja(e, t) { var n = e.stateNode; if (n === null) return null; var l = n[rt] || null; if (l === null) return null; n = l[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (l = !l.disabled) || (e = e.type, l = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !l; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(o(231, t, typeof n)); return n } var Lr = !1; if (Wt) try { var Da = {}; Object.defineProperty(Da, "passive", { get: function () { Lr = !0 } }), window.addEventListener("test", Da, Da), window.removeEventListener("test", Da, Da) } catch { Lr = !1 } var En = null, kr = null, es = null; function Rf() { if (es) return es; var e, t = kr, n = t.length, l, r = "value" in En ? En.value : En.textContent, u = r.length; for (e = 0; e < n && t[e] === r[e]; e++); var p = n - e; for (l = 1; l <= p && t[n - l] === r[u - l]; l++); return es = r.slice(e, 1 < l ? 1 - l : void 0) } function ts(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function ns() { return !0 } function Cf() { return !1 } function ot(e) { function t(n, l, r, u, p) { this._reactName = n, this._targetInst = r, this.type = l, this.nativeEvent = u, this.target = p, this.currentTarget = null; for (var b in e) e.hasOwnProperty(b) && (n = e[b], this[b] = n ? n(u) : u[b]); return this.isDefaultPrevented = (u.defaultPrevented != null ? u.defaultPrevented : u.returnValue === !1) ? ns : Cf, this.isPropagationStopped = Cf, this } return I(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = ns) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = ns) }, persist: function () { }, isPersistent: ns }), t } var ti = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, is = ot(ti), Ma = I({}, ti, { view: 0, detail: 0 }), zv = ot(Ma), Hr, qr, Ra, as = I({}, Ma, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Yr, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== Ra && (Ra && e.type === "mousemove" ? (Hr = e.screenX - Ra.screenX, qr = e.screenY - Ra.screenY) : qr = Hr = 0, Ra = e), Hr) }, movementY: function (e) { return "movementY" in e ? e.movementY : qr } }), Of = ot(as), _v = I({}, as, { dataTransfer: 0 }), Bv = ot(_v), Uv = I({}, Ma, { relatedTarget: 0 }), Gr = ot(Uv), Nv = I({}, ti, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Lv = ot(Nv), kv = I({}, ti, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), Hv = ot(kv), qv = I({}, ti, { data: 0 }), Vf = ot(qv), Gv = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Yv = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Xv = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Kv(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = Xv[e]) ? !!t[e] : !1 } function Yr() { return Kv } var Qv = I({}, Ma, { key: function (e) { if (e.key) { var t = Gv[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = ts(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? Yv[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Yr, charCode: function (e) { return e.type === "keypress" ? ts(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? ts(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), Zv = ot(Qv), Pv = I({}, as, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), zf = ot(Pv), Fv = I({}, Ma, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Yr }), Jv = ot(Fv), $v = I({}, ti, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Wv = ot($v), Iv = I({}, as, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), e0 = ot(Iv), t0 = I({}, ti, { newState: 0, oldState: 0 }), n0 = ot(t0), i0 = [9, 13, 27, 32], Xr = Wt && "CompositionEvent" in window, Ca = null; Wt && "documentMode" in document && (Ca = document.documentMode); var a0 = Wt && "TextEvent" in window && !Ca, _f = Wt && (!Xr || Ca && 8 < Ca && 11 >= Ca), Bf = " ", Uf = !1; function Nf(e, t) { switch (e) { case "keyup": return i0.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Lf(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var Bi = !1; function l0(e, t) { switch (e) { case "compositionend": return Lf(t); case "keypress": return t.which !== 32 ? null : (Uf = !0, Bf); case "textInput": return e = t.data, e === Bf && Uf ? null : e; default: return null } } function s0(e, t) { if (Bi) return e === "compositionend" || !Xr && Nf(e, t) ? (e = Rf(), es = kr = En = null, Bi = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return _f && t.locale !== "ko" ? null : t.data; default: return null } } var r0 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function kf(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!r0[e.type] : t === "textarea" } function Hf(e, t, n, l) { zi ? _i ? _i.push(l) : _i = [l] : zi = l, t = qs(t, "onChange"), 0 < t.length && (n = new is("onChange", "change", null, n, l), e.push({ event: n, listeners: t })) } var Oa = null, Va = null; function o0(e) { hm(e, 0) } function ls(e) { var t = Ea(e); if (Sf(t)) return e } function qf(e, t) { if (e === "change") return t } var Gf = !1; if (Wt) { var Kr; if (Wt) { var Qr = "oninput" in document; if (!Qr) { var Yf = document.createElement("div"); Yf.setAttribute("oninput", "return;"), Qr = typeof Yf.oninput == "function" } Kr = Qr } else Kr = !1; Gf = Kr && (!document.documentMode || 9 < document.documentMode) } function Xf() { Oa && (Oa.detachEvent("onpropertychange", Kf), Va = Oa = null) } function Kf(e) { if (e.propertyName === "value" && ls(Va)) { var t = []; Hf(t, Va, e, Ur(e)), Mf(o0, t) } } function u0(e, t, n) { e === "focusin" ? (Xf(), Oa = t, Va = n, Oa.attachEvent("onpropertychange", Kf)) : e === "focusout" && Xf() } function c0(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return ls(Va) } function f0(e, t) { if (e === "click") return ls(t) } function h0(e, t) { if (e === "input" || e === "change") return ls(t) } function d0(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var ht = typeof Object.is == "function" ? Object.is : d0; function za(e, t) { if (ht(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), l = Object.keys(t); if (n.length !== l.length) return !1; for (l = 0; l < n.length; l++) { var r = n[l]; if (!jr.call(t, r) || !ht(e[r], t[r])) return !1 } return !0 } function Qf(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function Zf(e, t) { var n = Qf(e); e = 0; for (var l; n;) { if (n.nodeType === 3) { if (l = e + n.textContent.length, e <= t && l >= t) return { node: n, offset: t - e }; e = l } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = Qf(n) } } function Pf(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? Pf(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function Ff(e) { e = e != null && e.ownerDocument != null && e.ownerDocument.defaultView != null ? e.ownerDocument.defaultView : window; for (var t = Wl(e.document); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (n) e = t.contentWindow; else break; t = Wl(e.document) } return t } function Zr(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function m0(e, t) { var n = Ff(t); t = e.focusedElem; var l = e.selectionRange; if (n !== t && t && t.ownerDocument && Pf(t.ownerDocument.documentElement, t)) { if (l !== null && Zr(t)) { if (e = l.start, n = l.end, n === void 0 && (n = e), "selectionStart" in t) t.selectionStart = e, t.selectionEnd = Math.min(n, t.value.length); else if (n = (e = t.ownerDocument || document) && e.defaultView || window, n.getSelection) { n = n.getSelection(); var r = t.textContent.length, u = Math.min(l.start, r); l = l.end === void 0 ? u : Math.min(l.end, r), !n.extend && u > l && (r = l, l = u, u = r), r = Zf(t, u); var p = Zf(t, l); r && p && (n.rangeCount !== 1 || n.anchorNode !== r.node || n.anchorOffset !== r.offset || n.focusNode !== p.node || n.focusOffset !== p.offset) && (e = e.createRange(), e.setStart(r.node, r.offset), n.removeAllRanges(), u > l ? (n.addRange(e), n.extend(p.node, p.offset)) : (e.setEnd(p.node, p.offset), n.addRange(e))) } } for (e = [], n = t; n = n.parentNode;)n.nodeType === 1 && e.push({ element: n, left: n.scrollLeft, top: n.scrollTop }); for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)n = e[t], n.element.scrollLeft = n.left, n.element.scrollTop = n.top } } var p0 = Wt && "documentMode" in document && 11 >= document.documentMode, Ui = null, Pr = null, _a = null, Fr = !1; function Jf(e, t, n) { var l = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Fr || Ui == null || Ui !== Wl(l) || (l = Ui, "selectionStart" in l && Zr(l) ? l = { start: l.selectionStart, end: l.selectionEnd } : (l = (l.ownerDocument && l.ownerDocument.defaultView || window).getSelection(), l = { anchorNode: l.anchorNode, anchorOffset: l.anchorOffset, focusNode: l.focusNode, focusOffset: l.focusOffset }), _a && za(_a, l) || (_a = l, l = qs(Pr, "onSelect"), 0 < l.length && (t = new is("onSelect", "select", null, t, n), e.push({ event: t, listeners: l }), t.target = Ui))) } function ni(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var Ni = { animationend: ni("Animation", "AnimationEnd"), animationiteration: ni("Animation", "AnimationIteration"), animationstart: ni("Animation", "AnimationStart"), transitionrun: ni("Transition", "TransitionRun"), transitionstart: ni("Transition", "TransitionStart"), transitioncancel: ni("Transition", "TransitionCancel"), transitionend: ni("Transition", "TransitionEnd") }, Jr = {}, $f = {}; Wt && ($f = document.createElement("div").style, "AnimationEvent" in window || (delete Ni.animationend.animation, delete Ni.animationiteration.animation, delete Ni.animationstart.animation), "TransitionEvent" in window || delete Ni.transitionend.transition); function ii(e) { if (Jr[e]) return Jr[e]; if (!Ni[e]) return e; var t = Ni[e], n; for (n in t) if (t.hasOwnProperty(n) && n in $f) return Jr[e] = t[n]; return e } var Wf = ii("animationend"), If = ii("animationiteration"), eh = ii("animationstart"), g0 = ii("transitionrun"), y0 = ii("transitionstart"), v0 = ii("transitioncancel"), th = ii("transitionend"), nh = new Map, ih = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(" "); function Bt(e, t) { nh.set(e, t), ei(t, [e]) } var wt = [], Li = 0, $r = 0; function ss() { for (var e = Li, t = $r = Li = 0; t < e;) { var n = wt[t]; wt[t++] = null; var l = wt[t]; wt[t++] = null; var r = wt[t]; wt[t++] = null; var u = wt[t]; if (wt[t++] = null, l !== null && r !== null) { var p = l.pending; p === null ? r.next = r : (r.next = p.next, p.next = r), l.pending = r } u !== 0 && ah(n, r, u) } } function rs(e, t, n, l) { wt[Li++] = e, wt[Li++] = t, wt[Li++] = n, wt[Li++] = l, $r |= l, e.lanes |= l, e = e.alternate, e !== null && (e.lanes |= l) } function Wr(e, t, n, l) { return rs(e, t, n, l), os(e) } function jn(e, t) { return rs(e, null, null, t), os(e) } function ah(e, t, n) { e.lanes |= n; var l = e.alternate; l !== null && (l.lanes |= n); for (var r = !1, u = e.return; u !== null;)u.childLanes |= n, l = u.alternate, l !== null && (l.childLanes |= n), u.tag === 22 && (e = u.stateNode, e === null || e._visibility & 1 || (r = !0)), e = u, u = u.return; r && t !== null && e.tag === 3 && (u = e.stateNode, r = 31 - ft(n), u = u.hiddenUpdates, e = u[r], e === null ? u[r] = [t] : e.push(t), t.lane = n | 536870912) } function os(e) { if (50 < ll) throw ll = 0, lu = null, Error(o(185)); for (var t = e.return; t !== null;)e = t, t = e.return; return e.tag === 3 ? e.stateNode : null } var ki = {}, lh = new WeakMap; function At(e, t) { if (typeof e == "object" && e !== null) { var n = lh.get(e); return n !== void 0 ? n : (t = { value: e, source: t, stack: P(t) }, lh.set(e, t), t) } return { value: e, source: t, stack: P(t) } } var Hi = [], qi = 0, us = null, cs = 0, Et = [], jt = 0, ai = null, en = 1, tn = ""; function li(e, t) { Hi[qi++] = cs, Hi[qi++] = us, us = e, cs = t } function sh(e, t, n) { Et[jt++] = en, Et[jt++] = tn, Et[jt++] = ai, ai = e; var l = en; e = tn; var r = 32 - ft(l) - 1; l &= ~(1 << r), n += 1; var u = 32 - ft(t) + r; if (30 < u) { var p = r - r % 5; u = (l & (1 << p) - 1).toString(32), l >>= p, r -= p, en = 1 << 32 - ft(t) + r | n << r | l, tn = u + e } else en = 1 << u | n << r | l, tn = e } function Ir(e) { e.return !== null && (li(e, 1), sh(e, 1, 0)) } function eo(e) { for (; e === us;)us = Hi[--qi], Hi[qi] = null, cs = Hi[--qi], Hi[qi] = null; for (; e === ai;)ai = Et[--jt], Et[jt] = null, tn = Et[--jt], Et[jt] = null, en = Et[--jt], Et[jt] = null } var at = null, Ze = null, pe = !1, Ut = null, Xt = !1, to = Error(o(519)); function si(e) { var t = Error(o(418, "")); throw Na(At(t, e)), to } function rh(e) { var t = e.stateNode, n = e.type, l = e.memoizedProps; switch (t[$e] = e, t[rt] = l, n) { case "dialog": he("cancel", t), he("close", t); break; case "iframe": case "object": case "embed": he("load", t); break; case "video": case "audio": for (n = 0; n < rl.length; n++)he(rl[n], t); break; case "source": he("error", t); break; case "img": case "image": case "link": he("error", t), he("load", t); break; case "details": he("toggle", t); break; case "input": he("invalid", t), Tf(t, l.value, l.defaultValue, l.checked, l.defaultChecked, l.type, l.name, !0), $l(t); break; case "select": he("invalid", t); break; case "textarea": he("invalid", t), Af(t, l.value, l.defaultValue, l.children), $l(t) }n = l.children, typeof n != "string" && typeof n != "number" && typeof n != "bigint" || t.textContent === "" + n || l.suppressHydrationWarning === !0 || gm(t.textContent, n) ? (l.popover != null && (he("beforetoggle", t), he("toggle", t)), l.onScroll != null && he("scroll", t), l.onScrollEnd != null && he("scrollend", t), l.onClick != null && (t.onclick = Gs), t = !0) : t = !1, t || si(e) } function oh(e) { for (at = e.return; at;)switch (at.tag) { case 3: case 27: Xt = !0; return; case 5: case 13: Xt = !1; return; default: at = at.return } } function Ba(e) { if (e !== at) return !1; if (!pe) return oh(e), pe = !0, !1; var t = !1, n; if ((n = e.tag !== 3 && e.tag !== 27) && ((n = e.tag === 5) && (n = e.type, n = !(n !== "form" && n !== "button") || Tu(e.type, e.memoizedProps)), n = !n), n && (t = !0), t && Ze && si(e), oh(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(o(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) if (n = e.data, n === "/$") { if (t === 0) { Ze = Lt(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++; e = e.nextSibling } Ze = null } } else Ze = at ? Lt(e.stateNode.nextSibling) : null; return !0 } function Ua() { Ze = at = null, pe = !1 } function Na(e) { Ut === null ? Ut = [e] : Ut.push(e) } var La = Error(o(460)), uh = Error(o(474)), no = { then: function () { } }; function ch(e) { return e = e.status, e === "fulfilled" || e === "rejected" } function fs() { } function fh(e, t, n) { switch (n = e[n], n === void 0 ? e.push(t) : n !== t && (t.then(fs, fs), t = n), t.status) { case "fulfilled": return t.value; case "rejected": throw e = t.reason, e === La ? Error(o(483)) : e; default: if (typeof t.status == "string") t.then(fs, fs); else { if (e = Te, e !== null && 100 < e.shellSuspendCounter) throw Error(o(482)); e = t, e.status = "pending", e.then(function (l) { if (t.status === "pending") { var r = t; r.status = "fulfilled", r.value = l } }, function (l) { if (t.status === "pending") { var r = t; r.status = "rejected", r.reason = l } }) } switch (t.status) { case "fulfilled": return t.value; case "rejected": throw e = t.reason, e === La ? Error(o(483)) : e }throw ka = t, La } } var ka = null; function hh() { if (ka === null) throw Error(o(459)); var e = ka; return ka = null, e } var Gi = null, Ha = 0; function hs(e) { var t = Ha; return Ha += 1, Gi === null && (Gi = []), fh(Gi, e, t) } function qa(e, t) { t = t.props.ref, e.ref = t !== void 0 ? t : null } function ds(e, t) { throw t.$$typeof === f ? Error(o(525)) : (e = Object.prototype.toString.call(t), Error(o(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))) } function dh(e) { var t = e._init; return t(e._payload) } function mh(e) { function t(M, A) { if (e) { var R = M.deletions; R === null ? (M.deletions = [A], M.flags |= 16) : R.push(A) } } function n(M, A) { if (!e) return null; for (; A !== null;)t(M, A), A = A.sibling; return null } function l(M) { for (var A = new Map; M !== null;)M.key !== null ? A.set(M.key, M) : A.set(M.index, M), M = M.sibling; return A } function r(M, A) { return M = Ln(M, A), M.index = 0, M.sibling = null, M } function u(M, A, R) { return M.index = R, e ? (R = M.alternate, R !== null ? (R = R.index, R < A ? (M.flags |= 33554434, A) : R) : (M.flags |= 33554434, A)) : (M.flags |= 1048576, A) } function p(M) { return e && M.alternate === null && (M.flags |= 33554434), M } function b(M, A, R, k) { return A === null || A.tag !== 6 ? (A = $o(R, M.mode, k), A.return = M, A) : (A = r(A, R), A.return = M, A) } function T(M, A, R, k) { var Q = R.type; return Q === d ? U(M, A, R.props.children, k, R.key) : A !== null && (A.elementType === Q || typeof Q == "object" && Q !== null && Q.$$typeof === L && dh(Q) === A.type) ? (A = r(A, R.props), qa(A, R), A.return = M, A) : (A = Os(R.type, R.key, R.props, null, M.mode, k), qa(A, R), A.return = M, A) } function E(M, A, R, k) { return A === null || A.tag !== 4 || A.stateNode.containerInfo !== R.containerInfo || A.stateNode.implementation !== R.implementation ? (A = Wo(R, M.mode, k), A.return = M, A) : (A = r(A, R.children || []), A.return = M, A) } function U(M, A, R, k, Q) { return A === null || A.tag !== 7 ? (A = gi(R, M.mode, k, Q), A.return = M, A) : (A = r(A, R), A.return = M, A) } function H(M, A, R) { if (typeof A == "string" && A !== "" || typeof A == "number" || typeof A == "bigint") return A = $o("" + A, M.mode, R), A.return = M, A; if (typeof A == "object" && A !== null) { switch (A.$$typeof) { case h: return R = Os(A.type, A.key, A.props, null, M.mode, R), qa(R, A), R.return = M, R; case g: return A = Wo(A, M.mode, R), A.return = M, A; case L: var k = A._init; return A = k(A._payload), H(M, A, R) }if (ee(A) || ae(A)) return A = gi(A, M.mode, R, null), A.return = M, A; if (typeof A.then == "function") return H(M, hs(A), R); if (A.$$typeof === j) return H(M, Ms(M, A), R); ds(M, A) } return null } function V(M, A, R, k) { var Q = A !== null ? A.key : null; if (typeof R == "string" && R !== "" || typeof R == "number" || typeof R == "bigint") return Q !== null ? null : b(M, A, "" + R, k); if (typeof R == "object" && R !== null) { switch (R.$$typeof) { case h: return R.key === Q ? T(M, A, R, k) : null; case g: return R.key === Q ? E(M, A, R, k) : null; case L: return Q = R._init, R = Q(R._payload), V(M, A, R, k) }if (ee(R) || ae(R)) return Q !== null ? null : U(M, A, R, k, null); if (typeof R.then == "function") return V(M, A, hs(R), k); if (R.$$typeof === j) return V(M, A, Ms(M, R), k); ds(M, R) } return null } function B(M, A, R, k, Q) { if (typeof k == "string" && k !== "" || typeof k == "number" || typeof k == "bigint") return M = M.get(R) || null, b(A, M, "" + k, Q); if (typeof k == "object" && k !== null) { switch (k.$$typeof) { case h: return M = M.get(k.key === null ? R : k.key) || null, T(A, M, k, Q); case g: return M = M.get(k.key === null ? R : k.key) || null, E(A, M, k, Q); case L: var ue = k._init; return k = ue(k._payload), B(M, A, R, k, Q) }if (ee(k) || ae(k)) return M = M.get(R) || null, U(A, M, k, Q, null); if (typeof k.then == "function") return B(M, A, R, hs(k), Q); if (k.$$typeof === j) return B(M, A, R, Ms(A, k), Q); ds(A, k) } return null } function Z(M, A, R, k) { for (var Q = null, ue = null, $ = A, te = A = 0, Qe = null; $ !== null && te < R.length; te++) { $.index > te ? (Qe = $, $ = null) : Qe = $.sibling; var ge = V(M, $, R[te], k); if (ge === null) { $ === null && ($ = Qe); break } e && $ && ge.alternate === null && t(M, $), A = u(ge, A, te), ue === null ? Q = ge : ue.sibling = ge, ue = ge, $ = Qe } if (te === R.length) return n(M, $), pe && li(M, te), Q; if ($ === null) { for (; te < R.length; te++)$ = H(M, R[te], k), $ !== null && (A = u($, A, te), ue === null ? Q = $ : ue.sibling = $, ue = $); return pe && li(M, te), Q } for ($ = l($); te < R.length; te++)Qe = B($, M, te, R[te], k), Qe !== null && (e && Qe.alternate !== null && $.delete(Qe.key === null ? te : Qe.key), A = u(Qe, A, te), ue === null ? Q = Qe : ue.sibling = Qe, ue = Qe); return e && $.forEach(function (Kn) { return t(M, Kn) }), pe && li(M, te), Q } function le(M, A, R, k) { if (R == null) throw Error(o(151)); for (var Q = null, ue = null, $ = A, te = A = 0, Qe = null, ge = R.next(); $ !== null && !ge.done; te++, ge = R.next()) { $.index > te ? (Qe = $, $ = null) : Qe = $.sibling; var Kn = V(M, $, ge.value, k); if (Kn === null) { $ === null && ($ = Qe); break } e && $ && Kn.alternate === null && t(M, $), A = u(Kn, A, te), ue === null ? Q = Kn : ue.sibling = Kn, ue = Kn, $ = Qe } if (ge.done) return n(M, $), pe && li(M, te), Q; if ($ === null) { for (; !ge.done; te++, ge = R.next())ge = H(M, ge.value, k), ge !== null && (A = u(ge, A, te), ue === null ? Q = ge : ue.sibling = ge, ue = ge); return pe && li(M, te), Q } for ($ = l($); !ge.done; te++, ge = R.next())ge = B($, M, te, ge.value, k), ge !== null && (e && ge.alternate !== null && $.delete(ge.key === null ? te : ge.key), A = u(ge, A, te), ue === null ? Q = ge : ue.sibling = ge, ue = ge); return e && $.forEach(function (Vb) { return t(M, Vb) }), pe && li(M, te), Q } function ze(M, A, R, k) { if (typeof R == "object" && R !== null && R.type === d && R.key === null && (R = R.props.children), typeof R == "object" && R !== null) { switch (R.$$typeof) { case h: e: { for (var Q = R.key; A !== null;) { if (A.key === Q) { if (Q = R.type, Q === d) { if (A.tag === 7) { n(M, A.sibling), k = r(A, R.props.children), k.return = M, M = k; break e } } else if (A.elementType === Q || typeof Q == "object" && Q !== null && Q.$$typeof === L && dh(Q) === A.type) { n(M, A.sibling), k = r(A, R.props), qa(k, R), k.return = M, M = k; break e } n(M, A); break } else t(M, A); A = A.sibling } R.type === d ? (k = gi(R.props.children, M.mode, k, R.key), k.return = M, M = k) : (k = Os(R.type, R.key, R.props, null, M.mode, k), qa(k, R), k.return = M, M = k) } return p(M); case g: e: { for (Q = R.key; A !== null;) { if (A.key === Q) if (A.tag === 4 && A.stateNode.containerInfo === R.containerInfo && A.stateNode.implementation === R.implementation) { n(M, A.sibling), k = r(A, R.children || []), k.return = M, M = k; break e } else { n(M, A); break } else t(M, A); A = A.sibling } k = Wo(R, M.mode, k), k.return = M, M = k } return p(M); case L: return Q = R._init, R = Q(R._payload), ze(M, A, R, k) }if (ee(R)) return Z(M, A, R, k); if (ae(R)) { if (Q = ae(R), typeof Q != "function") throw Error(o(150)); return R = Q.call(R), le(M, A, R, k) } if (typeof R.then == "function") return ze(M, A, hs(R), k); if (R.$$typeof === j) return ze(M, A, Ms(M, R), k); ds(M, R) } return typeof R == "string" && R !== "" || typeof R == "number" || typeof R == "bigint" ? (R = "" + R, A !== null && A.tag === 6 ? (n(M, A.sibling), k = r(A, R), k.return = M, M = k) : (n(M, A), k = $o(R, M.mode, k), k.return = M, M = k), p(M)) : n(M, A) } return function (M, A, R, k) { try { Ha = 0; var Q = ze(M, A, R, k); return Gi = null, Q } catch ($) { if ($ === La) throw $; var ue = Ct(29, $, null, M.mode); return ue.lanes = k, ue.return = M, ue } finally { } } } var ri = mh(!0), ph = mh(!1), Yi = ve(null), ms = ve(0); function gh(e, t) { e = dn, Ee(ms, e), Ee(Yi, t), dn = e | t.baseLanes } function io() { Ee(ms, dn), Ee(Yi, Yi.current) } function ao() { dn = ms.current, Ne(Yi), Ne(ms) } var Dt = ve(null), Kt = null; function Dn(e) { var t = e.alternate; Ee(qe, qe.current & 1), Ee(Dt, e), Kt === null && (t === null || Yi.current !== null || t.memoizedState !== null) && (Kt = e) } function yh(e) { if (e.tag === 22) { if (Ee(qe, qe.current), Ee(Dt, e), Kt === null) { var t = e.alternate; t !== null && t.memoizedState !== null && (Kt = e) } } else Mn() } function Mn() { Ee(qe, qe.current), Ee(Dt, Dt.current) } function nn(e) { Ne(Dt), Kt === e && (Kt = null), Ne(qe) } var qe = ve(0); function ps(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var b0 = typeof AbortController < "u" ? AbortController : function () { var e = [], t = this.signal = { aborted: !1, addEventListener: function (n, l) { e.push(l) } }; this.abort = function () { t.aborted = !0, e.forEach(function (n) { return n() }) } }, x0 = i.unstable_scheduleCallback, S0 = i.unstable_NormalPriority, Ge = { $$typeof: j, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }; function lo() { return { controller: new b0, data: new Map, refCount: 0 } } function Ga(e) { e.refCount--, e.refCount === 0 && x0(S0, function () { e.controller.abort() }) } var Ya = null, so = 0, Xi = 0, Ki = null; function T0(e, t) { if (Ya === null) { var n = Ya = []; so = 0, Xi = du(), Ki = { status: "pending", value: void 0, then: function (l) { n.push(l) } } } return so++, t.then(vh, vh), t } function vh() { if (--so === 0 && Ya !== null) { Ki !== null && (Ki.status = "fulfilled"); var e = Ya; Ya = null, Xi = 0, Ki = null; for (var t = 0; t < e.length; t++)(0, e[t])() } } function w0(e, t) { var n = [], l = { status: "pending", value: null, reason: null, then: function (r) { n.push(r) } }; return e.then(function () { l.status = "fulfilled", l.value = t; for (var r = 0; r < n.length; r++)(0, n[r])(t) }, function (r) { for (l.status = "rejected", l.reason = r, r = 0; r < n.length; r++)(0, n[r])(void 0) }), l } var bh = Y.S; Y.S = function (e, t) { typeof t == "object" && t !== null && typeof t.then == "function" && T0(e, t), bh !== null && bh(e, t) }; var oi = ve(null); function ro() { var e = oi.current; return e !== null ? e : Te.pooledCache } function gs(e, t) { t === null ? Ee(oi, oi.current) : Ee(oi, t.pool) } function xh() { var e = ro(); return e === null ? null : { parent: Ge._currentValue, pool: e } } var Rn = 0, oe = null, be = null, Le = null, ys = !1, Qi = !1, ui = !1, vs = 0, Xa = 0, Zi = null, A0 = 0; function Be() { throw Error(o(321)) } function oo(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!ht(e[n], t[n])) return !1; return !0 } function uo(e, t, n, l, r, u) { return Rn = u, oe = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, Y.H = e === null || e.memoizedState === null ? ci : Cn, ui = !1, u = n(l, r), ui = !1, Qi && (u = Th(t, n, l, r)), Sh(e), u } function Sh(e) { Y.H = Qt; var t = be !== null && be.next !== null; if (Rn = 0, Le = be = oe = null, ys = !1, Xa = 0, Zi = null, t) throw Error(o(300)); e === null || Xe || (e = e.dependencies, e !== null && Ds(e) && (Xe = !0)) } function Th(e, t, n, l) { oe = e; var r = 0; do { if (Qi && (Zi = null), Xa = 0, Qi = !1, 25 <= r) throw Error(o(301)); if (r += 1, Le = be = null, e.updateQueue != null) { var u = e.updateQueue; u.lastEffect = null, u.events = null, u.stores = null, u.memoCache != null && (u.memoCache.index = 0) } Y.H = fi, u = t(n, l) } while (Qi); return u } function E0() { var e = Y.H, t = e.useState()[0]; return t = typeof t.then == "function" ? Ka(t) : t, e = e.useState()[0], (be !== null ? be.memoizedState : null) !== e && (oe.flags |= 1024), t } function co() { var e = vs !== 0; return vs = 0, e } function fo(e, t, n) { t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~n } function ho(e) { if (ys) { for (e = e.memoizedState; e !== null;) { var t = e.queue; t !== null && (t.pending = null), e = e.next } ys = !1 } Rn = 0, Le = be = oe = null, Qi = !1, Xa = vs = 0, Zi = null } function ut() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Le === null ? oe.memoizedState = Le = e : Le = Le.next = e, Le } function ke() { if (be === null) { var e = oe.alternate; e = e !== null ? e.memoizedState : null } else e = be.next; var t = Le === null ? oe.memoizedState : Le.next; if (t !== null) Le = t, be = e; else { if (e === null) throw oe.alternate === null ? Error(o(467)) : Error(o(310)); be = e, e = { memoizedState: be.memoizedState, baseState: be.baseState, baseQueue: be.baseQueue, queue: be.queue, next: null }, Le === null ? oe.memoizedState = Le = e : Le = Le.next = e } return Le } var bs; bs = function () { return { lastEffect: null, events: null, stores: null, memoCache: null } }; function Ka(e) { var t = Xa; return Xa += 1, Zi === null && (Zi = []), e = fh(Zi, e, t), t = oe, (Le === null ? t.memoizedState : Le.next) === null && (t = t.alternate, Y.H = t === null || t.memoizedState === null ? ci : Cn), e } function xs(e) { if (e !== null && typeof e == "object") { if (typeof e.then == "function") return Ka(e); if (e.$$typeof === j) return We(e) } throw Error(o(438, String(e))) } function mo(e) { var t = null, n = oe.updateQueue; if (n !== null && (t = n.memoCache), t == null) { var l = oe.alternate; l !== null && (l = l.updateQueue, l !== null && (l = l.memoCache, l != null && (t = { data: l.data.map(function (r) { return r.slice() }), index: 0 }))) } if (t == null && (t = { data: [], index: 0 }), n === null && (n = bs(), oe.updateQueue = n), n.memoCache = t, n = t.data[t.index], n === void 0) for (n = t.data[t.index] = Array(e), l = 0; l < e; l++)n[l] = J; return t.index++, n } function an(e, t) { return typeof t == "function" ? t(e) : t } function Ss(e) { var t = ke(); return po(t, be, e) } function po(e, t, n) { var l = e.queue; if (l === null) throw Error(o(311)); l.lastRenderedReducer = n; var r = e.baseQueue, u = l.pending; if (u !== null) { if (r !== null) { var p = r.next; r.next = u.next, u.next = p } t.baseQueue = r = u, l.pending = null } if (u = e.baseState, r === null) e.memoizedState = u; else { t = r.next; var b = p = null, T = null, E = t, U = !1; do { var H = E.lane & -536870913; if (H !== E.lane ? (me & H) === H : (Rn & H) === H) { var V = E.revertLane; if (V === 0) T !== null && (T = T.next = { lane: 0, revertLane: 0, action: E.action, hasEagerState: E.hasEagerState, eagerState: E.eagerState, next: null }), H === Xi && (U = !0); else if ((Rn & V) === V) { E = E.next, V === Xi && (U = !0); continue } else H = { lane: 0, revertLane: E.revertLane, action: E.action, hasEagerState: E.hasEagerState, eagerState: E.eagerState, next: null }, T === null ? (b = T = H, p = u) : T = T.next = H, oe.lanes |= V, kn |= V; H = E.action, ui && n(u, H), u = E.hasEagerState ? E.eagerState : n(u, H) } else V = { lane: H, revertLane: E.revertLane, action: E.action, hasEagerState: E.hasEagerState, eagerState: E.eagerState, next: null }, T === null ? (b = T = V, p = u) : T = T.next = V, oe.lanes |= H, kn |= H; E = E.next } while (E !== null && E !== t); if (T === null ? p = u : T.next = b, !ht(u, e.memoizedState) && (Xe = !0, U && (n = Ki, n !== null))) throw n; e.memoizedState = u, e.baseState = p, e.baseQueue = T, l.lastRenderedState = u } return r === null && (l.lanes = 0), [e.memoizedState, l.dispatch] } function go(e) { var t = ke(), n = t.queue; if (n === null) throw Error(o(311)); n.lastRenderedReducer = e; var l = n.dispatch, r = n.pending, u = t.memoizedState; if (r !== null) { n.pending = null; var p = r = r.next; do u = e(u, p.action), p = p.next; while (p !== r); ht(u, t.memoizedState) || (Xe = !0), t.memoizedState = u, t.baseQueue === null && (t.baseState = u), n.lastRenderedState = u } return [u, l] } function wh(e, t, n) { var l = oe, r = ke(), u = pe; if (u) { if (n === void 0) throw Error(o(407)); n = n() } else n = t(); var p = !ht((be || r).memoizedState, n); if (p && (r.memoizedState = n, Xe = !0), r = r.queue, bo(jh.bind(null, l, r, e), [e]), r.getSnapshot !== t || p || Le !== null && Le.memoizedState.tag & 1) { if (l.flags |= 2048, Pi(9, Eh.bind(null, l, r, n, t), { destroy: void 0 }, null), Te === null) throw Error(o(349)); u || Rn & 60 || Ah(l, t, n) } return n } function Ah(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = oe.updateQueue, t === null ? (t = bs(), oe.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function Eh(e, t, n, l) { t.value = n, t.getSnapshot = l, Dh(t) && Mh(e) } function jh(e, t, n) { return n(function () { Dh(t) && Mh(e) }) } function Dh(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !ht(e, n) } catch { return !0 } } function Mh(e) { var t = jn(e, 2); t !== null && lt(t, e, 2) } function yo(e) { var t = ut(); if (typeof e == "function") { var n = e; if (e = n(), ui) { wn(!0); try { n() } finally { wn(!1) } } } return t.memoizedState = t.baseState = e, t.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: an, lastRenderedState: e }, t } function Rh(e, t, n, l) { return e.baseState = n, po(e, be, typeof l == "function" ? l : an) } function j0(e, t, n, l, r) { if (As(e)) throw Error(o(485)); if (e = t.action, e !== null) { var u = { payload: r, action: e, next: null, isTransition: !0, status: "pending", value: null, reason: null, listeners: [], then: function (p) { u.listeners.push(p) } }; Y.T !== null ? n(!0) : u.isTransition = !1, l(u), n = t.pending, n === null ? (u.next = t.pending = u, Ch(t, u)) : (u.next = n.next, t.pending = n.next = u) } } function Ch(e, t) { var n = t.action, l = t.payload, r = e.state; if (t.isTransition) { var u = Y.T, p = {}; Y.T = p; try { var b = n(r, l), T = Y.S; T !== null && T(p, b), Oh(e, t, b) } catch (E) { vo(e, t, E) } finally { Y.T = u } } else try { u = n(r, l), Oh(e, t, u) } catch (E) { vo(e, t, E) } } function Oh(e, t, n) { n !== null && typeof n == "object" && typeof n.then == "function" ? n.then(function (l) { Vh(e, t, l) }, function (l) { return vo(e, t, l) }) : Vh(e, t, n) } function Vh(e, t, n) { t.status = "fulfilled", t.value = n, zh(t), e.state = n, t = e.pending, t !== null && (n = t.next, n === t ? e.pending = null : (n = n.next, t.next = n, Ch(e, n))) } function vo(e, t, n) { var l = e.pending; if (e.pending = null, l !== null) { l = l.next; do t.status = "rejected", t.reason = n, zh(t), t = t.next; while (t !== l) } e.action = null } function zh(e) { e = e.listeners; for (var t = 0; t < e.length; t++)(0, e[t])() } function _h(e, t) { return t } function Bh(e, t) { if (pe) { var n = Te.formState; if (n !== null) { e: { var l = oe; if (pe) { if (Ze) { t: { for (var r = Ze, u = Xt; r.nodeType !== 8;) { if (!u) { r = null; break t } if (r = Lt(r.nextSibling), r === null) { r = null; break t } } u = r.data, r = u === "F!" || u === "F" ? r : null } if (r) { Ze = Lt(r.nextSibling), l = r.data === "F!"; break e } } si(l) } l = !1 } l && (t = n[0]) } } return n = ut(), n.memoizedState = n.baseState = t, l = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: _h, lastRenderedState: t }, n.queue = l, n = Ih.bind(null, oe, l), l.dispatch = n, l = yo(!1), u = Ao.bind(null, oe, !1, l.queue), l = ut(), r = { state: t, dispatch: null, action: e, pending: null }, l.queue = r, n = j0.bind(null, oe, r, u, n), r.dispatch = n, l.memoizedState = e, [t, n, !1] } function Uh(e) { var t = ke(); return Nh(t, be, e) } function Nh(e, t, n) { t = po(e, t, _h)[0], e = Ss(an)[0], t = typeof t == "object" && t !== null && typeof t.then == "function" ? Ka(t) : t; var l = ke(), r = l.queue, u = r.dispatch; return n !== l.memoizedState && (oe.flags |= 2048, Pi(9, D0.bind(null, r, n), { destroy: void 0 }, null)), [t, u, e] } function D0(e, t) { e.action = t } function Lh(e) { var t = ke(), n = be; if (n !== null) return Nh(t, n, e); ke(), t = t.memoizedState, n = ke(); var l = n.queue.dispatch; return n.memoizedState = e, [t, l, !1] } function Pi(e, t, n, l) { return e = { tag: e, create: t, inst: n, deps: l, next: null }, t = oe.updateQueue, t === null && (t = bs(), oe.updateQueue = t), n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (l = n.next, n.next = e, e.next = l, t.lastEffect = e), e } function kh() { return ke().memoizedState } function Ts(e, t, n, l) { var r = ut(); oe.flags |= e, r.memoizedState = Pi(1 | t, n, { destroy: void 0 }, l === void 0 ? null : l) } function ws(e, t, n, l) { var r = ke(); l = l === void 0 ? null : l; var u = r.memoizedState.inst; be !== null && l !== null && oo(l, be.memoizedState.deps) ? r.memoizedState = Pi(t, n, u, l) : (oe.flags |= e, r.memoizedState = Pi(1 | t, n, u, l)) } function Hh(e, t) { Ts(8390656, 8, e, t) } function bo(e, t) { ws(2048, 8, e, t) } function qh(e, t) { return ws(4, 2, e, t) } function Gh(e, t) { return ws(4, 4, e, t) } function Yh(e, t) { if (typeof t == "function") { e = e(); var n = t(e); return function () { typeof n == "function" ? n() : t(null) } } if (t != null) return e = e(), t.current = e, function () { t.current = null } } function Xh(e, t, n) { n = n != null ? n.concat([e]) : null, ws(4, 4, Yh.bind(null, t, e), n) } function xo() { } function Kh(e, t) { var n = ke(); t = t === void 0 ? null : t; var l = n.memoizedState; return t !== null && oo(t, l[1]) ? l[0] : (n.memoizedState = [e, t], e) } function Qh(e, t) { var n = ke(); t = t === void 0 ? null : t; var l = n.memoizedState; if (t !== null && oo(t, l[1])) return l[0]; if (l = e(), ui) { wn(!0); try { e() } finally { wn(!1) } } return n.memoizedState = [l, t], l } function So(e, t, n) { return n === void 0 || Rn & 1073741824 ? e.memoizedState = t : (e.memoizedState = n, e = Pd(), oe.lanes |= e, kn |= e, n) } function Zh(e, t, n, l) { return ht(n, t) ? n : Yi.current !== null ? (e = So(e, n, l), ht(e, t) || (Xe = !0), e) : Rn & 42 ? (e = Pd(), oe.lanes |= e, kn |= e, t) : (Xe = !0, e.memoizedState = n) } function Ph(e, t, n, l, r) { var u = K.p; K.p = u !== 0 && 8 > u ? u : 8; var p = Y.T, b = {}; Y.T = b, Ao(e, !1, t, n); try { var T = r(), E = Y.S; if (E !== null && E(b, T), T !== null && typeof T == "object" && typeof T.then == "function") { var U = w0(T, l); Qa(e, t, U, gt(e)) } else Qa(e, t, l, gt(e)) } catch (H) { Qa(e, t, { then: function () { }, status: "rejected", reason: H }, gt()) } finally { K.p = u, Y.T = p } } function M0() { } function To(e, t, n, l) { if (e.tag !== 5) throw Error(o(476)); var r = Fh(e).queue; Ph(e, r, t, de, n === null ? M0 : function () { return Jh(e), n(l) }) } function Fh(e) { var t = e.memoizedState; if (t !== null) return t; t = { memoizedState: de, baseState: de, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: an, lastRenderedState: de }, next: null }; var n = {}; return t.next = { memoizedState: n, baseState: n, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: an, lastRenderedState: n }, next: null }, e.memoizedState = t, e = e.alternate, e !== null && (e.memoizedState = t), t } function Jh(e) { var t = Fh(e).next.queue; Qa(e, t, {}, gt()) } function wo() { return We(hl) } function $h() { return ke().memoizedState } function Wh() { return ke().memoizedState } function R0(e) { for (var t = e.return; t !== null;) { switch (t.tag) { case 24: case 3: var n = gt(); e = zn(n); var l = _n(t, e, n); l !== null && (lt(l, t, n), Fa(l, t, n)), t = { cache: lo() }, e.payload = t; return }t = t.return } } function C0(e, t, n) { var l = gt(); n = { lane: l, revertLane: 0, action: n, hasEagerState: !1, eagerState: null, next: null }, As(e) ? ed(t, n) : (n = Wr(e, t, n, l), n !== null && (lt(n, e, l), td(n, t, l))) } function Ih(e, t, n) { var l = gt(); Qa(e, t, n, l) } function Qa(e, t, n, l) { var r = { lane: l, revertLane: 0, action: n, hasEagerState: !1, eagerState: null, next: null }; if (As(e)) ed(t, r); else { var u = e.alternate; if (e.lanes === 0 && (u === null || u.lanes === 0) && (u = t.lastRenderedReducer, u !== null)) try { var p = t.lastRenderedState, b = u(p, n); if (r.hasEagerState = !0, r.eagerState = b, ht(b, p)) return rs(e, t, r, 0), Te === null && ss(), !1 } catch { } finally { } if (n = Wr(e, t, r, l), n !== null) return lt(n, e, l), td(n, t, l), !0 } return !1 } function Ao(e, t, n, l) { if (l = { lane: 2, revertLane: du(), action: l, hasEagerState: !1, eagerState: null, next: null }, As(e)) { if (t) throw Error(o(479)) } else t = Wr(e, n, l, 2), t !== null && lt(t, e, 2) } function As(e) { var t = e.alternate; return e === oe || t !== null && t === oe } function ed(e, t) { Qi = ys = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function td(e, t, n) { if (n & 4194176) { var l = t.lanes; l &= e.pendingLanes, n |= l, t.lanes = n, hf(e, n) } } var Qt = { readContext: We, use: xs, useCallback: Be, useContext: Be, useEffect: Be, useImperativeHandle: Be, useLayoutEffect: Be, useInsertionEffect: Be, useMemo: Be, useReducer: Be, useRef: Be, useState: Be, useDebugValue: Be, useDeferredValue: Be, useTransition: Be, useSyncExternalStore: Be, useId: Be }; Qt.useCacheRefresh = Be, Qt.useMemoCache = Be, Qt.useHostTransitionStatus = Be, Qt.useFormState = Be, Qt.useActionState = Be, Qt.useOptimistic = Be; var ci = { readContext: We, use: xs, useCallback: function (e, t) { return ut().memoizedState = [e, t === void 0 ? null : t], e }, useContext: We, useEffect: Hh, useImperativeHandle: function (e, t, n) { n = n != null ? n.concat([e]) : null, Ts(4194308, 4, Yh.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Ts(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { Ts(4, 2, e, t) }, useMemo: function (e, t) { var n = ut(); t = t === void 0 ? null : t; var l = e(); if (ui) { wn(!0); try { e() } finally { wn(!1) } } return n.memoizedState = [l, t], l }, useReducer: function (e, t, n) { var l = ut(); if (n !== void 0) { var r = n(t); if (ui) { wn(!0); try { n(t) } finally { wn(!1) } } } else r = t; return l.memoizedState = l.baseState = r, e = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: r }, l.queue = e, e = e.dispatch = C0.bind(null, oe, e), [l.memoizedState, e] }, useRef: function (e) { var t = ut(); return e = { current: e }, t.memoizedState = e }, useState: function (e) { e = yo(e); var t = e.queue, n = Ih.bind(null, oe, t); return t.dispatch = n, [e.memoizedState, n] }, useDebugValue: xo, useDeferredValue: function (e, t) { var n = ut(); return So(n, e, t) }, useTransition: function () { var e = yo(!1); return e = Ph.bind(null, oe, e.queue, !0, !1), ut().memoizedState = e, [!1, e] }, useSyncExternalStore: function (e, t, n) { var l = oe, r = ut(); if (pe) { if (n === void 0) throw Error(o(407)); n = n() } else { if (n = t(), Te === null) throw Error(o(349)); me & 60 || Ah(l, t, n) } r.memoizedState = n; var u = { value: n, getSnapshot: t }; return r.queue = u, Hh(jh.bind(null, l, u, e), [e]), l.flags |= 2048, Pi(9, Eh.bind(null, l, u, n, t), { destroy: void 0 }, null), n }, useId: function () { var e = ut(), t = Te.identifierPrefix; if (pe) { var n = tn, l = en; n = (l & ~(1 << 32 - ft(l) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = vs++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = A0++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, useCacheRefresh: function () { return ut().memoizedState = R0.bind(null, oe) } }; ci.useMemoCache = mo, ci.useHostTransitionStatus = wo, ci.useFormState = Bh, ci.useActionState = Bh, ci.useOptimistic = function (e) { var t = ut(); t.memoizedState = t.baseState = e; var n = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null }; return t.queue = n, t = Ao.bind(null, oe, !0, n), n.dispatch = t, [e, t] }; var Cn = { readContext: We, use: xs, useCallback: Kh, useContext: We, useEffect: bo, useImperativeHandle: Xh, useInsertionEffect: qh, useLayoutEffect: Gh, useMemo: Qh, useReducer: Ss, useRef: kh, useState: function () { return Ss(an) }, useDebugValue: xo, useDeferredValue: function (e, t) { var n = ke(); return Zh(n, be.memoizedState, e, t) }, useTransition: function () { var e = Ss(an)[0], t = ke().memoizedState; return [typeof e == "boolean" ? e : Ka(e), t] }, useSyncExternalStore: wh, useId: $h }; Cn.useCacheRefresh = Wh, Cn.useMemoCache = mo, Cn.useHostTransitionStatus = wo, Cn.useFormState = Uh, Cn.useActionState = Uh, Cn.useOptimistic = function (e, t) { var n = ke(); return Rh(n, be, e, t) }; var fi = { readContext: We, use: xs, useCallback: Kh, useContext: We, useEffect: bo, useImperativeHandle: Xh, useInsertionEffect: qh, useLayoutEffect: Gh, useMemo: Qh, useReducer: go, useRef: kh, useState: function () { return go(an) }, useDebugValue: xo, useDeferredValue: function (e, t) { var n = ke(); return be === null ? So(n, e, t) : Zh(n, be.memoizedState, e, t) }, useTransition: function () { var e = go(an)[0], t = ke().memoizedState; return [typeof e == "boolean" ? e : Ka(e), t] }, useSyncExternalStore: wh, useId: $h }; fi.useCacheRefresh = Wh, fi.useMemoCache = mo, fi.useHostTransitionStatus = wo, fi.useFormState = Lh, fi.useActionState = Lh, fi.useOptimistic = function (e, t) { var n = ke(); return be !== null ? Rh(n, be, e, t) : (n.baseState = e, [e, n.queue.dispatch]) }; function Eo(e, t, n, l) { t = e.memoizedState, n = n(l, t), n = n == null ? t : I({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var jo = { isMounted: function (e) { return (e = e._reactInternals) ? F(e) === e : !1 }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var l = gt(), r = zn(l); r.payload = t, n != null && (r.callback = n), t = _n(e, r, l), t !== null && (lt(t, e, l), Fa(t, e, l)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var l = gt(), r = zn(l); r.tag = 1, r.payload = t, n != null && (r.callback = n), t = _n(e, r, l), t !== null && (lt(t, e, l), Fa(t, e, l)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = gt(), l = zn(n); l.tag = 2, t != null && (l.callback = t), t = _n(e, l, n), t !== null && (lt(t, e, n), Fa(t, e, n)) } }; function nd(e, t, n, l, r, u, p) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(l, u, p) : t.prototype && t.prototype.isPureReactComponent ? !za(n, l) || !za(r, u) : !0 } function id(e, t, n, l) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, l), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, l), t.state !== e && jo.enqueueReplaceState(t, t.state, null) } function hi(e, t) { var n = t; if ("ref" in t) { n = {}; for (var l in t) l !== "ref" && (n[l] = t[l]) } if (e = e.defaultProps) { n === t && (n = I({}, n)); for (var r in e) n[r] === void 0 && (n[r] = e[r]) } return n } var Es = typeof reportError == "function" ? reportError : function (e) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var t = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof e == "object" && e !== null && typeof e.message == "string" ? String(e.message) : String(e), error: e }); if (!window.dispatchEvent(t)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", e); return } console.error(e) }; function ad(e) { Es(e) } function ld(e) { console.error(e) } function sd(e) { Es(e) } function js(e, t) { try { var n = e.onUncaughtError; n(t.value, { componentStack: t.stack }) } catch (l) { setTimeout(function () { throw l }) } } function rd(e, t, n) { try { var l = e.onCaughtError; l(n.value, { componentStack: n.stack, errorBoundary: t.tag === 1 ? t.stateNode : null }) } catch (r) { setTimeout(function () { throw r }) } } function Do(e, t, n) { return n = zn(n), n.tag = 3, n.payload = { element: null }, n.callback = function () { js(e, t) }, n } function od(e) { return e = zn(e), e.tag = 3, e } function ud(e, t, n, l) { var r = n.type.getDerivedStateFromError; if (typeof r == "function") { var u = l.value; e.payload = function () { return r(u) }, e.callback = function () { rd(t, n, l) } } var p = n.stateNode; p !== null && typeof p.componentDidCatch == "function" && (e.callback = function () { rd(t, n, l), typeof r != "function" && (Hn === null ? Hn = new Set([this]) : Hn.add(this)); var b = l.stack; this.componentDidCatch(l.value, { componentStack: b !== null ? b : "" }) }) } function O0(e, t, n, l, r) { if (n.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { if (t = n.alternate, t !== null && Pa(t, n, r, !0), n = Dt.current, n !== null) { switch (n.tag) { case 13: return Kt === null ? ou() : n.alternate === null && Ve === 0 && (Ve = 3), n.flags &= -257, n.flags |= 65536, n.lanes = r, l === no ? n.flags |= 16384 : (t = n.updateQueue, t === null ? n.updateQueue = new Set([l]) : t.add(l), cu(e, l, r)), !1; case 22: return n.flags |= 65536, l === no ? n.flags |= 16384 : (t = n.updateQueue, t === null ? (t = { transitions: null, markerInstances: null, retryQueue: new Set([l]) }, n.updateQueue = t) : (n = t.retryQueue, n === null ? t.retryQueue = new Set([l]) : n.add(l)), cu(e, l, r)), !1 }throw Error(o(435, n.tag)) } return cu(e, l, r), ou(), !1 } if (pe) return t = Dt.current, t !== null ? (!(t.flags & 65536) && (t.flags |= 256), t.flags |= 65536, t.lanes = r, l !== to && (e = Error(o(422), { cause: l }), Na(At(e, n)))) : (l !== to && (t = Error(o(423), { cause: l }), Na(At(t, n))), e = e.current.alternate, e.flags |= 65536, r &= -r, e.lanes |= r, l = At(l, n), r = Do(e.stateNode, l, r), Go(e, r), Ve !== 4 && (Ve = 2)), !1; var u = Error(o(520), { cause: l }); if (u = At(u, n), il === null ? il = [u] : il.push(u), Ve !== 4 && (Ve = 2), t === null) return !0; l = At(l, n), n = t; do { switch (n.tag) { case 3: return n.flags |= 65536, e = r & -r, n.lanes |= e, e = Do(n.stateNode, l, e), Go(n, e), !1; case 1: if (t = n.type, u = n.stateNode, (n.flags & 128) === 0 && (typeof t.getDerivedStateFromError == "function" || u !== null && typeof u.componentDidCatch == "function" && (Hn === null || !Hn.has(u)))) return n.flags |= 65536, r &= -r, n.lanes |= r, r = od(r), ud(r, e, n, l), Go(n, r), !1 }n = n.return } while (n !== null); return !1 } var cd = Error(o(461)), Xe = !1; function Pe(e, t, n, l) { t.child = e === null ? ph(t, null, n, l) : ri(t, e.child, n, l) } function fd(e, t, n, l, r) { n = n.render; var u = t.ref; if ("ref" in l) { var p = {}; for (var b in l) b !== "ref" && (p[b] = l[b]) } else p = l; return mi(t), l = uo(e, t, n, p, u, r), b = co(), e !== null && !Xe ? (fo(e, t, r), ln(e, t, r)) : (pe && b && Ir(t), t.flags |= 1, Pe(e, t, l, r), t.child) } function hd(e, t, n, l, r) { if (e === null) { var u = n.type; return typeof u == "function" && !Jo(u) && u.defaultProps === void 0 && n.compare === null ? (t.tag = 15, t.type = u, dd(e, t, u, l, r)) : (e = Os(n.type, null, l, t, t.mode, r), e.ref = t.ref, e.return = t, t.child = e) } if (u = e.child, !Uo(e, r)) { var p = u.memoizedProps; if (n = n.compare, n = n !== null ? n : za, n(p, l) && e.ref === t.ref) return ln(e, t, r) } return t.flags |= 1, e = Ln(u, l), e.ref = t.ref, e.return = t, t.child = e } function dd(e, t, n, l, r) { if (e !== null) { var u = e.memoizedProps; if (za(u, l) && e.ref === t.ref) if (Xe = !1, t.pendingProps = l = u, Uo(e, r)) e.flags & 131072 && (Xe = !0); else return t.lanes = e.lanes, ln(e, t, r) } return Mo(e, t, n, l, r) } function md(e, t, n) { var l = t.pendingProps, r = l.children, u = (t.stateNode._pendingVisibility & 2) !== 0, p = e !== null ? e.memoizedState : null; if (Za(e, t), l.mode === "hidden" || u) { if (t.flags & 128) { if (l = p !== null ? p.baseLanes | n : n, e !== null) { for (r = t.child = e.child, u = 0; r !== null;)u = u | r.lanes | r.childLanes, r = r.sibling; t.childLanes = u & ~l } else t.childLanes = 0, t.child = null; return pd(e, t, l, n) } if (n & 536870912) t.memoizedState = { baseLanes: 0, cachePool: null }, e !== null && gs(t, p !== null ? p.cachePool : null), p !== null ? gh(t, p) : io(), yh(t); else return t.lanes = t.childLanes = 536870912, pd(e, t, p !== null ? p.baseLanes | n : n, n) } else p !== null ? (gs(t, p.cachePool), gh(t, p), Mn(), t.memoizedState = null) : (e !== null && gs(t, null), io(), Mn()); return Pe(e, t, r, n), t.child } function pd(e, t, n, l) { var r = ro(); return r = r === null ? null : { parent: Ge._currentValue, pool: r }, t.memoizedState = { baseLanes: n, cachePool: r }, e !== null && gs(t, null), io(), yh(t), e !== null && Pa(e, t, l, !0), null } function Za(e, t) { var n = t.ref; if (n === null) e !== null && e.ref !== null && (t.flags |= 2097664); else { if (typeof n != "function" && typeof n != "object") throw Error(o(284)); (e === null || e.ref !== n) && (t.flags |= 2097664) } } function Mo(e, t, n, l, r) { return mi(t), n = uo(e, t, n, l, void 0, r), l = co(), e !== null && !Xe ? (fo(e, t, r), ln(e, t, r)) : (pe && l && Ir(t), t.flags |= 1, Pe(e, t, n, r), t.child) } function gd(e, t, n, l, r, u) { return mi(t), t.updateQueue = null, n = Th(t, l, n, r), Sh(e), l = co(), e !== null && !Xe ? (fo(e, t, u), ln(e, t, u)) : (pe && l && Ir(t), t.flags |= 1, Pe(e, t, n, u), t.child) } function yd(e, t, n, l, r) { if (mi(t), t.stateNode === null) { var u = ki, p = n.contextType; typeof p == "object" && p !== null && (u = We(p)), u = new n(l, u), t.memoizedState = u.state !== null && u.state !== void 0 ? u.state : null, u.updater = jo, t.stateNode = u, u._reactInternals = t, u = t.stateNode, u.props = l, u.state = t.memoizedState, u.refs = {}, Ho(t), p = n.contextType, u.context = typeof p == "object" && p !== null ? We(p) : ki, u.state = t.memoizedState, p = n.getDerivedStateFromProps, typeof p == "function" && (Eo(t, n, p, l), u.state = t.memoizedState), typeof n.getDerivedStateFromProps == "function" || typeof u.getSnapshotBeforeUpdate == "function" || typeof u.UNSAFE_componentWillMount != "function" && typeof u.componentWillMount != "function" || (p = u.state, typeof u.componentWillMount == "function" && u.componentWillMount(), typeof u.UNSAFE_componentWillMount == "function" && u.UNSAFE_componentWillMount(), p !== u.state && jo.enqueueReplaceState(u, u.state, null), $a(t, l, u, r), Ja(), u.state = t.memoizedState), typeof u.componentDidMount == "function" && (t.flags |= 4194308), l = !0 } else if (e === null) { u = t.stateNode; var b = t.memoizedProps, T = hi(n, b); u.props = T; var E = u.context, U = n.contextType; p = ki, typeof U == "object" && U !== null && (p = We(U)); var H = n.getDerivedStateFromProps; U = typeof H == "function" || typeof u.getSnapshotBeforeUpdate == "function", b = t.pendingProps !== b, U || typeof u.UNSAFE_componentWillReceiveProps != "function" && typeof u.componentWillReceiveProps != "function" || (b || E !== p) && id(t, u, l, p), Vn = !1; var V = t.memoizedState; u.state = V, $a(t, l, u, r), Ja(), E = t.memoizedState, b || V !== E || Vn ? (typeof H == "function" && (Eo(t, n, H, l), E = t.memoizedState), (T = Vn || nd(t, n, T, l, V, E, p)) ? (U || typeof u.UNSAFE_componentWillMount != "function" && typeof u.componentWillMount != "function" || (typeof u.componentWillMount == "function" && u.componentWillMount(), typeof u.UNSAFE_componentWillMount == "function" && u.UNSAFE_componentWillMount()), typeof u.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof u.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = l, t.memoizedState = E), u.props = l, u.state = E, u.context = p, l = T) : (typeof u.componentDidMount == "function" && (t.flags |= 4194308), l = !1) } else { u = t.stateNode, qo(e, t), p = t.memoizedProps, U = hi(n, p), u.props = U, H = t.pendingProps, V = u.context, E = n.contextType, T = ki, typeof E == "object" && E !== null && (T = We(E)), b = n.getDerivedStateFromProps, (E = typeof b == "function" || typeof u.getSnapshotBeforeUpdate == "function") || typeof u.UNSAFE_componentWillReceiveProps != "function" && typeof u.componentWillReceiveProps != "function" || (p !== H || V !== T) && id(t, u, l, T), Vn = !1, V = t.memoizedState, u.state = V, $a(t, l, u, r), Ja(); var B = t.memoizedState; p !== H || V !== B || Vn || e !== null && e.dependencies !== null && Ds(e.dependencies) ? (typeof b == "function" && (Eo(t, n, b, l), B = t.memoizedState), (U = Vn || nd(t, n, U, l, V, B, T) || e !== null && e.dependencies !== null && Ds(e.dependencies)) ? (E || typeof u.UNSAFE_componentWillUpdate != "function" && typeof u.componentWillUpdate != "function" || (typeof u.componentWillUpdate == "function" && u.componentWillUpdate(l, B, T), typeof u.UNSAFE_componentWillUpdate == "function" && u.UNSAFE_componentWillUpdate(l, B, T)), typeof u.componentDidUpdate == "function" && (t.flags |= 4), typeof u.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof u.componentDidUpdate != "function" || p === e.memoizedProps && V === e.memoizedState || (t.flags |= 4), typeof u.getSnapshotBeforeUpdate != "function" || p === e.memoizedProps && V === e.memoizedState || (t.flags |= 1024), t.memoizedProps = l, t.memoizedState = B), u.props = l, u.state = B, u.context = T, l = U) : (typeof u.componentDidUpdate != "function" || p === e.memoizedProps && V === e.memoizedState || (t.flags |= 4), typeof u.getSnapshotBeforeUpdate != "function" || p === e.memoizedProps && V === e.memoizedState || (t.flags |= 1024), l = !1) } return u = l, Za(e, t), l = (t.flags & 128) !== 0, u || l ? (u = t.stateNode, n = l && typeof n.getDerivedStateFromError != "function" ? null : u.render(), t.flags |= 1, e !== null && l ? (t.child = ri(t, e.child, null, r), t.child = ri(t, null, n, r)) : Pe(e, t, n, r), t.memoizedState = u.state, e = t.child) : e = ln(e, t, r), e } function vd(e, t, n, l) { return Ua(), t.flags |= 256, Pe(e, t, n, l), t.child } var Ro = { dehydrated: null, treeContext: null, retryLane: 0 }; function Co(e) { return { baseLanes: e, cachePool: xh() } } function Oo(e, t, n) { return e = e !== null ? e.childLanes & ~n : 0, t && (e |= Ot), e } function bd(e, t, n) { var l = t.pendingProps, r = !1, u = (t.flags & 128) !== 0, p; if ((p = u) || (p = e !== null && e.memoizedState === null ? !1 : (qe.current & 2) !== 0), p && (r = !0, t.flags &= -129), p = (t.flags & 32) !== 0, t.flags &= -33, e === null) { if (pe) { if (r ? Dn(t) : Mn(), pe) { var b = Ze, T; if (T = b) { e: { for (T = b, b = Xt; T.nodeType !== 8;) { if (!b) { b = null; break e } if (T = Lt(T.nextSibling), T === null) { b = null; break e } } b = T } b !== null ? (t.memoizedState = { dehydrated: b, treeContext: ai !== null ? { id: en, overflow: tn } : null, retryLane: 536870912 }, T = Ct(18, null, null, 0), T.stateNode = b, T.return = t, t.child = T, at = t, Ze = null, T = !0) : T = !1 } T || si(t) } if (b = t.memoizedState, b !== null && (b = b.dehydrated, b !== null)) return b.data === "$!" ? t.lanes = 16 : t.lanes = 536870912, null; nn(t) } return b = l.children, l = l.fallback, r ? (Mn(), r = t.mode, b = zo({ mode: "hidden", children: b }, r), l = gi(l, r, n, null), b.return = t, l.return = t, b.sibling = l, t.child = b, r = t.child, r.memoizedState = Co(n), r.childLanes = Oo(e, p, n), t.memoizedState = Ro, l) : (Dn(t), Vo(t, b)) } if (T = e.memoizedState, T !== null && (b = T.dehydrated, b !== null)) { if (u) t.flags & 256 ? (Dn(t), t.flags &= -257, t = _o(e, t, n)) : t.memoizedState !== null ? (Mn(), t.child = e.child, t.flags |= 128, t = null) : (Mn(), r = l.fallback, b = t.mode, l = zo({ mode: "visible", children: l.children }, b), r = gi(r, b, n, null), r.flags |= 2, l.return = t, r.return = t, l.sibling = r, t.child = l, ri(t, e.child, null, n), l = t.child, l.memoizedState = Co(n), l.childLanes = Oo(e, p, n), t.memoizedState = Ro, t = r); else if (Dn(t), b.data === "$!") { if (p = b.nextSibling && b.nextSibling.dataset, p) var E = p.dgst; p = E, l = Error(o(419)), l.stack = "", l.digest = p, Na({ value: l, source: null, stack: null }), t = _o(e, t, n) } else if (Xe || Pa(e, t, n, !1), p = (n & e.childLanes) !== 0, Xe || p) { if (p = Te, p !== null) { if (l = n & -n, l & 42) l = 1; else switch (l) { case 2: l = 1; break; case 8: l = 4; break; case 32: l = 16; break; case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: l = 64; break; case 268435456: l = 134217728; break; default: l = 0 }if (l = l & (p.suspendedLanes | n) ? 0 : l, l !== 0 && l !== T.retryLane) throw T.retryLane = l, jn(e, l), lt(p, e, l), cd } b.data === "$?" || ou(), t = _o(e, t, n) } else b.data === "$?" ? (t.flags |= 128, t.child = e.child, t = Q0.bind(null, e), b._reactRetry = t, t = null) : (e = T.treeContext, Ze = Lt(b.nextSibling), at = t, pe = !0, Ut = null, Xt = !1, e !== null && (Et[jt++] = en, Et[jt++] = tn, Et[jt++] = ai, en = e.id, tn = e.overflow, ai = t), t = Vo(t, l.children), t.flags |= 4096); return t } return r ? (Mn(), r = l.fallback, b = t.mode, T = e.child, E = T.sibling, l = Ln(T, { mode: "hidden", children: l.children }), l.subtreeFlags = T.subtreeFlags & 31457280, E !== null ? r = Ln(E, r) : (r = gi(r, b, n, null), r.flags |= 2), r.return = t, l.return = t, l.sibling = r, t.child = l, l = r, r = t.child, b = e.child.memoizedState, b === null ? b = Co(n) : (T = b.cachePool, T !== null ? (E = Ge._currentValue, T = T.parent !== E ? { parent: E, pool: E } : T) : T = xh(), b = { baseLanes: b.baseLanes | n, cachePool: T }), r.memoizedState = b, r.childLanes = Oo(e, p, n), t.memoizedState = Ro, l) : (Dn(t), n = e.child, e = n.sibling, n = Ln(n, { mode: "visible", children: l.children }), n.return = t, n.sibling = null, e !== null && (p = t.deletions, p === null ? (t.deletions = [e], t.flags |= 16) : p.push(e)), t.child = n, t.memoizedState = null, n) } function Vo(e, t) { return t = zo({ mode: "visible", children: t }, e.mode), t.return = e, e.child = t } function zo(e, t) { return Kd(e, t, 0, null) } function _o(e, t, n) { return ri(t, e.child, null, n), e = Vo(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function xd(e, t, n) { e.lanes |= t; var l = e.alternate; l !== null && (l.lanes |= t), Lo(e.return, t, n) } function Bo(e, t, n, l, r) { var u = e.memoizedState; u === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: l, tail: n, tailMode: r } : (u.isBackwards = t, u.rendering = null, u.renderingStartTime = 0, u.last = l, u.tail = n, u.tailMode = r) } function Sd(e, t, n) { var l = t.pendingProps, r = l.revealOrder, u = l.tail; if (Pe(e, t, l.children, n), l = qe.current, l & 2) l = l & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && xd(e, n, t); else if (e.tag === 19) xd(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } l &= 1 } switch (Ee(qe, l), r) { case "forwards": for (n = t.child, r = null; n !== null;)e = n.alternate, e !== null && ps(e) === null && (r = n), n = n.sibling; n = r, n === null ? (r = t.child, t.child = null) : (r = n.sibling, n.sibling = null), Bo(t, !1, r, n, u); break; case "backwards": for (n = null, r = t.child, t.child = null; r !== null;) { if (e = r.alternate, e !== null && ps(e) === null) { t.child = r; break } e = r.sibling, r.sibling = n, n = r, r = e } Bo(t, !0, n, null, u); break; case "together": Bo(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function ln(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), kn |= t.lanes, !(n & t.childLanes)) if (e !== null) { if (Pa(e, t, n, !1), (n & t.childLanes) === 0) return null } else return null; if (e !== null && t.child !== e.child) throw Error(o(153)); if (t.child !== null) { for (e = t.child, n = Ln(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = Ln(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function Uo(e, t) { return e.lanes & t ? !0 : (e = e.dependencies, !!(e !== null && Ds(e))) } function V0(e, t, n) { switch (t.tag) { case 3: Yl(t, t.stateNode.containerInfo), On(t, Ge, e.memoizedState.cache), Ua(); break; case 27: case 5: Er(t); break; case 4: Yl(t, t.stateNode.containerInfo); break; case 10: On(t, t.type, t.memoizedProps.value); break; case 13: var l = t.memoizedState; if (l !== null) return l.dehydrated !== null ? (Dn(t), t.flags |= 128, null) : n & t.child.childLanes ? bd(e, t, n) : (Dn(t), e = ln(e, t, n), e !== null ? e.sibling : null); Dn(t); break; case 19: var r = (e.flags & 128) !== 0; if (l = (n & t.childLanes) !== 0, l || (Pa(e, t, n, !1), l = (n & t.childLanes) !== 0), r) { if (l) return Sd(e, t, n); t.flags |= 128 } if (r = t.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), Ee(qe, qe.current), l) break; return null; case 22: case 23: return t.lanes = 0, md(e, t, n); case 24: On(t, Ge, e.memoizedState.cache) }return ln(e, t, n) } function Td(e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps) Xe = !0; else { if (!Uo(e, n) && !(t.flags & 128)) return Xe = !1, V0(e, t, n); Xe = !!(e.flags & 131072) } else Xe = !1, pe && t.flags & 1048576 && sh(t, cs, t.index); switch (t.lanes = 0, t.tag) { case 16: e: { e = t.pendingProps; var l = t.elementType, r = l._init; if (l = r(l._payload), t.type = l, typeof l == "function") Jo(l) ? (e = hi(l, e), t.tag = 1, t = yd(null, t, l, e, n)) : (t.tag = 0, t = Mo(null, t, l, e, n)); else { if (l != null) { if (r = l.$$typeof, r === D) { t.tag = 11, t = fd(null, t, l, e, n); break e } else if (r === O) { t.tag = 14, t = hd(null, t, l, e, n); break e } } throw t = W(l) || l, Error(o(306, t, "")) } } return t; case 0: return Mo(e, t, t.type, t.pendingProps, n); case 1: return l = t.type, r = hi(l, t.pendingProps), yd(e, t, l, r, n); case 3: e: { if (Yl(t, t.stateNode.containerInfo), e === null) throw Error(o(387)); var u = t.pendingProps; r = t.memoizedState, l = r.element, qo(e, t), $a(t, u, null, n); var p = t.memoizedState; if (u = p.cache, On(t, Ge, u), u !== r.cache && ko(t, [Ge], n, !0), Ja(), u = p.element, r.isDehydrated) if (r = { element: u, isDehydrated: !1, cache: p.cache }, t.updateQueue.baseState = r, t.memoizedState = r, t.flags & 256) { t = vd(e, t, u, n); break e } else if (u !== l) { l = At(Error(o(424)), t), Na(l), t = vd(e, t, u, n); break e } else for (Ze = Lt(t.stateNode.containerInfo.firstChild), at = t, pe = !0, Ut = null, Xt = !0, n = ph(t, null, u, n), t.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (Ua(), u === l) { t = ln(e, t, n); break e } Pe(e, t, u, n) } t = t.child } return t; case 26: return Za(e, t), e === null ? (n = Em(t.type, null, t.pendingProps, null)) ? t.memoizedState = n : pe || (n = t.type, e = t.pendingProps, l = Ys(Tn.current).createElement(n), l[$e] = t, l[rt] = e, Fe(l, n, e), Ye(l), t.stateNode = l) : t.memoizedState = Em(t.type, e.memoizedProps, t.pendingProps, e.memoizedState), null; case 27: return Er(t), e === null && pe && (l = t.stateNode = Tm(t.type, t.pendingProps, Tn.current), at = t, Xt = !0, Ze = Lt(l.firstChild)), l = t.pendingProps.children, e !== null || pe ? Pe(e, t, l, n) : t.child = ri(t, null, l, n), Za(e, t), t.child; case 5: return e === null && pe && ((r = l = Ze) && (l = ob(l, t.type, t.pendingProps, Xt), l !== null ? (t.stateNode = l, at = t, Ze = Lt(l.firstChild), Xt = !1, r = !0) : r = !1), r || si(t)), Er(t), r = t.type, u = t.pendingProps, p = e !== null ? e.memoizedProps : null, l = u.children, Tu(r, u) ? l = null : p !== null && Tu(r, p) && (t.flags |= 32), t.memoizedState !== null && (r = uo(e, t, E0, null, null, n), hl._currentValue = r), Za(e, t), Pe(e, t, l, n), t.child; case 6: return e === null && pe && ((e = n = Ze) && (n = ub(n, t.pendingProps, Xt), n !== null ? (t.stateNode = n, at = t, Ze = null, e = !0) : e = !1), e || si(t)), null; case 13: return bd(e, t, n); case 4: return Yl(t, t.stateNode.containerInfo), l = t.pendingProps, e === null ? t.child = ri(t, null, l, n) : Pe(e, t, l, n), t.child; case 11: return fd(e, t, t.type, t.pendingProps, n); case 7: return Pe(e, t, t.pendingProps, n), t.child; case 8: return Pe(e, t, t.pendingProps.children, n), t.child; case 12: return Pe(e, t, t.pendingProps.children, n), t.child; case 10: return l = t.pendingProps, On(t, t.type, l.value), Pe(e, t, l.children, n), t.child; case 9: return r = t.type._context, l = t.pendingProps.children, mi(t), r = We(r), l = l(r), t.flags |= 1, Pe(e, t, l, n), t.child; case 14: return hd(e, t, t.type, t.pendingProps, n); case 15: return dd(e, t, t.type, t.pendingProps, n); case 19: return Sd(e, t, n); case 22: return md(e, t, n); case 24: return mi(t), l = We(Ge), e === null ? (r = ro(), r === null && (r = Te, u = lo(), r.pooledCache = u, u.refCount++, u !== null && (r.pooledCacheLanes |= n), r = u), t.memoizedState = { parent: l, cache: r }, Ho(t), On(t, Ge, r)) : (e.lanes & n && (qo(e, t), $a(t, null, null, n), Ja()), r = e.memoizedState, u = t.memoizedState, r.parent !== l ? (r = { parent: l, cache: l }, t.memoizedState = r, t.lanes === 0 && (t.memoizedState = t.updateQueue.baseState = r), On(t, Ge, l)) : (l = u.cache, On(t, Ge, l), l !== r.cache && ko(t, [Ge], n, !0))), Pe(e, t, t.pendingProps.children, n), t.child; case 29: throw t.pendingProps }throw Error(o(156, t.tag)) } var No = ve(null), di = null, sn = null; function On(e, t, n) { Ee(No, t._currentValue), t._currentValue = n } function rn(e) { e._currentValue = No.current, Ne(No) } function Lo(e, t, n) { for (; e !== null;) { var l = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, l !== null && (l.childLanes |= t)) : l !== null && (l.childLanes & t) !== t && (l.childLanes |= t), e === n) break; e = e.return } } function ko(e, t, n, l) { var r = e.child; for (r !== null && (r.return = e); r !== null;) { var u = r.dependencies; if (u !== null) { var p = r.child; u = u.firstContext; e: for (; u !== null;) { var b = u; u = r; for (var T = 0; T < t.length; T++)if (b.context === t[T]) { u.lanes |= n, b = u.alternate, b !== null && (b.lanes |= n), Lo(u.return, n, e), l || (p = null); break e } u = b.next } } else if (r.tag === 18) { if (p = r.return, p === null) throw Error(o(341)); p.lanes |= n, u = p.alternate, u !== null && (u.lanes |= n), Lo(p, n, e), p = null } else p = r.child; if (p !== null) p.return = r; else for (p = r; p !== null;) { if (p === e) { p = null; break } if (r = p.sibling, r !== null) { r.return = p.return, p = r; break } p = p.return } r = p } } function Pa(e, t, n, l) { e = null; for (var r = t, u = !1; r !== null;) { if (!u) { if (r.flags & 524288) u = !0; else if (r.flags & 262144) break } if (r.tag === 10) { var p = r.alternate; if (p === null) throw Error(o(387)); if (p = p.memoizedProps, p !== null) { var b = r.type; ht(r.pendingProps.value, p.value) || (e !== null ? e.push(b) : e = [b]) } } else if (r === Gl.current) { if (p = r.alternate, p === null) throw Error(o(387)); p.memoizedState.memoizedState !== r.memoizedState.memoizedState && (e !== null ? e.push(hl) : e = [hl]) } r = r.return } e !== null && ko(t, e, n, l), t.flags |= 262144 } function Ds(e) { for (e = e.firstContext; e !== null;) { if (!ht(e.context._currentValue, e.memoizedValue)) return !0; e = e.next } return !1 } function mi(e) { di = e, sn = null, e = e.dependencies, e !== null && (e.firstContext = null) } function We(e) { return wd(di, e) } function Ms(e, t) { return di === null && mi(e), wd(e, t) } function wd(e, t) { var n = t._currentValue; if (t = { context: t, memoizedValue: n, next: null }, sn === null) { if (e === null) throw Error(o(308)); sn = t, e.dependencies = { lanes: 0, firstContext: t }, e.flags |= 524288 } else sn = sn.next = t; return n } var Vn = !1; function Ho(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null } } function qo(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, callbacks: null }) } function zn(e) { return { lane: e, tag: 0, payload: null, callback: null, next: null } } function _n(e, t, n) { var l = e.updateQueue; if (l === null) return null; if (l = l.shared, De & 2) { var r = l.pending; return r === null ? t.next = t : (t.next = r.next, r.next = t), l.pending = t, t = os(e), ah(e, null, n), t } return rs(e, l, t, n), os(e) } function Fa(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194176) !== 0)) { var l = t.lanes; l &= e.pendingLanes, n |= l, t.lanes = n, hf(e, n) } } function Go(e, t) { var n = e.updateQueue, l = e.alternate; if (l !== null && (l = l.updateQueue, n === l)) { var r = null, u = null; if (n = n.firstBaseUpdate, n !== null) { do { var p = { lane: n.lane, tag: n.tag, payload: n.payload, callback: null, next: null }; u === null ? r = u = p : u = u.next = p, n = n.next } while (n !== null); u === null ? r = u = t : u = u.next = t } else r = u = t; n = { baseState: l.baseState, firstBaseUpdate: r, lastBaseUpdate: u, shared: l.shared, callbacks: l.callbacks }, e.updateQueue = n; return } e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } var Yo = !1; function Ja() { if (Yo) { var e = Ki; if (e !== null) throw e } } function $a(e, t, n, l) { Yo = !1; var r = e.updateQueue; Vn = !1; var u = r.firstBaseUpdate, p = r.lastBaseUpdate, b = r.shared.pending; if (b !== null) { r.shared.pending = null; var T = b, E = T.next; T.next = null, p === null ? u = E : p.next = E, p = T; var U = e.alternate; U !== null && (U = U.updateQueue, b = U.lastBaseUpdate, b !== p && (b === null ? U.firstBaseUpdate = E : b.next = E, U.lastBaseUpdate = T)) } if (u !== null) { var H = r.baseState; p = 0, U = E = T = null, b = u; do { var V = b.lane & -536870913, B = V !== b.lane; if (B ? (me & V) === V : (l & V) === V) { V !== 0 && V === Xi && (Yo = !0), U !== null && (U = U.next = { lane: 0, tag: b.tag, payload: b.payload, callback: null, next: null }); e: { var Z = e, le = b; V = t; var ze = n; switch (le.tag) { case 1: if (Z = le.payload, typeof Z == "function") { H = Z.call(ze, H, V); break e } H = Z; break e; case 3: Z.flags = Z.flags & -65537 | 128; case 0: if (Z = le.payload, V = typeof Z == "function" ? Z.call(ze, H, V) : Z, V == null) break e; H = I({}, H, V); break e; case 2: Vn = !0 } } V = b.callback, V !== null && (e.flags |= 64, B && (e.flags |= 8192), B = r.callbacks, B === null ? r.callbacks = [V] : B.push(V)) } else B = { lane: V, tag: b.tag, payload: b.payload, callback: b.callback, next: null }, U === null ? (E = U = B, T = H) : U = U.next = B, p |= V; if (b = b.next, b === null) { if (b = r.shared.pending, b === null) break; B = b, b = B.next, B.next = null, r.lastBaseUpdate = B, r.shared.pending = null } } while (!0); U === null && (T = H), r.baseState = T, r.firstBaseUpdate = E, r.lastBaseUpdate = U, u === null && (r.shared.lanes = 0), kn |= p, e.lanes = p, e.memoizedState = H } } function Ad(e, t) { if (typeof e != "function") throw Error(o(191, e)); e.call(t) } function Ed(e, t) { var n = e.callbacks; if (n !== null) for (e.callbacks = null, e = 0; e < n.length; e++)Ad(n[e], t) } function Wa(e, t) { try { var n = t.updateQueue, l = n !== null ? n.lastEffect : null; if (l !== null) { var r = l.next; n = r; do { if ((n.tag & e) === e) { l = void 0; var u = n.create, p = n.inst; l = u(), p.destroy = l } n = n.next } while (n !== r) } } catch (b) { Se(t, t.return, b) } } function Bn(e, t, n) { try { var l = t.updateQueue, r = l !== null ? l.lastEffect : null; if (r !== null) { var u = r.next; l = u; do { if ((l.tag & e) === e) { var p = l.inst, b = p.destroy; if (b !== void 0) { p.destroy = void 0, r = t; var T = n; try { b() } catch (E) { Se(r, T, E) } } } l = l.next } while (l !== u) } } catch (E) { Se(t, t.return, E) } } function jd(e) { var t = e.updateQueue; if (t !== null) { var n = e.stateNode; try { Ed(t, n) } catch (l) { Se(e, e.return, l) } } } function Dd(e, t, n) { n.props = hi(e.type, e.memoizedProps), n.state = e.memoizedState; try { n.componentWillUnmount() } catch (l) { Se(e, t, l) } } function pi(e, t) { try { var n = e.ref; if (n !== null) { var l = e.stateNode; switch (e.tag) { case 26: case 27: case 5: var r = l; break; default: r = l }typeof n == "function" ? e.refCleanup = n(r) : n.current = r } } catch (u) { Se(e, t, u) } } function dt(e, t) { var n = e.ref, l = e.refCleanup; if (n !== null) if (typeof l == "function") try { l() } catch (r) { Se(e, t, r) } finally { e.refCleanup = null, e = e.alternate, e != null && (e.refCleanup = null) } else if (typeof n == "function") try { n(null) } catch (r) { Se(e, t, r) } else n.current = null } function Md(e) { var t = e.type, n = e.memoizedProps, l = e.stateNode; try { e: switch (t) { case "button": case "input": case "select": case "textarea": n.autoFocus && l.focus(); break e; case "img": n.src ? l.src = n.src : n.srcSet && (l.srcset = n.srcSet) } } catch (r) { Se(e, e.return, r) } } function Rd(e, t, n) { try { var l = e.stateNode; ib(l, e.type, n, t), l[rt] = t } catch (r) { Se(e, e.return, r) } } function Cd(e) { return e.tag === 5 || e.tag === 3 || e.tag === 26 || e.tag === 27 || e.tag === 4 } function Xo(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || Cd(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 27 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function Ko(e, t, n) { var l = e.tag; if (l === 5 || l === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = Gs)); else if (l !== 4 && l !== 27 && (e = e.child, e !== null)) for (Ko(e, t, n), e = e.sibling; e !== null;)Ko(e, t, n), e = e.sibling } function Rs(e, t, n) { var l = e.tag; if (l === 5 || l === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (l !== 4 && l !== 27 && (e = e.child, e !== null)) for (Rs(e, t, n), e = e.sibling; e !== null;)Rs(e, t, n), e = e.sibling } var on = !1, Oe = !1, Qo = !1, Od = typeof WeakSet == "function" ? WeakSet : Set, Ke = null, Vd = !1; function z0(e, t) { if (e = e.containerInfo, xu = Fs, e = Ff(e), Zr(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || window; var l = n.getSelection && n.getSelection(); if (l && l.rangeCount !== 0) { n = l.anchorNode; var r = l.anchorOffset, u = l.focusNode; l = l.focusOffset; try { n.nodeType, u.nodeType } catch { n = null; break e } var p = 0, b = -1, T = -1, E = 0, U = 0, H = e, V = null; t: for (; ;) { for (var B; H !== n || r !== 0 && H.nodeType !== 3 || (b = p + r), H !== u || l !== 0 && H.nodeType !== 3 || (T = p + l), H.nodeType === 3 && (p += H.nodeValue.length), (B = H.firstChild) !== null;)V = H, H = B; for (; ;) { if (H === e) break t; if (V === n && ++E === r && (b = p), V === u && ++U === l && (T = p), (B = H.nextSibling) !== null) break; H = V, V = H.parentNode } H = B } n = b === -1 || T === -1 ? null : { start: b, end: T } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (Su = { focusedElem: e, selectionRange: n }, Fs = !1, Ke = t; Ke !== null;)if (t = Ke, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, Ke = e; else for (; Ke !== null;) { switch (t = Ke, u = t.alternate, e = t.flags, t.tag) { case 0: break; case 11: case 15: break; case 1: if (e & 1024 && u !== null) { e = void 0, n = t, r = u.memoizedProps, u = u.memoizedState, l = n.stateNode; try { var Z = hi(n.type, r, n.elementType === n.type); e = l.getSnapshotBeforeUpdate(Z, u), l.__reactInternalSnapshotBeforeUpdate = e } catch (le) { Se(n, n.return, le) } } break; case 3: if (e & 1024) { if (e = t.stateNode.containerInfo, n = e.nodeType, n === 9) Eu(e); else if (n === 1) switch (e.nodeName) { case "HEAD": case "HTML": case "BODY": Eu(e); break; default: e.textContent = "" } } break; case 5: case 26: case 27: case 6: case 4: case 17: break; default: if (e & 1024) throw Error(o(163)) }if (e = t.sibling, e !== null) { e.return = t.return, Ke = e; break } Ke = t.return } return Z = Vd, Vd = !1, Z } function zd(e, t, n) { var l = n.flags; switch (n.tag) { case 0: case 11: case 15: cn(e, n), l & 4 && Wa(5, n); break; case 1: if (cn(e, n), l & 4) if (e = n.stateNode, t === null) try { e.componentDidMount() } catch (b) { Se(n, n.return, b) } else { var r = hi(n.type, t.memoizedProps); t = t.memoizedState; try { e.componentDidUpdate(r, t, e.__reactInternalSnapshotBeforeUpdate) } catch (b) { Se(n, n.return, b) } } l & 64 && jd(n), l & 512 && pi(n, n.return); break; case 3: if (cn(e, n), l & 64 && (l = n.updateQueue, l !== null)) { if (e = null, n.child !== null) switch (n.child.tag) { case 27: case 5: e = n.child.stateNode; break; case 1: e = n.child.stateNode }try { Ed(l, e) } catch (b) { Se(n, n.return, b) } } break; case 26: cn(e, n), l & 512 && pi(n, n.return); break; case 27: case 5: cn(e, n), t === null && l & 4 && Md(n), l & 512 && pi(n, n.return); break; case 12: cn(e, n); break; case 13: cn(e, n), l & 4 && Ud(e, n); break; case 22: if (r = n.memoizedState !== null || on, !r) { t = t !== null && t.memoizedState !== null || Oe; var u = on, p = Oe; on = r, (Oe = t) && !p ? Un(e, n, (n.subtreeFlags & 8772) !== 0) : cn(e, n), on = u, Oe = p } l & 512 && (n.memoizedProps.mode === "manual" ? pi(n, n.return) : dt(n, n.return)); break; default: cn(e, n) } } function _d(e) { var t = e.alternate; t !== null && (e.alternate = null, _d(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && Or(t)), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } var He = null, mt = !1; function un(e, t, n) { for (n = n.child; n !== null;)Bd(e, t, n), n = n.sibling } function Bd(e, t, n) { if (ct && typeof ct.onCommitFiberUnmount == "function") try { ct.onCommitFiberUnmount(Sa, n) } catch { } switch (n.tag) { case 26: Oe || dt(n, t), un(e, t, n), n.memoizedState ? n.memoizedState.count-- : n.stateNode && (n = n.stateNode, n.parentNode.removeChild(n)); break; case 27: Oe || dt(n, t); var l = He, r = mt; for (He = n.stateNode, un(e, t, n), n = n.stateNode, t = n.attributes; t.length;)n.removeAttributeNode(t[0]); Or(n), He = l, mt = r; break; case 5: Oe || dt(n, t); case 6: r = He; var u = mt; if (He = null, un(e, t, n), He = r, mt = u, He !== null) if (mt) try { e = He, l = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(l) : e.removeChild(l) } catch (p) { Se(n, t, p) } else try { He.removeChild(n.stateNode) } catch (p) { Se(n, t, p) } break; case 18: He !== null && (mt ? (t = He, n = n.stateNode, t.nodeType === 8 ? Au(t.parentNode, n) : t.nodeType === 1 && Au(t, n), gl(t)) : Au(He, n.stateNode)); break; case 4: l = He, r = mt, He = n.stateNode.containerInfo, mt = !0, un(e, t, n), He = l, mt = r; break; case 0: case 11: case 14: case 15: Oe || Bn(2, n, t), Oe || Bn(4, n, t), un(e, t, n); break; case 1: Oe || (dt(n, t), l = n.stateNode, typeof l.componentWillUnmount == "function" && Dd(n, t, l)), un(e, t, n); break; case 21: un(e, t, n); break; case 22: Oe || dt(n, t), Oe = (l = Oe) || n.memoizedState !== null, un(e, t, n), Oe = l; break; default: un(e, t, n) } } function Ud(e, t) { if (t.memoizedState === null && (e = t.alternate, e !== null && (e = e.memoizedState, e !== null && (e = e.dehydrated, e !== null)))) try { gl(e) } catch (n) { Se(t, t.return, n) } } function _0(e) { switch (e.tag) { case 13: case 19: var t = e.stateNode; return t === null && (t = e.stateNode = new Od), t; case 22: return e = e.stateNode, t = e._retryCache, t === null && (t = e._retryCache = new Od), t; default: throw Error(o(435, e.tag)) } } function Zo(e, t) { var n = _0(e); t.forEach(function (l) { var r = Z0.bind(null, e, l); n.has(l) || (n.add(l), l.then(r, r)) }) } function Mt(e, t) { var n = t.deletions; if (n !== null) for (var l = 0; l < n.length; l++) { var r = n[l], u = e, p = t, b = p; e: for (; b !== null;) { switch (b.tag) { case 27: case 5: He = b.stateNode, mt = !1; break e; case 3: He = b.stateNode.containerInfo, mt = !0; break e; case 4: He = b.stateNode.containerInfo, mt = !0; break e }b = b.return } if (He === null) throw Error(o(160)); Bd(u, p, r), He = null, mt = !1, u = r.alternate, u !== null && (u.return = null), r.return = null } if (t.subtreeFlags & 13878) for (t = t.child; t !== null;)Nd(t, e), t = t.sibling } var Nt = null; function Nd(e, t) { var n = e.alternate, l = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: Mt(t, e), Rt(e), l & 4 && (Bn(3, e, e.return), Wa(3, e), Bn(5, e, e.return)); break; case 1: Mt(t, e), Rt(e), l & 512 && (Oe || n === null || dt(n, n.return)), l & 64 && on && (e = e.updateQueue, e !== null && (l = e.callbacks, l !== null && (n = e.shared.hiddenCallbacks, e.shared.hiddenCallbacks = n === null ? l : n.concat(l)))); break; case 26: var r = Nt; if (Mt(t, e), Rt(e), l & 512 && (Oe || n === null || dt(n, n.return)), l & 4) { var u = n !== null ? n.memoizedState : null; if (l = e.memoizedState, n === null) if (l === null) if (e.stateNode === null) { e: { l = e.type, n = e.memoizedProps, r = r.ownerDocument || r; t: switch (l) { case "title": u = r.getElementsByTagName("title")[0], (!u || u[Aa] || u[$e] || u.namespaceURI === "http://www.w3.org/2000/svg" || u.hasAttribute("itemprop")) && (u = r.createElement(l), r.head.insertBefore(u, r.querySelector("head > title"))), Fe(u, l, n), u[$e] = e, Ye(u), l = u; break e; case "link": var p = Mm("link", "href", r).get(l + (n.href || "")); if (p) { for (var b = 0; b < p.length; b++)if (u = p[b], u.getAttribute("href") === (n.href == null ? null : n.href) && u.getAttribute("rel") === (n.rel == null ? null : n.rel) && u.getAttribute("title") === (n.title == null ? null : n.title) && u.getAttribute("crossorigin") === (n.crossOrigin == null ? null : n.crossOrigin)) { p.splice(b, 1); break t } } u = r.createElement(l), Fe(u, l, n), r.head.appendChild(u); break; case "meta": if (p = Mm("meta", "content", r).get(l + (n.content || ""))) { for (b = 0; b < p.length; b++)if (u = p[b], u.getAttribute("content") === (n.content == null ? null : "" + n.content) && u.getAttribute("name") === (n.name == null ? null : n.name) && u.getAttribute("property") === (n.property == null ? null : n.property) && u.getAttribute("http-equiv") === (n.httpEquiv == null ? null : n.httpEquiv) && u.getAttribute("charset") === (n.charSet == null ? null : n.charSet)) { p.splice(b, 1); break t } } u = r.createElement(l), Fe(u, l, n), r.head.appendChild(u); break; default: throw Error(o(468, l)) }u[$e] = e, Ye(u), l = u } e.stateNode = l } else Rm(r, e.type, e.stateNode); else e.stateNode = Dm(r, l, e.memoizedProps); else u !== l ? (u === null ? n.stateNode !== null && (n = n.stateNode, n.parentNode.removeChild(n)) : u.count--, l === null ? Rm(r, e.type, e.stateNode) : Dm(r, l, e.memoizedProps)) : l === null && e.stateNode !== null && Rd(e, e.memoizedProps, n.memoizedProps) } break; case 27: if (l & 4 && e.alternate === null) { r = e.stateNode, u = e.memoizedProps; try { for (var T = r.firstChild; T;) { var E = T.nextSibling, U = T.nodeName; T[Aa] || U === "HEAD" || U === "BODY" || U === "SCRIPT" || U === "STYLE" || U === "LINK" && T.rel.toLowerCase() === "stylesheet" || r.removeChild(T), T = E } for (var H = e.type, V = r.attributes; V.length;)r.removeAttributeNode(V[0]); Fe(r, H, u), r[$e] = e, r[rt] = u } catch (Z) { Se(e, e.return, Z) } } case 5: if (Mt(t, e), Rt(e), l & 512 && (Oe || n === null || dt(n, n.return)), e.flags & 32) { r = e.stateNode; try { Vi(r, "") } catch (Z) { Se(e, e.return, Z) } } l & 4 && e.stateNode != null && (r = e.memoizedProps, Rd(e, r, n !== null ? n.memoizedProps : r)), l & 1024 && (Qo = !0); break; case 6: if (Mt(t, e), Rt(e), l & 4) { if (e.stateNode === null) throw Error(o(162)); l = e.memoizedProps, n = e.stateNode; try { n.nodeValue = l } catch (Z) { Se(e, e.return, Z) } } break; case 3: if (Qs = null, r = Nt, Nt = Xs(t.containerInfo), Mt(t, e), Nt = r, Rt(e), l & 4 && n !== null && n.memoizedState.isDehydrated) try { gl(t.containerInfo) } catch (Z) { Se(e, e.return, Z) } Qo && (Qo = !1, Ld(e)); break; case 4: l = Nt, Nt = Xs(e.stateNode.containerInfo), Mt(t, e), Rt(e), Nt = l; break; case 12: Mt(t, e), Rt(e); break; case 13: Mt(t, e), Rt(e), e.child.flags & 8192 && e.memoizedState !== null != (n !== null && n.memoizedState !== null) && (nu = Yt()), l & 4 && (l = e.updateQueue, l !== null && (e.updateQueue = null, Zo(e, l))); break; case 22: if (l & 512 && (Oe || n === null || dt(n, n.return)), T = e.memoizedState !== null, E = n !== null && n.memoizedState !== null, U = on, H = Oe, on = U || T, Oe = H || E, Mt(t, e), Oe = H, on = U, Rt(e), t = e.stateNode, t._current = e, t._visibility &= -3, t._visibility |= t._pendingVisibility & 2, l & 8192 && (t._visibility = T ? t._visibility & -2 : t._visibility | 1, T && (t = on || Oe, n === null || E || t || Fi(e)), e.memoizedProps === null || e.memoizedProps.mode !== "manual")) e: for (n = null, t = e; ;) { if (t.tag === 5 || t.tag === 26 || t.tag === 27) { if (n === null) { E = n = t; try { if (r = E.stateNode, T) u = r.style, typeof u.setProperty == "function" ? u.setProperty("display", "none", "important") : u.display = "none"; else { p = E.stateNode, b = E.memoizedProps.style; var B = b != null && b.hasOwnProperty("display") ? b.display : null; p.style.display = B == null || typeof B == "boolean" ? "" : ("" + B).trim() } } catch (Z) { Se(E, E.return, Z) } } } else if (t.tag === 6) { if (n === null) { E = t; try { E.stateNode.nodeValue = T ? "" : E.memoizedProps } catch (Z) { Se(E, E.return, Z) } } } else if ((t.tag !== 22 && t.tag !== 23 || t.memoizedState === null || t === e) && t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break e; for (; t.sibling === null;) { if (t.return === null || t.return === e) break e; n === t && (n = null), t = t.return } n === t && (n = null), t.sibling.return = t.return, t = t.sibling } l & 4 && (l = e.updateQueue, l !== null && (n = l.retryQueue, n !== null && (l.retryQueue = null, Zo(e, n)))); break; case 19: Mt(t, e), Rt(e), l & 4 && (l = e.updateQueue, l !== null && (e.updateQueue = null, Zo(e, l))); break; case 21: break; default: Mt(t, e), Rt(e) } } function Rt(e) { var t = e.flags; if (t & 2) { try { if (e.tag !== 27) { e: { for (var n = e.return; n !== null;) { if (Cd(n)) { var l = n; break e } n = n.return } throw Error(o(160)) } switch (l.tag) { case 27: var r = l.stateNode, u = Xo(e); Rs(e, u, r); break; case 5: var p = l.stateNode; l.flags & 32 && (Vi(p, ""), l.flags &= -33); var b = Xo(e); Rs(e, b, p); break; case 3: case 4: var T = l.stateNode.containerInfo, E = Xo(e); Ko(e, E, T); break; default: throw Error(o(161)) } } } catch (U) { Se(e, e.return, U) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function Ld(e) { if (e.subtreeFlags & 1024) for (e = e.child; e !== null;) { var t = e; Ld(t), t.tag === 5 && t.flags & 1024 && t.stateNode.reset(), e = e.sibling } } function cn(e, t) { if (t.subtreeFlags & 8772) for (t = t.child; t !== null;)zd(e, t.alternate, t), t = t.sibling } function Fi(e) { for (e = e.child; e !== null;) { var t = e; switch (t.tag) { case 0: case 11: case 14: case 15: Bn(4, t, t.return), Fi(t); break; case 1: dt(t, t.return); var n = t.stateNode; typeof n.componentWillUnmount == "function" && Dd(t, t.return, n), Fi(t); break; case 26: case 27: case 5: dt(t, t.return), Fi(t); break; case 22: dt(t, t.return), t.memoizedState === null && Fi(t); break; default: Fi(t) }e = e.sibling } } function Un(e, t, n) { for (n = n && (t.subtreeFlags & 8772) !== 0, t = t.child; t !== null;) { var l = t.alternate, r = e, u = t, p = u.flags; switch (u.tag) { case 0: case 11: case 15: Un(r, u, n), Wa(4, u); break; case 1: if (Un(r, u, n), l = u, r = l.stateNode, typeof r.componentDidMount == "function") try { r.componentDidMount() } catch (E) { Se(l, l.return, E) } if (l = u, r = l.updateQueue, r !== null) { var b = l.stateNode; try { var T = r.shared.hiddenCallbacks; if (T !== null) for (r.shared.hiddenCallbacks = null, r = 0; r < T.length; r++)Ad(T[r], b) } catch (E) { Se(l, l.return, E) } } n && p & 64 && jd(u), pi(u, u.return); break; case 26: case 27: case 5: Un(r, u, n), n && l === null && p & 4 && Md(u), pi(u, u.return); break; case 12: Un(r, u, n); break; case 13: Un(r, u, n), n && p & 4 && Ud(r, u); break; case 22: u.memoizedState === null && Un(r, u, n), pi(u, u.return); break; default: Un(r, u, n) }t = t.sibling } } function Po(e, t) { var n = null; e !== null && e.memoizedState !== null && e.memoizedState.cachePool !== null && (n = e.memoizedState.cachePool.pool), e = null, t.memoizedState !== null && t.memoizedState.cachePool !== null && (e = t.memoizedState.cachePool.pool), e !== n && (e != null && e.refCount++, n != null && Ga(n)) } function Fo(e, t) { e = null, t.alternate !== null && (e = t.alternate.memoizedState.cache), t = t.memoizedState.cache, t !== e && (t.refCount++, e != null && Ga(e)) } function Nn(e, t, n, l) { if (t.subtreeFlags & 10256) for (t = t.child; t !== null;)kd(e, t, n, l), t = t.sibling } function kd(e, t, n, l) { var r = t.flags; switch (t.tag) { case 0: case 11: case 15: Nn(e, t, n, l), r & 2048 && Wa(9, t); break; case 3: Nn(e, t, n, l), r & 2048 && (e = null, t.alternate !== null && (e = t.alternate.memoizedState.cache), t = t.memoizedState.cache, t !== e && (t.refCount++, e != null && Ga(e))); break; case 12: if (r & 2048) { Nn(e, t, n, l), e = t.stateNode; try { var u = t.memoizedProps, p = u.id, b = u.onPostCommit; typeof b == "function" && b(p, t.alternate === null ? "mount" : "update", e.passiveEffectDuration, -0) } catch (T) { Se(t, t.return, T) } } else Nn(e, t, n, l); break; case 23: break; case 22: u = t.stateNode, t.memoizedState !== null ? u._visibility & 4 ? Nn(e, t, n, l) : Ia(e, t) : u._visibility & 4 ? Nn(e, t, n, l) : (u._visibility |= 4, Ji(e, t, n, l, (t.subtreeFlags & 10256) !== 0)), r & 2048 && Po(t.alternate, t); break; case 24: Nn(e, t, n, l), r & 2048 && Fo(t.alternate, t); break; default: Nn(e, t, n, l) } } function Ji(e, t, n, l, r) { for (r = r && (t.subtreeFlags & 10256) !== 0, t = t.child; t !== null;) { var u = e, p = t, b = n, T = l, E = p.flags; switch (p.tag) { case 0: case 11: case 15: Ji(u, p, b, T, r), Wa(8, p); break; case 23: break; case 22: var U = p.stateNode; p.memoizedState !== null ? U._visibility & 4 ? Ji(u, p, b, T, r) : Ia(u, p) : (U._visibility |= 4, Ji(u, p, b, T, r)), r && E & 2048 && Po(p.alternate, p); break; case 24: Ji(u, p, b, T, r), r && E & 2048 && Fo(p.alternate, p); break; default: Ji(u, p, b, T, r) }t = t.sibling } } function Ia(e, t) { if (t.subtreeFlags & 10256) for (t = t.child; t !== null;) { var n = e, l = t, r = l.flags; switch (l.tag) { case 22: Ia(n, l), r & 2048 && Po(l.alternate, l); break; case 24: Ia(n, l), r & 2048 && Fo(l.alternate, l); break; default: Ia(n, l) }t = t.sibling } } var el = 8192; function $i(e) { if (e.subtreeFlags & el) for (e = e.child; e !== null;)Hd(e), e = e.sibling } function Hd(e) { switch (e.tag) { case 26: $i(e), e.flags & el && e.memoizedState !== null && Tb(Nt, e.memoizedState, e.memoizedProps); break; case 5: $i(e); break; case 3: case 4: var t = Nt; Nt = Xs(e.stateNode.containerInfo), $i(e), Nt = t; break; case 22: e.memoizedState === null && (t = e.alternate, t !== null && t.memoizedState !== null ? (t = el, el = 16777216, $i(e), el = t) : $i(e)); break; default: $i(e) } } function qd(e) { var t = e.alternate; if (t !== null && (e = t.child, e !== null)) { t.child = null; do t = e.sibling, e.sibling = null, e = t; while (e !== null) } } function tl(e) { var t = e.deletions; if (e.flags & 16) { if (t !== null) for (var n = 0; n < t.length; n++) { var l = t[n]; Ke = l, Yd(l, e) } qd(e) } if (e.subtreeFlags & 10256) for (e = e.child; e !== null;)Gd(e), e = e.sibling } function Gd(e) { switch (e.tag) { case 0: case 11: case 15: tl(e), e.flags & 2048 && Bn(9, e, e.return); break; case 3: tl(e); break; case 12: tl(e); break; case 22: var t = e.stateNode; e.memoizedState !== null && t._visibility & 4 && (e.return === null || e.return.tag !== 13) ? (t._visibility &= -5, Cs(e)) : tl(e); break; default: tl(e) } } function Cs(e) { var t = e.deletions; if (e.flags & 16) { if (t !== null) for (var n = 0; n < t.length; n++) { var l = t[n]; Ke = l, Yd(l, e) } qd(e) } for (e = e.child; e !== null;) { switch (t = e, t.tag) { case 0: case 11: case 15: Bn(8, t, t.return), Cs(t); break; case 22: n = t.stateNode, n._visibility & 4 && (n._visibility &= -5, Cs(t)); break; default: Cs(t) }e = e.sibling } } function Yd(e, t) { for (; Ke !== null;) { var n = Ke; switch (n.tag) { case 0: case 11: case 15: Bn(8, n, t); break; case 23: case 22: if (n.memoizedState !== null && n.memoizedState.cachePool !== null) { var l = n.memoizedState.cachePool.pool; l != null && l.refCount++ } break; case 24: Ga(n.memoizedState.cache) }if (l = n.child, l !== null) l.return = n, Ke = l; else e: for (n = e; Ke !== null;) { l = Ke; var r = l.sibling, u = l.return; if (_d(l), l === n) { Ke = null; break e } if (r !== null) { r.return = u, Ke = r; break e } Ke = u } } } function B0(e, t, n, l) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = l, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Ct(e, t, n, l) { return new B0(e, t, n, l) } function Jo(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function Ln(e, t) { var n = e.alternate; return n === null ? (n = Ct(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 31457280, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n.refCleanup = e.refCleanup, n } function Xd(e, t) { e.flags &= 31457282; var n = e.alternate; return n === null ? (e.childLanes = 0, e.lanes = t, e.child = null, e.subtreeFlags = 0, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null) : (e.childLanes = n.childLanes, e.lanes = n.lanes, e.child = n.child, e.subtreeFlags = 0, e.deletions = null, e.memoizedProps = n.memoizedProps, e.memoizedState = n.memoizedState, e.updateQueue = n.updateQueue, e.type = n.type, t = n.dependencies, e.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }), e } function Os(e, t, n, l, r, u) { var p = 0; if (l = e, typeof e == "function") Jo(e) && (p = 1); else if (typeof e == "string") p = xb(e, n, Gt.current) ? 26 : e === "html" || e === "head" || e === "body" ? 27 : 5; else e: switch (e) { case d: return gi(n.children, r, u, t); case m: p = 8, r |= 24; break; case v: return e = Ct(12, n, t, r | 2), e.elementType = v, e.lanes = u, e; case z: return e = Ct(13, n, t, r), e.elementType = z, e.lanes = u, e; case _: return e = Ct(19, n, t, r), e.elementType = _, e.lanes = u, e; case N: return Kd(n, r, u, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case x: case j: p = 10; break e; case S: p = 9; break e; case D: p = 11; break e; case O: p = 14; break e; case L: p = 16, l = null; break e }p = 29, n = Error(o(130, e === null ? "null" : typeof e, "")), l = null }return t = Ct(p, n, t, r), t.elementType = e, t.type = l, t.lanes = u, t } function gi(e, t, n, l) { return e = Ct(7, e, l, t), e.lanes = n, e } function Kd(e, t, n, l) { e = Ct(22, e, l, t), e.elementType = N, e.lanes = n; var r = { _visibility: 1, _pendingVisibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null, _current: null, detach: function () { var u = r._current; if (u === null) throw Error(o(456)); if (!(r._pendingVisibility & 2)) { var p = jn(u, 2); p !== null && (r._pendingVisibility |= 2, lt(p, u, 2)) } }, attach: function () { var u = r._current; if (u === null) throw Error(o(456)); if (r._pendingVisibility & 2) { var p = jn(u, 2); p !== null && (r._pendingVisibility &= -3, lt(p, u, 2)) } } }; return e.stateNode = r, e } function $o(e, t, n) { return e = Ct(6, e, null, t), e.lanes = n, e } function Wo(e, t, n) { return t = Ct(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function fn(e) { e.flags |= 4 } function Qd(e, t) { if (t.type !== "stylesheet" || t.state.loading & 4) e.flags &= -16777217; else if (e.flags |= 16777216, !Cm(t)) { if (t = Dt.current, t !== null && ((me & 4194176) === me ? Kt !== null : (me & 62914560) !== me && !(me & 536870912) || t !== Kt)) throw ka = no, uh; e.flags |= 8192 } } function Vs(e, t) { t !== null && (e.flags |= 4), e.flags & 16384 && (t = e.tag !== 22 ? cf() : 536870912, e.lanes |= t, Ii |= t) } function nl(e, t) { if (!pe) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var l = null; n !== null;)n.alternate !== null && (l = n), n = n.sibling; l === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : l.sibling = null } } function je(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, l = 0; if (t) for (var r = e.child; r !== null;)n |= r.lanes | r.childLanes, l |= r.subtreeFlags & 31457280, l |= r.flags & 31457280, r.return = e, r = r.sibling; else for (r = e.child; r !== null;)n |= r.lanes | r.childLanes, l |= r.subtreeFlags, l |= r.flags, r.return = e, r = r.sibling; return e.subtreeFlags |= l, e.childLanes = n, t } function U0(e, t, n) { var l = t.pendingProps; switch (eo(t), t.tag) { case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return je(t), null; case 1: return je(t), null; case 3: return n = t.stateNode, l = null, e !== null && (l = e.memoizedState.cache), t.memoizedState.cache !== l && (t.flags |= 2048), rn(Ge), ji(), n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), (e === null || e.child === null) && (Ba(t) ? fn(t) : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Ut !== null && (su(Ut), Ut = null))), je(t), null; case 26: return n = t.memoizedState, e === null ? (fn(t), n !== null ? (je(t), Qd(t, n)) : (je(t), t.flags &= -16777217)) : n ? n !== e.memoizedState ? (fn(t), je(t), Qd(t, n)) : (je(t), t.flags &= -16777217) : (e.memoizedProps !== l && fn(t), je(t), t.flags &= -16777217), null; case 27: Xl(t), n = Tn.current; var r = t.type; if (e !== null && t.stateNode != null) e.memoizedProps !== l && fn(t); else { if (!l) { if (t.stateNode === null) throw Error(o(166)); return je(t), null } e = Gt.current, Ba(t) ? rh(t) : (e = Tm(r, l, n), t.stateNode = e, fn(t)) } return je(t), null; case 5: if (Xl(t), n = t.type, e !== null && t.stateNode != null) e.memoizedProps !== l && fn(t); else { if (!l) { if (t.stateNode === null) throw Error(o(166)); return je(t), null } if (e = Gt.current, Ba(t)) rh(t); else { switch (r = Ys(Tn.current), e) { case 1: e = r.createElementNS("http://www.w3.org/2000/svg", n); break; case 2: e = r.createElementNS("http://www.w3.org/1998/Math/MathML", n); break; default: switch (n) { case "svg": e = r.createElementNS("http://www.w3.org/2000/svg", n); break; case "math": e = r.createElementNS("http://www.w3.org/1998/Math/MathML", n); break; case "script": e = r.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild); break; case "select": e = typeof l.is == "string" ? r.createElement("select", { is: l.is }) : r.createElement("select"), l.multiple ? e.multiple = !0 : l.size && (e.size = l.size); break; default: e = typeof l.is == "string" ? r.createElement(n, { is: l.is }) : r.createElement(n) } }e[$e] = t, e[rt] = l; e: for (r = t.child; r !== null;) { if (r.tag === 5 || r.tag === 6) e.appendChild(r.stateNode); else if (r.tag !== 4 && r.tag !== 27 && r.child !== null) { r.child.return = r, r = r.child; continue } if (r === t) break e; for (; r.sibling === null;) { if (r.return === null || r.return === t) break e; r = r.return } r.sibling.return = r.return, r = r.sibling } t.stateNode = e; e: switch (Fe(e, n, l), n) { case "button": case "input": case "select": case "textarea": e = !!l.autoFocus; break e; case "img": e = !0; break e; default: e = !1 }e && fn(t) } } return je(t), t.flags &= -16777217, null; case 6: if (e && t.stateNode != null) e.memoizedProps !== l && fn(t); else { if (typeof l != "string" && t.stateNode === null) throw Error(o(166)); if (e = Tn.current, Ba(t)) { if (e = t.stateNode, n = t.memoizedProps, l = null, r = at, r !== null) switch (r.tag) { case 27: case 5: l = r.memoizedProps }e[$e] = t, e = !!(e.nodeValue === n || l !== null && l.suppressHydrationWarning === !0 || gm(e.nodeValue, n)), e || si(t) } else e = Ys(e).createTextNode(l), e[$e] = t, t.stateNode = e } return je(t), null; case 13: if (l = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (r = Ba(t), l !== null && l.dehydrated !== null) { if (e === null) { if (!r) throw Error(o(318)); if (r = t.memoizedState, r = r !== null ? r.dehydrated : null, !r) throw Error(o(317)); r[$e] = t } else Ua(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; je(t), r = !1 } else Ut !== null && (su(Ut), Ut = null), r = !0; if (!r) return t.flags & 256 ? (nn(t), t) : (nn(t), null) } if (nn(t), t.flags & 128) return t.lanes = n, t; if (n = l !== null, e = e !== null && e.memoizedState !== null, n) { l = t.child, r = null, l.alternate !== null && l.alternate.memoizedState !== null && l.alternate.memoizedState.cachePool !== null && (r = l.alternate.memoizedState.cachePool.pool); var u = null; l.memoizedState !== null && l.memoizedState.cachePool !== null && (u = l.memoizedState.cachePool.pool), u !== r && (l.flags |= 2048) } return n !== e && n && (t.child.flags |= 8192), Vs(t, t.updateQueue), je(t), null; case 4: return ji(), e === null && yu(t.stateNode.containerInfo), je(t), null; case 10: return rn(t.type), je(t), null; case 19: if (Ne(qe), r = t.memoizedState, r === null) return je(t), null; if (l = (t.flags & 128) !== 0, u = r.rendering, u === null) if (l) nl(r, !1); else { if (Ve !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (u = ps(e), u !== null) { for (t.flags |= 128, nl(r, !1), e = u.updateQueue, t.updateQueue = e, Vs(t, e), t.subtreeFlags = 0, e = n, n = t.child; n !== null;)Xd(n, e), n = n.sibling; return Ee(qe, qe.current & 1 | 2), t.child } e = e.sibling } r.tail !== null && Yt() > zs && (t.flags |= 128, l = !0, nl(r, !1), t.lanes = 4194304) } else { if (!l) if (e = ps(u), e !== null) { if (t.flags |= 128, l = !0, e = e.updateQueue, t.updateQueue = e, Vs(t, e), nl(r, !0), r.tail === null && r.tailMode === "hidden" && !u.alternate && !pe) return je(t), null } else 2 * Yt() - r.renderingStartTime > zs && n !== 536870912 && (t.flags |= 128, l = !0, nl(r, !1), t.lanes = 4194304); r.isBackwards ? (u.sibling = t.child, t.child = u) : (e = r.last, e !== null ? e.sibling = u : t.child = u, r.last = u) } return r.tail !== null ? (t = r.tail, r.rendering = t, r.tail = t.sibling, r.renderingStartTime = Yt(), t.sibling = null, e = qe.current, Ee(qe, l ? e & 1 | 2 : e & 1), t) : (je(t), null); case 22: case 23: return nn(t), ao(), l = t.memoizedState !== null, e !== null ? e.memoizedState !== null !== l && (t.flags |= 8192) : l && (t.flags |= 8192), l ? n & 536870912 && !(t.flags & 128) && (je(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : je(t), n = t.updateQueue, n !== null && Vs(t, n.retryQueue), n = null, e !== null && e.memoizedState !== null && e.memoizedState.cachePool !== null && (n = e.memoizedState.cachePool.pool), l = null, t.memoizedState !== null && t.memoizedState.cachePool !== null && (l = t.memoizedState.cachePool.pool), l !== n && (t.flags |= 2048), e !== null && Ne(oi), null; case 24: return n = null, e !== null && (n = e.memoizedState.cache), t.memoizedState.cache !== n && (t.flags |= 2048), rn(Ge), je(t), null; case 25: return null }throw Error(o(156, t.tag)) } function N0(e, t) { switch (eo(t), t.tag) { case 1: return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return rn(Ge), ji(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 26: case 27: case 5: return Xl(t), null; case 13: if (nn(t), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(o(340)); Ua() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return Ne(qe), null; case 4: return ji(), null; case 10: return rn(t.type), null; case 22: case 23: return nn(t), ao(), e !== null && Ne(oi), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 24: return rn(Ge), null; case 25: return null; default: return null } } function Zd(e, t) { switch (eo(t), t.tag) { case 3: rn(Ge), ji(); break; case 26: case 27: case 5: Xl(t); break; case 4: ji(); break; case 13: nn(t); break; case 19: Ne(qe); break; case 10: rn(t.type); break; case 22: case 23: nn(t), ao(), e !== null && Ne(oi); break; case 24: rn(Ge) } } var L0 = { getCacheForType: function (e) { var t = We(Ge), n = t.data.get(e); return n === void 0 && (n = e(), t.data.set(e, n)), n } }, k0 = typeof WeakMap == "function" ? WeakMap : Map, De = 0, Te = null, ce = null, me = 0, we = 0, pt = null, hn = !1, Wi = !1, Io = !1, dn = 0, Ve = 0, kn = 0, yi = 0, eu = 0, Ot = 0, Ii = 0, il = null, Zt = null, tu = !1, nu = 0, zs = 1 / 0, _s = null, Hn = null, Bs = !1, vi = null, al = 0, iu = 0, au = null, ll = 0, lu = null; function gt() { if (De & 2 && me !== 0) return me & -me; if (Y.T !== null) { var e = Xi; return e !== 0 ? e : du() } return mf() } function Pd() { Ot === 0 && (Ot = !(me & 536870912) || pe ? uf() : 536870912); var e = Dt.current; return e !== null && (e.flags |= 32), Ot } function lt(e, t, n) { (e === Te && we === 2 || e.cancelPendingCommit !== null) && (ea(e, 0), mn(e, me, Ot, !1)), wa(e, n), (!(De & 2) || e !== Te) && (e === Te && (!(De & 2) && (yi |= n), Ve === 4 && mn(e, me, Ot, !1)), Pt(e)) } function Fd(e, t, n) { if (De & 6) throw Error(o(327)); var l = !n && (t & 60) === 0 && (t & e.expiredLanes) === 0 || Ta(e, t), r = l ? G0(e, t) : uu(e, t, !0), u = l; do { if (r === 0) { Wi && !l && mn(e, t, 0, !1); break } else if (r === 6) mn(e, t, 0, !hn); else { if (n = e.current.alternate, u && !H0(n)) { r = uu(e, t, !1), u = !1; continue } if (r === 2) { if (u = t, e.errorRecoveryDisabledLanes & u) var p = 0; else p = e.pendingLanes & -536870913, p = p !== 0 ? p : p & 536870912 ? 536870912 : 0; if (p !== 0) { t = p; e: { var b = e; r = il; var T = b.current.memoizedState.isDehydrated; if (T && (ea(b, p).flags |= 256), p = uu(b, p, !1), p !== 2) { if (Io && !T) { b.errorRecoveryDisabledLanes |= u, yi |= u, r = 4; break e } u = Zt, Zt = r, u !== null && su(u) } r = p } if (u = !1, r !== 2) continue } } if (r === 1) { ea(e, 0), mn(e, t, 0, !0); break } e: { switch (l = e, r) { case 0: case 1: throw Error(o(345)); case 4: if ((t & 4194176) === t) { mn(l, t, Ot, !hn); break e } break; case 2: Zt = null; break; case 3: case 5: break; default: throw Error(o(329)) }if (l.finishedWork = n, l.finishedLanes = t, (t & 62914560) === t && (u = nu + 300 - Yt(), 10 < u)) { if (mn(l, t, Ot, !hn), Pl(l, 0) !== 0) break e; l.timeoutHandle = bm(Jd.bind(null, l, n, Zt, _s, tu, t, Ot, yi, Ii, hn, 2, -0, 0), u); break e } Jd(l, n, Zt, _s, tu, t, Ot, yi, Ii, hn, 0, -0, 0) } } break } while (!0); Pt(e) } function su(e) { Zt === null ? Zt = e : Zt.push.apply(Zt, e) } function Jd(e, t, n, l, r, u, p, b, T, E, U, H, V) { var B = t.subtreeFlags; if ((B & 8192 || (B & 16785408) === 16785408) && (fl = { stylesheets: null, count: 0, unsuspend: Sb }, Hd(t), t = wb(), t !== null)) { e.cancelPendingCommit = t(im.bind(null, e, n, l, r, p, b, T, 1, H, V)), mn(e, u, p, !E); return } im(e, n, l, r, p, b, T, U, H, V) } function H0(e) { for (var t = e; ;) { var n = t.tag; if ((n === 0 || n === 11 || n === 15) && t.flags & 16384 && (n = t.updateQueue, n !== null && (n = n.stores, n !== null))) for (var l = 0; l < n.length; l++) { var r = n[l], u = r.getSnapshot; r = r.value; try { if (!ht(u(), r)) return !1 } catch { return !1 } } if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function mn(e, t, n, l) { t &= ~eu, t &= ~yi, e.suspendedLanes |= t, e.pingedLanes &= ~t, l && (e.warmLanes |= t), l = e.expirationTimes; for (var r = t; 0 < r;) { var u = 31 - ft(r), p = 1 << u; l[u] = -1, r &= ~p } n !== 0 && ff(e, n, t) } function Us() { return De & 6 ? !0 : (sl(0), !1) } function ru() { if (ce !== null) { if (we === 0) var e = ce.return; else e = ce, sn = di = null, ho(e), Gi = null, Ha = 0, e = ce; for (; e !== null;)Zd(e.alternate, e), e = e.return; ce = null } } function ea(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; n !== -1 && (e.timeoutHandle = -1, lb(n)), n = e.cancelPendingCommit, n !== null && (e.cancelPendingCommit = null, n()), ru(), Te = e, ce = n = Ln(e.current, null), me = t, we = 0, pt = null, hn = !1, Wi = Ta(e, t), Io = !1, Ii = Ot = eu = yi = kn = Ve = 0, Zt = il = null, tu = !1, t & 8 && (t |= t & 32); var l = e.entangledLanes; if (l !== 0) for (e = e.entanglements, l &= t; 0 < l;) { var r = 31 - ft(l), u = 1 << r; t |= e[r], l &= ~u } return dn = t, ss(), n } function $d(e, t) { oe = null, Y.H = Qt, t === La ? (t = hh(), we = 3) : t === uh ? (t = hh(), we = 4) : we = t === cd ? 8 : t !== null && typeof t == "object" && typeof t.then == "function" ? 6 : 1, pt = t, ce === null && (Ve = 1, js(e, At(t, e.current))) } function Wd() { var e = Y.H; return Y.H = Qt, e === null ? Qt : e } function Id() { var e = Y.A; return Y.A = L0, e } function ou() { Ve = 4, hn || (me & 4194176) !== me && Dt.current !== null || (Wi = !0), !(kn & 134217727) && !(yi & 134217727) || Te === null || mn(Te, me, Ot, !1) } function uu(e, t, n) { var l = De; De |= 2; var r = Wd(), u = Id(); (Te !== e || me !== t) && (_s = null, ea(e, t)), t = !1; var p = Ve; e: do try { if (we !== 0 && ce !== null) { var b = ce, T = pt; switch (we) { case 8: ru(), p = 6; break e; case 3: case 2: case 6: Dt.current === null && (t = !0); var E = we; if (we = 0, pt = null, ta(e, b, T, E), n && Wi) { p = 0; break e } break; default: E = we, we = 0, pt = null, ta(e, b, T, E) } } q0(), p = Ve; break } catch (U) { $d(e, U) } while (!0); return t && e.shellSuspendCounter++, sn = di = null, De = l, Y.H = r, Y.A = u, ce === null && (Te = null, me = 0, ss()), p } function q0() { for (; ce !== null;)em(ce) } function G0(e, t) { var n = De; De |= 2; var l = Wd(), r = Id(); Te !== e || me !== t ? (_s = null, zs = Yt() + 500, ea(e, t)) : Wi = Ta(e, t); e: do try { if (we !== 0 && ce !== null) { t = ce; var u = pt; t: switch (we) { case 1: we = 0, pt = null, ta(e, t, u, 1); break; case 2: if (ch(u)) { we = 0, pt = null, tm(t); break } t = function () { we === 2 && Te === e && (we = 7), Pt(e) }, u.then(t, t); break e; case 3: we = 7; break e; case 4: we = 5; break e; case 7: ch(u) ? (we = 0, pt = null, tm(t)) : (we = 0, pt = null, ta(e, t, u, 7)); break; case 5: var p = null; switch (ce.tag) { case 26: p = ce.memoizedState; case 5: case 27: var b = ce; if (!p || Cm(p)) { we = 0, pt = null; var T = b.sibling; if (T !== null) ce = T; else { var E = b.return; E !== null ? (ce = E, Ns(E)) : ce = null } break t } }we = 0, pt = null, ta(e, t, u, 5); break; case 6: we = 0, pt = null, ta(e, t, u, 6); break; case 8: ru(), Ve = 6; break e; default: throw Error(o(462)) } } Y0(); break } catch (U) { $d(e, U) } while (!0); return sn = di = null, Y.H = l, Y.A = r, De = n, ce !== null ? 0 : (Te = null, me = 0, ss(), Ve) } function Y0() { for (; ce !== null && !fv();)em(ce) } function em(e) { var t = Td(e.alternate, e, dn); e.memoizedProps = e.pendingProps, t === null ? Ns(e) : ce = t } function tm(e) { var t = e, n = t.alternate; switch (t.tag) { case 15: case 0: t = gd(n, t, t.pendingProps, t.type, void 0, me); break; case 11: t = gd(n, t, t.pendingProps, t.type.render, t.ref, me); break; case 5: ho(t); default: Zd(n, t), t = ce = Xd(t, dn), t = Td(n, t, dn) }e.memoizedProps = e.pendingProps, t === null ? Ns(e) : ce = t } function ta(e, t, n, l) { sn = di = null, ho(t), Gi = null, Ha = 0; var r = t.return; try { if (O0(e, r, t, n, me)) { Ve = 1, js(e, At(n, e.current)), ce = null; return } } catch (u) { if (r !== null) throw ce = r, u; Ve = 1, js(e, At(n, e.current)), ce = null; return } t.flags & 32768 ? (pe || l === 1 ? e = !0 : Wi || me & 536870912 ? e = !1 : (hn = e = !0, (l === 2 || l === 3 || l === 6) && (l = Dt.current, l !== null && l.tag === 13 && (l.flags |= 16384))), nm(t, e)) : Ns(t) } function Ns(e) { var t = e; do { if (t.flags & 32768) { nm(t, hn); return } e = t.return; var n = U0(t.alternate, t, dn); if (n !== null) { ce = n; return } if (t = t.sibling, t !== null) { ce = t; return } ce = t = e } while (t !== null); Ve === 0 && (Ve = 5) } function nm(e, t) { do { var n = N0(e.alternate, e); if (n !== null) { n.flags &= 32767, ce = n; return } if (n = e.return, n !== null && (n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null), !t && (e = e.sibling, e !== null)) { ce = e; return } ce = e = n } while (e !== null); Ve = 6, ce = null } function im(e, t, n, l, r, u, p, b, T, E) { var U = Y.T, H = K.p; try { K.p = 2, Y.T = null, X0(e, t, n, l, H, r, u, p, b, T, E) } finally { Y.T = U, K.p = H } } function X0(e, t, n, l, r, u, p, b) { do na(); while (vi !== null); if (De & 6) throw Error(o(327)); var T = e.finishedWork; if (l = e.finishedLanes, T === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, T === e.current) throw Error(o(177)); e.callbackNode = null, e.callbackPriority = 0, e.cancelPendingCommit = null; var E = T.lanes | T.childLanes; if (E |= $r, Tv(e, l, E, u, p, b), e === Te && (ce = Te = null, me = 0), !(T.subtreeFlags & 10256) && !(T.flags & 10256) || Bs || (Bs = !0, iu = E, au = n, P0(Kl, function () { return na(), null })), n = (T.flags & 15990) !== 0, T.subtreeFlags & 15990 || n ? (n = Y.T, Y.T = null, u = K.p, K.p = 2, p = De, De |= 4, z0(e, T), Nd(T, e), m0(Su, e.containerInfo), Fs = !!xu, Su = xu = null, e.current = T, zd(e, T.alternate, T), hv(), De = p, K.p = u, Y.T = n) : e.current = T, Bs ? (Bs = !1, vi = e, al = l) : am(e, E), E = e.pendingLanes, E === 0 && (Hn = null), yv(T.stateNode), Pt(e), t !== null) for (r = e.onRecoverableError, T = 0; T < t.length; T++)E = t[T], r(E.value, { componentStack: E.stack }); return al & 3 && na(), E = e.pendingLanes, l & 4194218 && E & 42 ? e === lu ? ll++ : (ll = 0, lu = e) : ll = 0, sl(0), null } function am(e, t) { (e.pooledCacheLanes &= t) === 0 && (t = e.pooledCache, t != null && (e.pooledCache = null, Ga(t))) } function na() { if (vi !== null) { var e = vi, t = iu; iu = 0; var n = df(al), l = Y.T, r = K.p; try { if (K.p = 32 > n ? 32 : n, Y.T = null, vi === null) var u = !1; else { n = au, au = null; var p = vi, b = al; if (vi = null, al = 0, De & 6) throw Error(o(331)); var T = De; if (De |= 4, Gd(p.current), kd(p, p.current, b, n), De = T, sl(0, !1), ct && typeof ct.onPostCommitFiberRoot == "function") try { ct.onPostCommitFiberRoot(Sa, p) } catch { } u = !0 } return u } finally { K.p = r, Y.T = l, am(e, t) } } return !1 } function lm(e, t, n) { t = At(n, t), t = Do(e.stateNode, t, 2), e = _n(e, t, 2), e !== null && (wa(e, 2), Pt(e)) } function Se(e, t, n) { if (e.tag === 3) lm(e, e, n); else for (; t !== null;) { if (t.tag === 3) { lm(t, e, n); break } else if (t.tag === 1) { var l = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof l.componentDidCatch == "function" && (Hn === null || !Hn.has(l))) { e = At(n, e), n = od(2), l = _n(t, n, 2), l !== null && (ud(n, l, t, e), wa(l, 2), Pt(l)); break } } t = t.return } } function cu(e, t, n) { var l = e.pingCache; if (l === null) { l = e.pingCache = new k0; var r = new Set; l.set(t, r) } else r = l.get(t), r === void 0 && (r = new Set, l.set(t, r)); r.has(n) || (Io = !0, r.add(n), e = K0.bind(null, e, t, n), t.then(e, e)) } function K0(e, t, n) { var l = e.pingCache; l !== null && l.delete(t), e.pingedLanes |= e.suspendedLanes & n, e.warmLanes &= ~n, Te === e && (me & n) === n && (Ve === 4 || Ve === 3 && (me & 62914560) === me && 300 > Yt() - nu ? !(De & 2) && ea(e, 0) : eu |= n, Ii === me && (Ii = 0)), Pt(e) } function sm(e, t) { t === 0 && (t = cf()), e = jn(e, t), e !== null && (wa(e, t), Pt(e)) } function Q0(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), sm(e, n) } function Z0(e, t) { var n = 0; switch (e.tag) { case 13: var l = e.stateNode, r = e.memoizedState; r !== null && (n = r.retryLane); break; case 19: l = e.stateNode; break; case 22: l = e.stateNode._retryCache; break; default: throw Error(o(314)) }l !== null && l.delete(t), sm(e, n) } function P0(e, t) { return Dr(e, t) } var Ls = null, ia = null, fu = !1, ks = !1, hu = !1, bi = 0; function Pt(e) { e !== ia && e.next === null && (ia === null ? Ls = ia = e : ia = ia.next = e), ks = !0, fu || (fu = !0, J0(F0)) } function sl(e, t) { if (!hu && ks) { hu = !0; do for (var n = !1, l = Ls; l !== null;) { if (e !== 0) { var r = l.pendingLanes; if (r === 0) var u = 0; else { var p = l.suspendedLanes, b = l.pingedLanes; u = (1 << 31 - ft(42 | e) + 1) - 1, u &= r & ~(p & ~b), u = u & 201326677 ? u & 201326677 | 1 : u ? u | 2 : 0 } u !== 0 && (n = !0, um(l, u)) } else u = me, u = Pl(l, l === Te ? u : 0), !(u & 3) || Ta(l, u) || (n = !0, um(l, u)); l = l.next } while (n); hu = !1 } } function F0() { ks = fu = !1; var e = 0; bi !== 0 && (ab() && (e = bi), bi = 0); for (var t = Yt(), n = null, l = Ls; l !== null;) { var r = l.next, u = rm(l, t); u === 0 ? (l.next = null, n === null ? Ls = r : n.next = r, r === null && (ia = n)) : (n = l, (e !== 0 || u & 3) && (ks = !0)), l = r } sl(e) } function rm(e, t) { for (var n = e.suspendedLanes, l = e.pingedLanes, r = e.expirationTimes, u = e.pendingLanes & -62914561; 0 < u;) { var p = 31 - ft(u), b = 1 << p, T = r[p]; T === -1 ? (!(b & n) || b & l) && (r[p] = Sv(b, t)) : T <= t && (e.expiredLanes |= b), u &= ~b } if (t = Te, n = me, n = Pl(e, e === t ? n : 0), l = e.callbackNode, n === 0 || e === t && we === 2 || e.cancelPendingCommit !== null) return l !== null && l !== null && Mr(l), e.callbackNode = null, e.callbackPriority = 0; if (!(n & 3) || Ta(e, n)) { if (t = n & -n, t === e.callbackPriority) return t; switch (l !== null && Mr(l), df(n)) { case 2: case 8: n = rf; break; case 32: n = Kl; break; case 268435456: n = of; break; default: n = Kl }return l = om.bind(null, e), n = Dr(n, l), e.callbackPriority = t, e.callbackNode = n, t } return l !== null && l !== null && Mr(l), e.callbackPriority = 2, e.callbackNode = null, 2 } function om(e, t) { var n = e.callbackNode; if (na() && e.callbackNode !== n) return null; var l = me; return l = Pl(e, e === Te ? l : 0), l === 0 ? null : (Fd(e, l, t), rm(e, Yt()), e.callbackNode != null && e.callbackNode === n ? om.bind(null, e) : null) } function um(e, t) { if (na()) return null; Fd(e, t, !0) } function J0(e) { sb(function () { De & 6 ? Dr(sf, e) : e() }) } function du() { return bi === 0 && (bi = uf()), bi } function cm(e) { return e == null || typeof e == "symbol" || typeof e == "boolean" ? null : typeof e == "function" ? e : Il("" + e) } function fm(e, t) { var n = t.ownerDocument.createElement("input"); return n.name = t.name, n.value = t.value, e.id && n.setAttribute("form", e.id), t.parentNode.insertBefore(n, t), e = new FormData(e), n.parentNode.removeChild(n), e } function $0(e, t, n, l, r) { if (t === "submit" && n && n.stateNode === r) { var u = cm((r[rt] || null).action), p = l.submitter; p && (t = (t = p[rt] || null) ? cm(t.formAction) : p.getAttribute("formAction"), t !== null && (u = t, p = null)); var b = new is("action", "action", null, l, r); e.push({ event: b, listeners: [{ instance: null, listener: function () { if (l.defaultPrevented) { if (bi !== 0) { var T = p ? fm(r, p) : new FormData(r); To(n, { pending: !0, data: T, method: r.method, action: u }, null, T) } } else typeof u == "function" && (b.preventDefault(), T = p ? fm(r, p) : new FormData(r), To(n, { pending: !0, data: T, method: r.method, action: u }, u, T)) }, currentTarget: r }] }) } } for (var mu = 0; mu < ih.length; mu++) { var pu = ih[mu], W0 = pu.toLowerCase(), I0 = pu[0].toUpperCase() + pu.slice(1); Bt(W0, "on" + I0) } Bt(Wf, "onAnimationEnd"), Bt(If, "onAnimationIteration"), Bt(eh, "onAnimationStart"), Bt("dblclick", "onDoubleClick"), Bt("focusin", "onFocus"), Bt("focusout", "onBlur"), Bt(g0, "onTransitionRun"), Bt(y0, "onTransitionStart"), Bt(v0, "onTransitionCancel"), Bt(th, "onTransitionEnd"), Ci("onMouseEnter", ["mouseout", "mouseover"]), Ci("onMouseLeave", ["mouseout", "mouseover"]), Ci("onPointerEnter", ["pointerout", "pointerover"]), Ci("onPointerLeave", ["pointerout", "pointerover"]), ei("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), ei("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), ei("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), ei("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), ei("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), ei("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var rl = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), eb = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(rl)); function hm(e, t) { t = (t & 4) !== 0; for (var n = 0; n < e.length; n++) { var l = e[n], r = l.event; l = l.listeners; e: { var u = void 0; if (t) for (var p = l.length - 1; 0 <= p; p--) { var b = l[p], T = b.instance, E = b.currentTarget; if (b = b.listener, T !== u && r.isPropagationStopped()) break e; u = b, r.currentTarget = E; try { u(r) } catch (U) { Es(U) } r.currentTarget = null, u = T } else for (p = 0; p < l.length; p++) { if (b = l[p], T = b.instance, E = b.currentTarget, b = b.listener, T !== u && r.isPropagationStopped()) break e; u = b, r.currentTarget = E; try { u(r) } catch (U) { Es(U) } r.currentTarget = null, u = T } } } } function he(e, t) { var n = t[Cr]; n === void 0 && (n = t[Cr] = new Set); var l = e + "__bubble"; n.has(l) || (dm(t, e, 2, !1), n.add(l)) } function gu(e, t, n) { var l = 0; t && (l |= 4), dm(n, e, l, t) } var Hs = "_reactListening" + Math.random().toString(36).slice(2); function yu(e) { if (!e[Hs]) { e[Hs] = !0, gf.forEach(function (n) { n !== "selectionchange" && (eb.has(n) || gu(n, !1, e), gu(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[Hs] || (t[Hs] = !0, gu("selectionchange", !1, t)) } } function dm(e, t, n, l) { switch (Um(t)) { case 2: var r = jb; break; case 8: r = Db; break; default: r = Cu }n = r.bind(null, t, n, e), r = void 0, !Lr || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (r = !0), l ? r !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: r }) : e.addEventListener(t, n, !0) : r !== void 0 ? e.addEventListener(t, n, { passive: r }) : e.addEventListener(t, n, !1) } function vu(e, t, n, l, r) { var u = l; if (!(t & 1) && !(t & 2) && l !== null) e: for (; ;) { if (l === null) return; var p = l.tag; if (p === 3 || p === 4) { var b = l.stateNode.containerInfo; if (b === r || b.nodeType === 8 && b.parentNode === r) break; if (p === 4) for (p = l.return; p !== null;) { var T = p.tag; if ((T === 3 || T === 4) && (T = p.stateNode.containerInfo, T === r || T.nodeType === 8 && T.parentNode === r)) return; p = p.return } for (; b !== null;) { if (p = In(b), p === null) return; if (T = p.tag, T === 5 || T === 6 || T === 26 || T === 27) { l = u = p; continue e } b = b.parentNode } } l = l.return } Mf(function () { var E = u, U = Ur(n), H = []; e: { var V = nh.get(e); if (V !== void 0) { var B = is, Z = e; switch (e) { case "keypress": if (ts(n) === 0) break e; case "keydown": case "keyup": B = Zv; break; case "focusin": Z = "focus", B = Gr; break; case "focusout": Z = "blur", B = Gr; break; case "beforeblur": case "afterblur": B = Gr; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": B = Of; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": B = Bv; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": B = Jv; break; case Wf: case If: case eh: B = Lv; break; case th: B = Wv; break; case "scroll": case "scrollend": B = zv; break; case "wheel": B = e0; break; case "copy": case "cut": case "paste": B = Hv; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": B = zf; break; case "toggle": case "beforetoggle": B = n0 }var le = (t & 4) !== 0, ze = !le && (e === "scroll" || e === "scrollend"), M = le ? V !== null ? V + "Capture" : null : V; le = []; for (var A = E, R; A !== null;) { var k = A; if (R = k.stateNode, k = k.tag, k !== 5 && k !== 26 && k !== 27 || R === null || M === null || (k = ja(A, M), k != null && le.push(ol(A, k, R))), ze) break; A = A.return } 0 < le.length && (V = new B(V, Z, null, n, U), H.push({ event: V, listeners: le })) } } if (!(t & 7)) { e: { if (V = e === "mouseover" || e === "pointerover", B = e === "mouseout" || e === "pointerout", V && n !== Br && (Z = n.relatedTarget || n.fromElement) && (In(Z) || Z[Di])) break e; if ((B || V) && (V = U.window === U ? U : (V = U.ownerDocument) ? V.defaultView || V.parentWindow : window, B ? (Z = n.relatedTarget || n.toElement, B = E, Z = Z ? In(Z) : null, Z !== null && (ze = F(Z), le = Z.tag, Z !== ze || le !== 5 && le !== 27 && le !== 6) && (Z = null)) : (B = null, Z = E), B !== Z)) { if (le = Of, k = "onMouseLeave", M = "onMouseEnter", A = "mouse", (e === "pointerout" || e === "pointerover") && (le = zf, k = "onPointerLeave", M = "onPointerEnter", A = "pointer"), ze = B == null ? V : Ea(B), R = Z == null ? V : Ea(Z), V = new le(k, A + "leave", B, n, U), V.target = ze, V.relatedTarget = R, k = null, In(U) === E && (le = new le(M, A + "enter", Z, n, U), le.target = R, le.relatedTarget = ze, k = le), ze = k, B && Z) t: { for (le = B, M = Z, A = 0, R = le; R; R = aa(R))A++; for (R = 0, k = M; k; k = aa(k))R++; for (; 0 < A - R;)le = aa(le), A--; for (; 0 < R - A;)M = aa(M), R--; for (; A--;) { if (le === M || M !== null && le === M.alternate) break t; le = aa(le), M = aa(M) } le = null } else le = null; B !== null && mm(H, V, B, le, !1), Z !== null && ze !== null && mm(H, ze, Z, le, !0) } } e: { if (V = E ? Ea(E) : window, B = V.nodeName && V.nodeName.toLowerCase(), B === "select" || B === "input" && V.type === "file") var Q = qf; else if (kf(V)) if (Gf) Q = h0; else { Q = c0; var ue = u0 } else B = V.nodeName, !B || B.toLowerCase() !== "input" || V.type !== "checkbox" && V.type !== "radio" ? E && _r(E.elementType) && (Q = qf) : Q = f0; if (Q && (Q = Q(e, E))) { Hf(H, Q, n, U); break e } ue && ue(e, V, E), e === "focusout" && E && V.type === "number" && E.memoizedProps.value != null && zr(V, "number", V.value) } switch (ue = E ? Ea(E) : window, e) { case "focusin": (kf(ue) || ue.contentEditable === "true") && (Ui = ue, Pr = E, _a = null); break; case "focusout": _a = Pr = Ui = null; break; case "mousedown": Fr = !0; break; case "contextmenu": case "mouseup": case "dragend": Fr = !1, Jf(H, n, U); break; case "selectionchange": if (p0) break; case "keydown": case "keyup": Jf(H, n, U) }var $; if (Xr) e: { switch (e) { case "compositionstart": var te = "onCompositionStart"; break e; case "compositionend": te = "onCompositionEnd"; break e; case "compositionupdate": te = "onCompositionUpdate"; break e }te = void 0 } else Bi ? Nf(e, n) && (te = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (te = "onCompositionStart"); te && (_f && n.locale !== "ko" && (Bi || te !== "onCompositionStart" ? te === "onCompositionEnd" && Bi && ($ = Rf()) : (En = U, kr = "value" in En ? En.value : En.textContent, Bi = !0)), ue = qs(E, te), 0 < ue.length && (te = new Vf(te, e, null, n, U), H.push({ event: te, listeners: ue }), $ ? te.data = $ : ($ = Lf(n), $ !== null && (te.data = $)))), ($ = a0 ? l0(e, n) : s0(e, n)) && (te = qs(E, "onBeforeInput"), 0 < te.length && (ue = new Vf("onBeforeInput", "beforeinput", null, n, U), H.push({ event: ue, listeners: te }), ue.data = $)), $0(H, e, E, n, U) } hm(H, t) }) } function ol(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function qs(e, t) { for (var n = t + "Capture", l = []; e !== null;) { var r = e, u = r.stateNode; r = r.tag, r !== 5 && r !== 26 && r !== 27 || u === null || (r = ja(e, n), r != null && l.unshift(ol(e, r, u)), r = ja(e, t), r != null && l.push(ol(e, r, u))), e = e.return } return l } function aa(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5 && e.tag !== 27); return e || null } function mm(e, t, n, l, r) { for (var u = t._reactName, p = []; n !== null && n !== l;) { var b = n, T = b.alternate, E = b.stateNode; if (b = b.tag, T !== null && T === l) break; b !== 5 && b !== 26 && b !== 27 || E === null || (T = E, r ? (E = ja(n, u), E != null && p.unshift(ol(n, E, T))) : r || (E = ja(n, u), E != null && p.push(ol(n, E, T)))), n = n.return } p.length !== 0 && e.push({ event: t, listeners: p }) } var tb = /\r\n?/g, nb = /\u0000|\uFFFD/g; function pm(e) {
        return (typeof e == "string" ? e : "" + e).replace(tb, `
`).replace(nb, "")
    } function gm(e, t) { return t = pm(t), pm(e) === t } function Gs() { } function xe(e, t, n, l, r, u) { switch (n) { case "children": typeof l == "string" ? t === "body" || t === "textarea" && l === "" || Vi(e, l) : (typeof l == "number" || typeof l == "bigint") && t !== "body" && Vi(e, "" + l); break; case "className": Jl(e, "class", l); break; case "tabIndex": Jl(e, "tabindex", l); break; case "dir": case "role": case "viewBox": case "width": case "height": Jl(e, n, l); break; case "style": jf(e, l, u); break; case "data": if (t !== "object") { Jl(e, "data", l); break } case "src": case "href": if (l === "" && (t !== "a" || n !== "href")) { e.removeAttribute(n); break } if (l == null || typeof l == "function" || typeof l == "symbol" || typeof l == "boolean") { e.removeAttribute(n); break } l = Il("" + l), e.setAttribute(n, l); break; case "action": case "formAction": if (typeof l == "function") { e.setAttribute(n, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"); break } else typeof u == "function" && (n === "formAction" ? (t !== "input" && xe(e, t, "name", r.name, r, null), xe(e, t, "formEncType", r.formEncType, r, null), xe(e, t, "formMethod", r.formMethod, r, null), xe(e, t, "formTarget", r.formTarget, r, null)) : (xe(e, t, "encType", r.encType, r, null), xe(e, t, "method", r.method, r, null), xe(e, t, "target", r.target, r, null))); if (l == null || typeof l == "symbol" || typeof l == "boolean") { e.removeAttribute(n); break } l = Il("" + l), e.setAttribute(n, l); break; case "onClick": l != null && (e.onclick = Gs); break; case "onScroll": l != null && he("scroll", e); break; case "onScrollEnd": l != null && he("scrollend", e); break; case "dangerouslySetInnerHTML": if (l != null) { if (typeof l != "object" || !("__html" in l)) throw Error(o(61)); if (n = l.__html, n != null) { if (r.children != null) throw Error(o(60)); e.innerHTML = n } } break; case "multiple": e.multiple = l && typeof l != "function" && typeof l != "symbol"; break; case "muted": e.muted = l && typeof l != "function" && typeof l != "symbol"; break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "defaultValue": case "defaultChecked": case "innerHTML": case "ref": break; case "autoFocus": break; case "xlinkHref": if (l == null || typeof l == "function" || typeof l == "boolean" || typeof l == "symbol") { e.removeAttribute("xlink:href"); break } n = Il("" + l), e.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", n); break; case "contentEditable": case "spellCheck": case "draggable": case "value": case "autoReverse": case "externalResourcesRequired": case "focusable": case "preserveAlpha": l != null && typeof l != "function" && typeof l != "symbol" ? e.setAttribute(n, "" + l) : e.removeAttribute(n); break; case "inert": case "allowFullScreen": case "async": case "autoPlay": case "controls": case "default": case "defer": case "disabled": case "disablePictureInPicture": case "disableRemotePlayback": case "formNoValidate": case "hidden": case "loop": case "noModule": case "noValidate": case "open": case "playsInline": case "readOnly": case "required": case "reversed": case "scoped": case "seamless": case "itemScope": l && typeof l != "function" && typeof l != "symbol" ? e.setAttribute(n, "") : e.removeAttribute(n); break; case "capture": case "download": l === !0 ? e.setAttribute(n, "") : l !== !1 && l != null && typeof l != "function" && typeof l != "symbol" ? e.setAttribute(n, l) : e.removeAttribute(n); break; case "cols": case "rows": case "size": case "span": l != null && typeof l != "function" && typeof l != "symbol" && !isNaN(l) && 1 <= l ? e.setAttribute(n, l) : e.removeAttribute(n); break; case "rowSpan": case "start": l == null || typeof l == "function" || typeof l == "symbol" || isNaN(l) ? e.removeAttribute(n) : e.setAttribute(n, l); break; case "popover": he("beforetoggle", e), he("toggle", e), Fl(e, "popover", l); break; case "xlinkActuate": It(e, "http://www.w3.org/1999/xlink", "xlink:actuate", l); break; case "xlinkArcrole": It(e, "http://www.w3.org/1999/xlink", "xlink:arcrole", l); break; case "xlinkRole": It(e, "http://www.w3.org/1999/xlink", "xlink:role", l); break; case "xlinkShow": It(e, "http://www.w3.org/1999/xlink", "xlink:show", l); break; case "xlinkTitle": It(e, "http://www.w3.org/1999/xlink", "xlink:title", l); break; case "xlinkType": It(e, "http://www.w3.org/1999/xlink", "xlink:type", l); break; case "xmlBase": It(e, "http://www.w3.org/XML/1998/namespace", "xml:base", l); break; case "xmlLang": It(e, "http://www.w3.org/XML/1998/namespace", "xml:lang", l); break; case "xmlSpace": It(e, "http://www.w3.org/XML/1998/namespace", "xml:space", l); break; case "is": Fl(e, "is", l); break; case "innerText": case "textContent": break; default: (!(2 < n.length) || n[0] !== "o" && n[0] !== "O" || n[1] !== "n" && n[1] !== "N") && (n = Ov.get(n) || n, Fl(e, n, l)) } } function bu(e, t, n, l, r, u) { switch (n) { case "style": jf(e, l, u); break; case "dangerouslySetInnerHTML": if (l != null) { if (typeof l != "object" || !("__html" in l)) throw Error(o(61)); if (n = l.__html, n != null) { if (r.children != null) throw Error(o(60)); e.innerHTML = n } } break; case "children": typeof l == "string" ? Vi(e, l) : (typeof l == "number" || typeof l == "bigint") && Vi(e, "" + l); break; case "onScroll": l != null && he("scroll", e); break; case "onScrollEnd": l != null && he("scrollend", e); break; case "onClick": l != null && (e.onclick = Gs); break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "innerHTML": case "ref": break; case "innerText": case "textContent": break; default: if (!yf.hasOwnProperty(n)) e: { if (n[0] === "o" && n[1] === "n" && (r = n.endsWith("Capture"), t = n.slice(2, r ? n.length - 7 : void 0), u = e[rt] || null, u = u != null ? u[n] : null, typeof u == "function" && e.removeEventListener(t, u, r), typeof l == "function")) { typeof u != "function" && u !== null && (n in e ? e[n] = null : e.hasAttribute(n) && e.removeAttribute(n)), e.addEventListener(t, l, r); break e } n in e ? e[n] = l : l === !0 ? e.setAttribute(n, "") : Fl(e, n, l) } } } function Fe(e, t, n) { switch (t) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "img": he("error", e), he("load", e); var l = !1, r = !1, u; for (u in n) if (n.hasOwnProperty(u)) { var p = n[u]; if (p != null) switch (u) { case "src": l = !0; break; case "srcSet": r = !0; break; case "children": case "dangerouslySetInnerHTML": throw Error(o(137, t)); default: xe(e, t, u, p, n, null) } } r && xe(e, t, "srcSet", n.srcSet, n, null), l && xe(e, t, "src", n.src, n, null); return; case "input": he("invalid", e); var b = u = p = r = null, T = null, E = null; for (l in n) if (n.hasOwnProperty(l)) { var U = n[l]; if (U != null) switch (l) { case "name": r = U; break; case "type": p = U; break; case "checked": T = U; break; case "defaultChecked": E = U; break; case "value": u = U; break; case "defaultValue": b = U; break; case "children": case "dangerouslySetInnerHTML": if (U != null) throw Error(o(137, t)); break; default: xe(e, t, l, U, n, null) } } Tf(e, u, b, T, E, p, r, !1), $l(e); return; case "select": he("invalid", e), l = p = u = null; for (r in n) if (n.hasOwnProperty(r) && (b = n[r], b != null)) switch (r) { case "value": u = b; break; case "defaultValue": p = b; break; case "multiple": l = b; default: xe(e, t, r, b, n, null) }t = u, n = p, e.multiple = !!l, t != null ? Oi(e, !!l, t, !1) : n != null && Oi(e, !!l, n, !0); return; case "textarea": he("invalid", e), u = r = l = null; for (p in n) if (n.hasOwnProperty(p) && (b = n[p], b != null)) switch (p) { case "value": l = b; break; case "defaultValue": r = b; break; case "children": u = b; break; case "dangerouslySetInnerHTML": if (b != null) throw Error(o(91)); break; default: xe(e, t, p, b, n, null) }Af(e, l, r, u), $l(e); return; case "option": for (T in n) if (n.hasOwnProperty(T) && (l = n[T], l != null)) switch (T) { case "selected": e.selected = l && typeof l != "function" && typeof l != "symbol"; break; default: xe(e, t, T, l, n, null) }return; case "dialog": he("cancel", e), he("close", e); break; case "iframe": case "object": he("load", e); break; case "video": case "audio": for (l = 0; l < rl.length; l++)he(rl[l], e); break; case "image": he("error", e), he("load", e); break; case "details": he("toggle", e); break; case "embed": case "source": case "link": he("error", e), he("load", e); case "area": case "base": case "br": case "col": case "hr": case "keygen": case "meta": case "param": case "track": case "wbr": case "menuitem": for (E in n) if (n.hasOwnProperty(E) && (l = n[E], l != null)) switch (E) { case "children": case "dangerouslySetInnerHTML": throw Error(o(137, t)); default: xe(e, t, E, l, n, null) }return; default: if (_r(t)) { for (U in n) n.hasOwnProperty(U) && (l = n[U], l !== void 0 && bu(e, t, U, l, n, void 0)); return } }for (b in n) n.hasOwnProperty(b) && (l = n[b], l != null && xe(e, t, b, l, n, null)) } function ib(e, t, n, l) { switch (t) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "input": var r = null, u = null, p = null, b = null, T = null, E = null, U = null; for (B in n) { var H = n[B]; if (n.hasOwnProperty(B) && H != null) switch (B) { case "checked": break; case "value": break; case "defaultValue": T = H; default: l.hasOwnProperty(B) || xe(e, t, B, null, l, H) } } for (var V in l) { var B = l[V]; if (H = n[V], l.hasOwnProperty(V) && (B != null || H != null)) switch (V) { case "type": u = B; break; case "name": r = B; break; case "checked": E = B; break; case "defaultChecked": U = B; break; case "value": p = B; break; case "defaultValue": b = B; break; case "children": case "dangerouslySetInnerHTML": if (B != null) throw Error(o(137, t)); break; default: B !== H && xe(e, t, V, B, l, H) } } Vr(e, p, b, T, E, U, u, r); return; case "select": B = p = b = V = null; for (u in n) if (T = n[u], n.hasOwnProperty(u) && T != null) switch (u) { case "value": break; case "multiple": B = T; default: l.hasOwnProperty(u) || xe(e, t, u, null, l, T) }for (r in l) if (u = l[r], T = n[r], l.hasOwnProperty(r) && (u != null || T != null)) switch (r) { case "value": V = u; break; case "defaultValue": b = u; break; case "multiple": p = u; default: u !== T && xe(e, t, r, u, l, T) }t = b, n = p, l = B, V != null ? Oi(e, !!n, V, !1) : !!l != !!n && (t != null ? Oi(e, !!n, t, !0) : Oi(e, !!n, n ? [] : "", !1)); return; case "textarea": B = V = null; for (b in n) if (r = n[b], n.hasOwnProperty(b) && r != null && !l.hasOwnProperty(b)) switch (b) { case "value": break; case "children": break; default: xe(e, t, b, null, l, r) }for (p in l) if (r = l[p], u = n[p], l.hasOwnProperty(p) && (r != null || u != null)) switch (p) { case "value": V = r; break; case "defaultValue": B = r; break; case "children": break; case "dangerouslySetInnerHTML": if (r != null) throw Error(o(91)); break; default: r !== u && xe(e, t, p, r, l, u) }wf(e, V, B); return; case "option": for (var Z in n) if (V = n[Z], n.hasOwnProperty(Z) && V != null && !l.hasOwnProperty(Z)) switch (Z) { case "selected": e.selected = !1; break; default: xe(e, t, Z, null, l, V) }for (T in l) if (V = l[T], B = n[T], l.hasOwnProperty(T) && V !== B && (V != null || B != null)) switch (T) { case "selected": e.selected = V && typeof V != "function" && typeof V != "symbol"; break; default: xe(e, t, T, V, l, B) }return; case "img": case "link": case "area": case "base": case "br": case "col": case "embed": case "hr": case "keygen": case "meta": case "param": case "source": case "track": case "wbr": case "menuitem": for (var le in n) V = n[le], n.hasOwnProperty(le) && V != null && !l.hasOwnProperty(le) && xe(e, t, le, null, l, V); for (E in l) if (V = l[E], B = n[E], l.hasOwnProperty(E) && V !== B && (V != null || B != null)) switch (E) { case "children": case "dangerouslySetInnerHTML": if (V != null) throw Error(o(137, t)); break; default: xe(e, t, E, V, l, B) }return; default: if (_r(t)) { for (var ze in n) V = n[ze], n.hasOwnProperty(ze) && V !== void 0 && !l.hasOwnProperty(ze) && bu(e, t, ze, void 0, l, V); for (U in l) V = l[U], B = n[U], !l.hasOwnProperty(U) || V === B || V === void 0 && B === void 0 || bu(e, t, U, V, l, B); return } }for (var M in n) V = n[M], n.hasOwnProperty(M) && V != null && !l.hasOwnProperty(M) && xe(e, t, M, null, l, V); for (H in l) V = l[H], B = n[H], !l.hasOwnProperty(H) || V === B || V == null && B == null || xe(e, t, H, V, l, B) } var xu = null, Su = null; function Ys(e) { return e.nodeType === 9 ? e : e.ownerDocument } function ym(e) { switch (e) { case "http://www.w3.org/2000/svg": return 1; case "http://www.w3.org/1998/Math/MathML": return 2; default: return 0 } } function vm(e, t) { if (e === 0) switch (t) { case "svg": return 1; case "math": return 2; default: return 0 }return e === 1 && t === "foreignObject" ? 0 : e } function Tu(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.children == "bigint" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var wu = null; function ab() { var e = window.event; return e && e.type === "popstate" ? e === wu ? !1 : (wu = e, !0) : (wu = null, !1) } var bm = typeof setTimeout == "function" ? setTimeout : void 0, lb = typeof clearTimeout == "function" ? clearTimeout : void 0, xm = typeof Promise == "function" ? Promise : void 0, sb = typeof queueMicrotask == "function" ? queueMicrotask : typeof xm < "u" ? function (e) { return xm.resolve(null).then(e).catch(rb) } : bm; function rb(e) { setTimeout(function () { throw e }) } function Au(e, t) { var n = t, l = 0; do { var r = n.nextSibling; if (e.removeChild(n), r && r.nodeType === 8) if (n = r.data, n === "/$") { if (l === 0) { e.removeChild(r), gl(t); return } l-- } else n !== "$" && n !== "$?" && n !== "$!" || l++; n = r } while (n); gl(t) } function Eu(e) { var t = e.firstChild; for (t && t.nodeType === 10 && (t = t.nextSibling); t;) { var n = t; switch (t = t.nextSibling, n.nodeName) { case "HTML": case "HEAD": case "BODY": Eu(n), Or(n); continue; case "SCRIPT": case "STYLE": continue; case "LINK": if (n.rel.toLowerCase() === "stylesheet") continue }e.removeChild(n) } } function ob(e, t, n, l) { for (; e.nodeType === 1;) { var r = n; if (e.nodeName.toLowerCase() !== t.toLowerCase()) { if (!l && (e.nodeName !== "INPUT" || e.type !== "hidden")) break } else if (l) { if (!e[Aa]) switch (t) { case "meta": if (!e.hasAttribute("itemprop")) break; return e; case "link": if (u = e.getAttribute("rel"), u === "stylesheet" && e.hasAttribute("data-precedence")) break; if (u !== r.rel || e.getAttribute("href") !== (r.href == null ? null : r.href) || e.getAttribute("crossorigin") !== (r.crossOrigin == null ? null : r.crossOrigin) || e.getAttribute("title") !== (r.title == null ? null : r.title)) break; return e; case "style": if (e.hasAttribute("data-precedence")) break; return e; case "script": if (u = e.getAttribute("src"), (u !== (r.src == null ? null : r.src) || e.getAttribute("type") !== (r.type == null ? null : r.type) || e.getAttribute("crossorigin") !== (r.crossOrigin == null ? null : r.crossOrigin)) && u && e.hasAttribute("async") && !e.hasAttribute("itemprop")) break; return e; default: return e } } else if (t === "input" && e.type === "hidden") { var u = r.name == null ? null : "" + r.name; if (r.type === "hidden" && e.getAttribute("name") === u) return e } else return e; if (e = Lt(e.nextSibling), e === null) break } return null } function ub(e, t, n) { if (t === "") return null; for (; e.nodeType !== 3;)if ((e.nodeType !== 1 || e.nodeName !== "INPUT" || e.type !== "hidden") && !n || (e = Lt(e.nextSibling), e === null)) return null; return e } function Lt(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?" || t === "F!" || t === "F") break; if (t === "/$") return null } } return e } function Sm(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } function Tm(e, t, n) { switch (t = Ys(n), e) { case "html": if (e = t.documentElement, !e) throw Error(o(452)); return e; case "head": if (e = t.head, !e) throw Error(o(453)); return e; case "body": if (e = t.body, !e) throw Error(o(454)); return e; default: throw Error(o(451)) } } var Vt = new Map, wm = new Set; function Xs(e) { return typeof e.getRootNode == "function" ? e.getRootNode() : e.ownerDocument } var pn = K.d; K.d = { f: cb, r: fb, D: hb, C: db, L: mb, m: pb, X: yb, S: gb, M: vb }; function cb() { var e = pn.f(), t = Us(); return e || t } function fb(e) { var t = Mi(e); t !== null && t.tag === 5 && t.type === "form" ? Jh(t) : pn.r(e) } var la = typeof document > "u" ? null : document; function Am(e, t, n) { var l = la; if (l && typeof t == "string" && t) { var r = Tt(t); r = 'link[rel="' + e + '"][href="' + r + '"]', typeof n == "string" && (r += '[crossorigin="' + n + '"]'), wm.has(r) || (wm.add(r), e = { rel: e, crossOrigin: n, href: t }, l.querySelector(r) === null && (t = l.createElement("link"), Fe(t, "link", e), Ye(t), l.head.appendChild(t))) } } function hb(e) { pn.D(e), Am("dns-prefetch", e, null) } function db(e, t) { pn.C(e, t), Am("preconnect", e, t) } function mb(e, t, n) { pn.L(e, t, n); var l = la; if (l && e && t) { var r = 'link[rel="preload"][as="' + Tt(t) + '"]'; t === "image" && n && n.imageSrcSet ? (r += '[imagesrcset="' + Tt(n.imageSrcSet) + '"]', typeof n.imageSizes == "string" && (r += '[imagesizes="' + Tt(n.imageSizes) + '"]')) : r += '[href="' + Tt(e) + '"]'; var u = r; switch (t) { case "style": u = sa(e); break; case "script": u = ra(e) }Vt.has(u) || (e = I({ rel: "preload", href: t === "image" && n && n.imageSrcSet ? void 0 : e, as: t }, n), Vt.set(u, e), l.querySelector(r) !== null || t === "style" && l.querySelector(ul(u)) || t === "script" && l.querySelector(cl(u)) || (t = l.createElement("link"), Fe(t, "link", e), Ye(t), l.head.appendChild(t))) } } function pb(e, t) { pn.m(e, t); var n = la; if (n && e) { var l = t && typeof t.as == "string" ? t.as : "script", r = 'link[rel="modulepreload"][as="' + Tt(l) + '"][href="' + Tt(e) + '"]', u = r; switch (l) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": u = ra(e) }if (!Vt.has(u) && (e = I({ rel: "modulepreload", href: e }, t), Vt.set(u, e), n.querySelector(r) === null)) { switch (l) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": if (n.querySelector(cl(u))) return }l = n.createElement("link"), Fe(l, "link", e), Ye(l), n.head.appendChild(l) } } } function gb(e, t, n) { pn.S(e, t, n); var l = la; if (l && e) { var r = Ri(l).hoistableStyles, u = sa(e); t = t || "default"; var p = r.get(u); if (!p) { var b = { loading: 0, preload: null }; if (p = l.querySelector(ul(u))) b.loading = 5; else { e = I({ rel: "stylesheet", href: e, "data-precedence": t }, n), (n = Vt.get(u)) && ju(e, n); var T = p = l.createElement("link"); Ye(T), Fe(T, "link", e), T._p = new Promise(function (E, U) { T.onload = E, T.onerror = U }), T.addEventListener("load", function () { b.loading |= 1 }), T.addEventListener("error", function () { b.loading |= 2 }), b.loading |= 4, Ks(p, t, l) } p = { type: "stylesheet", instance: p, count: 1, state: b }, r.set(u, p) } } } function yb(e, t) { pn.X(e, t); var n = la; if (n && e) { var l = Ri(n).hoistableScripts, r = ra(e), u = l.get(r); u || (u = n.querySelector(cl(r)), u || (e = I({ src: e, async: !0 }, t), (t = Vt.get(r)) && Du(e, t), u = n.createElement("script"), Ye(u), Fe(u, "link", e), n.head.appendChild(u)), u = { type: "script", instance: u, count: 1, state: null }, l.set(r, u)) } } function vb(e, t) { pn.M(e, t); var n = la; if (n && e) { var l = Ri(n).hoistableScripts, r = ra(e), u = l.get(r); u || (u = n.querySelector(cl(r)), u || (e = I({ src: e, async: !0, type: "module" }, t), (t = Vt.get(r)) && Du(e, t), u = n.createElement("script"), Ye(u), Fe(u, "link", e), n.head.appendChild(u)), u = { type: "script", instance: u, count: 1, state: null }, l.set(r, u)) } } function Em(e, t, n, l) { var r = (r = Tn.current) ? Xs(r) : null; if (!r) throw Error(o(446)); switch (e) { case "meta": case "title": return null; case "style": return typeof n.precedence == "string" && typeof n.href == "string" ? (t = sa(n.href), n = Ri(r).hoistableStyles, l = n.get(t), l || (l = { type: "style", instance: null, count: 0, state: null }, n.set(t, l)), l) : { type: "void", instance: null, count: 0, state: null }; case "link": if (n.rel === "stylesheet" && typeof n.href == "string" && typeof n.precedence == "string") { e = sa(n.href); var u = Ri(r).hoistableStyles, p = u.get(e); if (p || (r = r.ownerDocument || r, p = { type: "stylesheet", instance: null, count: 0, state: { loading: 0, preload: null } }, u.set(e, p), (u = r.querySelector(ul(e))) && !u._p && (p.instance = u, p.state.loading = 5), Vt.has(e) || (n = { rel: "preload", as: "style", href: n.href, crossOrigin: n.crossOrigin, integrity: n.integrity, media: n.media, hrefLang: n.hrefLang, referrerPolicy: n.referrerPolicy }, Vt.set(e, n), u || bb(r, e, n, p.state))), t && l === null) throw Error(o(528, "")); return p } if (t && l !== null) throw Error(o(529, "")); return null; case "script": return t = n.async, n = n.src, typeof n == "string" && t && typeof t != "function" && typeof t != "symbol" ? (t = ra(n), n = Ri(r).hoistableScripts, l = n.get(t), l || (l = { type: "script", instance: null, count: 0, state: null }, n.set(t, l)), l) : { type: "void", instance: null, count: 0, state: null }; default: throw Error(o(444, e)) } } function sa(e) { return 'href="' + Tt(e) + '"' } function ul(e) { return 'link[rel="stylesheet"][' + e + "]" } function jm(e) { return I({}, e, { "data-precedence": e.precedence, precedence: null }) } function bb(e, t, n, l) { e.querySelector('link[rel="preload"][as="style"][' + t + "]") ? l.loading = 1 : (t = e.createElement("link"), l.preload = t, t.addEventListener("load", function () { return l.loading |= 1 }), t.addEventListener("error", function () { return l.loading |= 2 }), Fe(t, "link", n), Ye(t), e.head.appendChild(t)) } function ra(e) { return '[src="' + Tt(e) + '"]' } function cl(e) { return "script[async]" + e } function Dm(e, t, n) { if (t.count++, t.instance === null) switch (t.type) { case "style": var l = e.querySelector('style[data-href~="' + Tt(n.href) + '"]'); if (l) return t.instance = l, Ye(l), l; var r = I({}, n, { "data-href": n.href, "data-precedence": n.precedence, href: null, precedence: null }); return l = (e.ownerDocument || e).createElement("style"), Ye(l), Fe(l, "style", r), Ks(l, n.precedence, e), t.instance = l; case "stylesheet": r = sa(n.href); var u = e.querySelector(ul(r)); if (u) return t.state.loading |= 4, t.instance = u, Ye(u), u; l = jm(n), (r = Vt.get(r)) && ju(l, r), u = (e.ownerDocument || e).createElement("link"), Ye(u); var p = u; return p._p = new Promise(function (b, T) { p.onload = b, p.onerror = T }), Fe(u, "link", l), t.state.loading |= 4, Ks(u, n.precedence, e), t.instance = u; case "script": return u = ra(n.src), (r = e.querySelector(cl(u))) ? (t.instance = r, Ye(r), r) : (l = n, (r = Vt.get(u)) && (l = I({}, n), Du(l, r)), e = e.ownerDocument || e, r = e.createElement("script"), Ye(r), Fe(r, "link", l), e.head.appendChild(r), t.instance = r); case "void": return null; default: throw Error(o(443, t.type)) } else t.type === "stylesheet" && !(t.state.loading & 4) && (l = t.instance, t.state.loading |= 4, Ks(l, n.precedence, e)); return t.instance } function Ks(e, t, n) { for (var l = n.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), r = l.length ? l[l.length - 1] : null, u = r, p = 0; p < l.length; p++) { var b = l[p]; if (b.dataset.precedence === t) u = b; else if (u !== r) break } u ? u.parentNode.insertBefore(e, u.nextSibling) : (t = n.nodeType === 9 ? n.head : n, t.insertBefore(e, t.firstChild)) } function ju(e, t) { e.crossOrigin == null && (e.crossOrigin = t.crossOrigin), e.referrerPolicy == null && (e.referrerPolicy = t.referrerPolicy), e.title == null && (e.title = t.title) } function Du(e, t) { e.crossOrigin == null && (e.crossOrigin = t.crossOrigin), e.referrerPolicy == null && (e.referrerPolicy = t.referrerPolicy), e.integrity == null && (e.integrity = t.integrity) } var Qs = null; function Mm(e, t, n) { if (Qs === null) { var l = new Map, r = Qs = new Map; r.set(n, l) } else r = Qs, l = r.get(n), l || (l = new Map, r.set(n, l)); if (l.has(e)) return l; for (l.set(e, null), n = n.getElementsByTagName(e), r = 0; r < n.length; r++) { var u = n[r]; if (!(u[Aa] || u[$e] || e === "link" && u.getAttribute("rel") === "stylesheet") && u.namespaceURI !== "http://www.w3.org/2000/svg") { var p = u.getAttribute(t) || ""; p = e + p; var b = l.get(p); b ? b.push(u) : l.set(p, [u]) } } return l } function Rm(e, t, n) { e = e.ownerDocument || e, e.head.insertBefore(n, t === "title" ? e.querySelector("head > title") : null) } function xb(e, t, n) { if (n === 1 || t.itemProp != null) return !1; switch (e) { case "meta": case "title": return !0; case "style": if (typeof t.precedence != "string" || typeof t.href != "string" || t.href === "") break; return !0; case "link": if (typeof t.rel != "string" || typeof t.href != "string" || t.href === "" || t.onLoad || t.onError) break; switch (t.rel) { case "stylesheet": return e = t.disabled, typeof t.precedence == "string" && e == null; default: return !0 }case "script": if (t.async && typeof t.async != "function" && typeof t.async != "symbol" && !t.onLoad && !t.onError && t.src && typeof t.src == "string") return !0 }return !1 } function Cm(e) { return !(e.type === "stylesheet" && !(e.state.loading & 3)) } var fl = null; function Sb() { } function Tb(e, t, n) { if (fl === null) throw Error(o(475)); var l = fl; if (t.type === "stylesheet" && (typeof n.media != "string" || matchMedia(n.media).matches !== !1) && !(t.state.loading & 4)) { if (t.instance === null) { var r = sa(n.href), u = e.querySelector(ul(r)); if (u) { e = u._p, e !== null && typeof e == "object" && typeof e.then == "function" && (l.count++, l = Zs.bind(l), e.then(l, l)), t.state.loading |= 4, t.instance = u, Ye(u); return } u = e.ownerDocument || e, n = jm(n), (r = Vt.get(r)) && ju(n, r), u = u.createElement("link"), Ye(u); var p = u; p._p = new Promise(function (b, T) { p.onload = b, p.onerror = T }), Fe(u, "link", n), t.instance = u } l.stylesheets === null && (l.stylesheets = new Map), l.stylesheets.set(t, e), (e = t.state.preload) && !(t.state.loading & 3) && (l.count++, t = Zs.bind(l), e.addEventListener("load", t), e.addEventListener("error", t)) } } function wb() { if (fl === null) throw Error(o(475)); var e = fl; return e.stylesheets && e.count === 0 && Mu(e, e.stylesheets), 0 < e.count ? function (t) { var n = setTimeout(function () { if (e.stylesheets && Mu(e, e.stylesheets), e.unsuspend) { var l = e.unsuspend; e.unsuspend = null, l() } }, 6e4); return e.unsuspend = t, function () { e.unsuspend = null, clearTimeout(n) } } : null } function Zs() { if (this.count--, this.count === 0) { if (this.stylesheets) Mu(this, this.stylesheets); else if (this.unsuspend) { var e = this.unsuspend; this.unsuspend = null, e() } } } var Ps = null; function Mu(e, t) { e.stylesheets = null, e.unsuspend !== null && (e.count++, Ps = new Map, t.forEach(Ab, e), Ps = null, Zs.call(e)) } function Ab(e, t) { if (!(t.state.loading & 4)) { var n = Ps.get(e); if (n) var l = n.get(null); else { n = new Map, Ps.set(e, n); for (var r = e.querySelectorAll("link[data-precedence],style[data-precedence]"), u = 0; u < r.length; u++) { var p = r[u]; (p.nodeName === "LINK" || p.getAttribute("media") !== "not all") && (n.set(p.dataset.precedence, p), l = p) } l && n.set(null, l) } r = t.instance, p = r.getAttribute("data-precedence"), u = n.get(p) || l, u === l && n.set(null, r), n.set(p, r), this.count++, l = Zs.bind(this), r.addEventListener("load", l), r.addEventListener("error", l), u ? u.parentNode.insertBefore(r, u.nextSibling) : (e = e.nodeType === 9 ? e.head : e, e.insertBefore(r, e.firstChild)), t.state.loading |= 4 } } var hl = { $$typeof: j, Provider: null, Consumer: null, _currentValue: de, _currentValue2: de, _threadCount: 0 }; function Eb(e, t, n, l, r, u, p, b) { this.tag = 1, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Rr(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Rr(0), this.hiddenUpdates = Rr(null), this.identifierPrefix = l, this.onUncaughtError = r, this.onCaughtError = u, this.onRecoverableError = p, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = b, this.incompleteTransitions = new Map } function Om(e, t, n, l, r, u, p, b, T, E, U, H) { return e = new Eb(e, t, n, p, b, T, E, H), t = 1, u === !0 && (t |= 24), u = Ct(3, null, null, t), e.current = u, u.stateNode = e, t = lo(), t.refCount++, e.pooledCache = t, t.refCount++, u.memoizedState = { element: l, isDehydrated: n, cache: t }, Ho(u), e } function Vm(e) { return e ? (e = ki, e) : ki } function zm(e, t, n, l, r, u) { r = Vm(r), l.context === null ? l.context = r : l.pendingContext = r, l = zn(t), l.payload = { element: n }, u = u === void 0 ? null : u, u !== null && (l.callback = u), n = _n(e, l, t), n !== null && (lt(n, e, t), Fa(n, e, t)) } function _m(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function Ru(e, t) { _m(e, t), (e = e.alternate) && _m(e, t) } function Bm(e) { if (e.tag === 13) { var t = jn(e, 67108864); t !== null && lt(t, e, 67108864), Ru(e, 67108864) } } var Fs = !0; function jb(e, t, n, l) { var r = Y.T; Y.T = null; var u = K.p; try { K.p = 2, Cu(e, t, n, l) } finally { K.p = u, Y.T = r } } function Db(e, t, n, l) { var r = Y.T; Y.T = null; var u = K.p; try { K.p = 8, Cu(e, t, n, l) } finally { K.p = u, Y.T = r } } function Cu(e, t, n, l) { if (Fs) { var r = Ou(l); if (r === null) vu(e, t, l, Js, n), Nm(e, l); else if (Rb(r, e, t, n, l)) l.stopPropagation(); else if (Nm(e, l), t & 4 && -1 < Mb.indexOf(e)) { for (; r !== null;) { var u = Mi(r); if (u !== null) switch (u.tag) { case 3: if (u = u.stateNode, u.current.memoizedState.isDehydrated) { var p = Wn(u.pendingLanes); if (p !== 0) { var b = u; for (b.pendingLanes |= 2, b.entangledLanes |= 2; p;) { var T = 1 << 31 - ft(p); b.entanglements[1] |= T, p &= ~T } Pt(u), !(De & 6) && (zs = Yt() + 500, sl(0)) } } break; case 13: b = jn(u, 2), b !== null && lt(b, u, 2), Us(), Ru(u, 2) }if (u = Ou(l), u === null && vu(e, t, l, Js, n), u === r) break; r = u } r !== null && l.stopPropagation() } else vu(e, t, l, null, n) } } function Ou(e) { return e = Ur(e), Vu(e) } var Js = null; function Vu(e) { if (Js = null, e = In(e), e !== null) { var t = F(e); if (t === null) e = null; else { var n = t.tag; if (n === 13) { if (e = ye(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null) } } return Js = e, null } function Um(e) { switch (e) { case "beforetoggle": case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "toggle": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 2; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 8; case "message": switch (dv()) { case sf: return 2; case rf: return 8; case Kl: case mv: return 32; case of: return 268435456; default: return 32 }default: return 32 } } var zu = !1, qn = null, Gn = null, Yn = null, dl = new Map, ml = new Map, Xn = [], Mb = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "); function Nm(e, t) { switch (e) { case "focusin": case "focusout": qn = null; break; case "dragenter": case "dragleave": Gn = null; break; case "mouseover": case "mouseout": Yn = null; break; case "pointerover": case "pointerout": dl.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": ml.delete(t.pointerId) } } function pl(e, t, n, l, r, u) { return e === null || e.nativeEvent !== u ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: l, nativeEvent: u, targetContainers: [r] }, t !== null && (t = Mi(t), t !== null && Bm(t)), e) : (e.eventSystemFlags |= l, t = e.targetContainers, r !== null && t.indexOf(r) === -1 && t.push(r), e) } function Rb(e, t, n, l, r) { switch (t) { case "focusin": return qn = pl(qn, e, t, n, l, r), !0; case "dragenter": return Gn = pl(Gn, e, t, n, l, r), !0; case "mouseover": return Yn = pl(Yn, e, t, n, l, r), !0; case "pointerover": var u = r.pointerId; return dl.set(u, pl(dl.get(u) || null, e, t, n, l, r)), !0; case "gotpointercapture": return u = r.pointerId, ml.set(u, pl(ml.get(u) || null, e, t, n, l, r)), !0 }return !1 } function Lm(e) { var t = In(e.target); if (t !== null) { var n = F(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = ye(n), t !== null) { e.blockedOn = t, wv(e.priority, function () { if (n.tag === 13) { var l = gt(), r = jn(n, l); r !== null && lt(r, n, l), Ru(n, l) } }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function $s(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = Ou(e.nativeEvent); if (n === null) { n = e.nativeEvent; var l = new n.constructor(n.type, n); Br = l, n.target.dispatchEvent(l), Br = null } else return t = Mi(n), t !== null && Bm(t), e.blockedOn = n, !1; t.shift() } return !0 } function km(e, t, n) { $s(e) && n.delete(t) } function Cb() { zu = !1, qn !== null && $s(qn) && (qn = null), Gn !== null && $s(Gn) && (Gn = null), Yn !== null && $s(Yn) && (Yn = null), dl.forEach(km), ml.forEach(km) } function Ws(e, t) { e.blockedOn === t && (e.blockedOn = null, zu || (zu = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, Cb))) } var Is = null; function Hm(e) { Is !== e && (Is = e, i.unstable_scheduleCallback(i.unstable_NormalPriority, function () { Is === e && (Is = null); for (var t = 0; t < e.length; t += 3) { var n = e[t], l = e[t + 1], r = e[t + 2]; if (typeof l != "function") { if (Vu(l || n) === null) continue; break } var u = Mi(n); u !== null && (e.splice(t, 3), t -= 3, To(u, { pending: !0, data: r, method: n.method, action: l }, l, r)) } })) } function gl(e) { function t(T) { return Ws(T, e) } qn !== null && Ws(qn, e), Gn !== null && Ws(Gn, e), Yn !== null && Ws(Yn, e), dl.forEach(t), ml.forEach(t); for (var n = 0; n < Xn.length; n++) { var l = Xn[n]; l.blockedOn === e && (l.blockedOn = null) } for (; 0 < Xn.length && (n = Xn[0], n.blockedOn === null);)Lm(n), n.blockedOn === null && Xn.shift(); if (n = (e.ownerDocument || e).$$reactFormReplay, n != null) for (l = 0; l < n.length; l += 3) { var r = n[l], u = n[l + 1], p = r[rt] || null; if (typeof u == "function") p || Hm(n); else if (p) { var b = null; if (u && u.hasAttribute("formAction")) { if (r = u, p = u[rt] || null) b = p.formAction; else if (Vu(r) !== null) continue } else b = p.action; typeof b == "function" ? n[l + 1] = b : (n.splice(l, 3), l -= 3), Hm(n) } } } function _u(e) { this._internalRoot = e } er.prototype.render = _u.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(o(409)); var n = t.current, l = gt(); zm(n, l, e, t, null, null) }, er.prototype.unmount = _u.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; e.tag === 0 && na(), zm(e.current, 2, null, e, null, null), Us(), t[Di] = null } }; function er(e) { this._internalRoot = e } er.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = mf(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Xn.length && t !== 0 && t < Xn[n].priority; n++); Xn.splice(n, 0, e), n === 0 && Lm(e) } }; var qm = a.version; if (qm !== "19.0.0") throw Error(o(527, qm, "19.0.0")); K.findDOMNode = function (e) { var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(o(188)) : (e = Object.keys(e).join(","), Error(o(268, e))); return e = G(t), e = e !== null ? ie(e) : null, e = e === null ? null : e.stateNode, e }; var Ob = { bundleType: 0, version: "19.0.0", rendererPackageName: "react-dom", currentDispatcherRef: Y, findFiberByHostInstance: In, reconcilerVersion: "19.0.0" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var tr = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!tr.isDisabled && tr.supportsFiber) try { Sa = tr.inject(Ob), ct = tr } catch { } } return vl.createRoot = function (e, t) { if (!c(e)) throw Error(o(299)); var n = !1, l = "", r = ad, u = ld, p = sd, b = null; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (l = t.identifierPrefix), t.onUncaughtError !== void 0 && (r = t.onUncaughtError), t.onCaughtError !== void 0 && (u = t.onCaughtError), t.onRecoverableError !== void 0 && (p = t.onRecoverableError), t.unstable_transitionCallbacks !== void 0 && (b = t.unstable_transitionCallbacks)), t = Om(e, 1, !1, null, null, n, l, r, u, p, b, null), e[Di] = t.current, yu(e.nodeType === 8 ? e.parentNode : e), new _u(t) }, vl.hydrateRoot = function (e, t, n) { if (!c(e)) throw Error(o(299)); var l = !1, r = "", u = ad, p = ld, b = sd, T = null, E = null; return n != null && (n.unstable_strictMode === !0 && (l = !0), n.identifierPrefix !== void 0 && (r = n.identifierPrefix), n.onUncaughtError !== void 0 && (u = n.onUncaughtError), n.onCaughtError !== void 0 && (p = n.onCaughtError), n.onRecoverableError !== void 0 && (b = n.onRecoverableError), n.unstable_transitionCallbacks !== void 0 && (T = n.unstable_transitionCallbacks), n.formState !== void 0 && (E = n.formState)), t = Om(e, 1, !0, t, n ?? null, l, r, u, p, b, T, E), t.context = Vm(null), n = t.current, l = gt(), r = zn(l), r.callback = null, _n(n, r, l), t.current.lanes = l, wa(t, l), Pt(t), e[Di] = t.current, yu(e), new er(t) }, vl.version = "19.0.0", vl
} var $m; function qb() { if ($m) return Nu.exports; $m = 1; function i() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(i) } catch (a) { console.error(a) } } return i(), Nu.exports = Hb(), Nu.exports } var Gb = qb(), bl = {}, Wm; function Yb() { if (Wm) return bl; Wm = 1, Object.defineProperty(bl, "__esModule", { value: !0 }), bl.parse = h, bl.serialize = m; const i = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, a = /^[\u0021-\u003A\u003C-\u007E]*$/, s = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, o = /^[\u0020-\u003A\u003D-\u007E]*$/, c = Object.prototype.toString, f = (() => { const S = function () { }; return S.prototype = Object.create(null), S })(); function h(S, j) { const D = new f, z = S.length; if (z < 2) return D; const _ = (j == null ? void 0 : j.decode) || v; let O = 0; do { const L = S.indexOf("=", O); if (L === -1) break; const N = S.indexOf(";", O), J = N === -1 ? z : N; if (L > J) { O = S.lastIndexOf(";", L - 1) + 1; continue } const q = g(S, O, L), ae = d(S, L, q), fe = S.slice(q, ae); if (D[fe] === void 0) { let W = g(S, L + 1, J), Y = d(S, J, W); const I = _(S.slice(W, Y)); D[fe] = I } O = J + 1 } while (O < z); return D } function g(S, j, D) { do { const z = S.charCodeAt(j); if (z !== 32 && z !== 9) return j } while (++j < D); return D } function d(S, j, D) { for (; j > D;) { const z = S.charCodeAt(--j); if (z !== 32 && z !== 9) return j + 1 } return D } function m(S, j, D) { const z = (D == null ? void 0 : D.encode) || encodeURIComponent; if (!i.test(S)) throw new TypeError(`argument name is invalid: ${S}`); const _ = z(j); if (!a.test(_)) throw new TypeError(`argument val is invalid: ${j}`); let O = S + "=" + _; if (!D) return O; if (D.maxAge !== void 0) { if (!Number.isInteger(D.maxAge)) throw new TypeError(`option maxAge is invalid: ${D.maxAge}`); O += "; Max-Age=" + D.maxAge } if (D.domain) { if (!s.test(D.domain)) throw new TypeError(`option domain is invalid: ${D.domain}`); O += "; Domain=" + D.domain } if (D.path) { if (!o.test(D.path)) throw new TypeError(`option path is invalid: ${D.path}`); O += "; Path=" + D.path } if (D.expires) { if (!x(D.expires) || !Number.isFinite(D.expires.valueOf())) throw new TypeError(`option expires is invalid: ${D.expires}`); O += "; Expires=" + D.expires.toUTCString() } if (D.httpOnly && (O += "; HttpOnly"), D.secure && (O += "; Secure"), D.partitioned && (O += "; Partitioned"), D.priority) switch (typeof D.priority == "string" ? D.priority.toLowerCase() : void 0) { case "low": O += "; Priority=Low"; break; case "medium": O += "; Priority=Medium"; break; case "high": O += "; Priority=High"; break; default: throw new TypeError(`option priority is invalid: ${D.priority}`) }if (D.sameSite) switch (typeof D.sameSite == "string" ? D.sameSite.toLowerCase() : D.sameSite) { case !0: case "strict": O += "; SameSite=Strict"; break; case "lax": O += "; SameSite=Lax"; break; case "none": O += "; SameSite=None"; break; default: throw new TypeError(`option sameSite is invalid: ${D.sameSite}`) }return O } function v(S) { if (S.indexOf("%") === -1) return S; try { return decodeURIComponent(S) } catch { return S } } function x(S) { return c.call(S) === "[object Date]" } return bl } Yb();/**
 * react-router v7.4.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */var Im = "popstate"; function Xb(i = {}) { function a(c, f) { let { pathname: h = "/", search: g = "", hash: d = "" } = Ai(c.location.hash.substring(1)); return !h.startsWith("/") && !h.startsWith(".") && (h = "/" + h), nc("", { pathname: h, search: g, hash: d }, f.state && f.state.usr || null, f.state && f.state.key || "default") } function s(c, f) { let h = c.document.querySelector("base"), g = ""; if (h && h.getAttribute("href")) { let d = c.location.href, m = d.indexOf("#"); g = m === -1 ? d : d.slice(0, m) } return g + "#" + (typeof f == "string" ? f : Dl(f)) } function o(c, f) { qt(c.pathname.charAt(0) === "/", `relative pathnames are not supported in hash history.push(${JSON.stringify(f)})`) } return Qb(a, s, o, i) } function Re(i, a) { if (i === !1 || i === null || typeof i > "u") throw new Error(a) } function qt(i, a) { if (!i) { typeof console < "u" && console.warn(a); try { throw new Error(a) } catch { } } } function Kb() { return Math.random().toString(36).substring(2, 10) } function ep(i, a) { return { usr: i.state, key: i.key, idx: a } } function nc(i, a, s = null, o) { return { pathname: typeof i == "string" ? i : i.pathname, search: "", hash: "", ...typeof a == "string" ? Ai(a) : a, state: s, key: a && a.key || o || Kb() } } function Dl({ pathname: i = "/", search: a = "", hash: s = "" }) { return a && a !== "?" && (i += a.charAt(0) === "?" ? a : "?" + a), s && s !== "#" && (i += s.charAt(0) === "#" ? s : "#" + s), i } function Ai(i) { let a = {}; if (i) { let s = i.indexOf("#"); s >= 0 && (a.hash = i.substring(s), i = i.substring(0, s)); let o = i.indexOf("?"); o >= 0 && (a.search = i.substring(o), i = i.substring(0, o)), i && (a.pathname = i) } return a } function Qb(i, a, s, o = {}) { let { window: c = document.defaultView, v5Compat: f = !1 } = o, h = c.history, g = "POP", d = null, m = v(); m == null && (m = 0, h.replaceState({ ...h.state, idx: m }, "")); function v() { return (h.state || { idx: null }).idx } function x() { g = "POP"; let _ = v(), O = _ == null ? null : _ - m; m = _, d && d({ action: g, location: z.location, delta: O }) } function S(_, O) { g = "PUSH"; let L = nc(z.location, _, O); s && s(L, _), m = v() + 1; let N = ep(L, m), J = z.createHref(L); try { h.pushState(N, "", J) } catch (q) { if (q instanceof DOMException && q.name === "DataCloneError") throw q; c.location.assign(J) } f && d && d({ action: g, location: z.location, delta: 1 }) } function j(_, O) { g = "REPLACE"; let L = nc(z.location, _, O); s && s(L, _), m = v(); let N = ep(L, m), J = z.createHref(L); h.replaceState(N, "", J), f && d && d({ action: g, location: z.location, delta: 0 }) } function D(_) { let O = c.location.origin !== "null" ? c.location.origin : c.location.href, L = typeof _ == "string" ? _ : Dl(_); return L = L.replace(/ $/, "%20"), Re(O, `No window.location.(origin|href) available to create URL for href: ${L}`), new URL(L, O) } let z = { get action() { return g }, get location() { return i(c, h) }, listen(_) { if (d) throw new Error("A history only accepts one active listener"); return c.addEventListener(Im, x), d = _, () => { c.removeEventListener(Im, x), d = null } }, createHref(_) { return a(c, _) }, createURL: D, encodeLocation(_) { let O = D(_); return { pathname: O.pathname, search: O.search, hash: O.hash } }, push: S, replace: j, go(_) { return h.go(_) } }; return z } function bg(i, a, s = "/") { return Zb(i, a, s, !1) } function Zb(i, a, s, o) { let c = typeof a == "string" ? Ai(a) : a, f = bn(c.pathname || "/", s); if (f == null) return null; let h = xg(i); Pb(h); let g = null; for (let d = 0; g == null && d < h.length; ++d) { let m = lx(f); g = ix(h[d], m, o) } return g } function xg(i, a = [], s = [], o = "") { let c = (f, h, g) => { let d = { relativePath: g === void 0 ? f.path || "" : g, caseSensitive: f.caseSensitive === !0, childrenIndex: h, route: f }; d.relativePath.startsWith("/") && (Re(d.relativePath.startsWith(o), `Absolute route path "${d.relativePath}" nested under path "${o}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`), d.relativePath = d.relativePath.slice(o.length)); let m = gn([o, d.relativePath]), v = s.concat(d); f.children && f.children.length > 0 && (Re(f.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${m}".`), xg(f.children, a, v, m)), !(f.path == null && !f.index) && a.push({ path: m, score: tx(m, f.index), routesMeta: v }) }; return i.forEach((f, h) => { var g; if (f.path === "" || !((g = f.path) != null && g.includes("?"))) c(f, h); else for (let d of Sg(f.path)) c(f, h, d) }), a } function Sg(i) { let a = i.split("/"); if (a.length === 0) return []; let [s, ...o] = a, c = s.endsWith("?"), f = s.replace(/\?$/, ""); if (o.length === 0) return c ? [f, ""] : [f]; let h = Sg(o.join("/")), g = []; return g.push(...h.map(d => d === "" ? f : [f, d].join("/"))), c && g.push(...h), g.map(d => i.startsWith("/") && d === "" ? "/" : d) } function Pb(i) { i.sort((a, s) => a.score !== s.score ? s.score - a.score : nx(a.routesMeta.map(o => o.childrenIndex), s.routesMeta.map(o => o.childrenIndex))) } var Fb = /^:[\w-]+$/, Jb = 3, $b = 2, Wb = 1, Ib = 10, ex = -2, tp = i => i === "*"; function tx(i, a) { let s = i.split("/"), o = s.length; return s.some(tp) && (o += ex), a && (o += $b), s.filter(c => !tp(c)).reduce((c, f) => c + (Fb.test(f) ? Jb : f === "" ? Wb : Ib), o) } function nx(i, a) { return i.length === a.length && i.slice(0, -1).every((o, c) => o === a[c]) ? i[i.length - 1] - a[a.length - 1] : 0 } function ix(i, a, s = !1) { let { routesMeta: o } = i, c = {}, f = "/", h = []; for (let g = 0; g < o.length; ++g) { let d = o[g], m = g === o.length - 1, v = f === "/" ? a : a.slice(f.length) || "/", x = fr({ path: d.relativePath, caseSensitive: d.caseSensitive, end: m }, v), S = d.route; if (!x && m && s && !o[o.length - 1].route.index && (x = fr({ path: d.relativePath, caseSensitive: d.caseSensitive, end: !1 }, v)), !x) return null; Object.assign(c, x.params), h.push({ params: c, pathname: gn([f, x.pathname]), pathnameBase: ux(gn([f, x.pathnameBase])), route: S }), x.pathnameBase !== "/" && (f = gn([f, x.pathnameBase])) } return h } function fr(i, a) { typeof i == "string" && (i = { path: i, caseSensitive: !1, end: !0 }); let [s, o] = ax(i.path, i.caseSensitive, i.end), c = a.match(s); if (!c) return null; let f = c[0], h = f.replace(/(.)\/+$/, "$1"), g = c.slice(1); return { params: o.reduce((m, { paramName: v, isOptional: x }, S) => { if (v === "*") { let D = g[S] || ""; h = f.slice(0, f.length - D.length).replace(/(.)\/+$/, "$1") } const j = g[S]; return x && !j ? m[v] = void 0 : m[v] = (j || "").replace(/%2F/g, "/"), m }, {}), pathname: f, pathnameBase: h, pattern: i } } function ax(i, a = !1, s = !0) { qt(i === "*" || !i.endsWith("*") || i.endsWith("/*"), `Route path "${i}" will be treated as if it were "${i.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${i.replace(/\*$/, "/*")}".`); let o = [], c = "^" + i.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (h, g, d) => (o.push({ paramName: g, isOptional: d != null }), d ? "/?([^\\/]+)?" : "/([^\\/]+)")); return i.endsWith("*") ? (o.push({ paramName: "*" }), c += i === "*" || i === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : s ? c += "\\/*$" : i !== "" && i !== "/" && (c += "(?:(?=\\/|$))"), [new RegExp(c, a ? void 0 : "i"), o] } function lx(i) { try { return i.split("/").map(a => decodeURIComponent(a).replace(/\//g, "%2F")).join("/") } catch (a) { return qt(!1, `The URL path "${i}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${a}).`), i } } function bn(i, a) { if (a === "/") return i; if (!i.toLowerCase().startsWith(a.toLowerCase())) return null; let s = a.endsWith("/") ? a.length - 1 : a.length, o = i.charAt(s); return o && o !== "/" ? null : i.slice(s) || "/" } function sx(i, a = "/") { let { pathname: s, search: o = "", hash: c = "" } = typeof i == "string" ? Ai(i) : i; return { pathname: s ? s.startsWith("/") ? s : rx(s, a) : a, search: cx(o), hash: fx(c) } } function rx(i, a) { let s = a.replace(/\/+$/, "").split("/"); return i.split("/").forEach(c => { c === ".." ? s.length > 1 && s.pop() : c !== "." && s.push(c) }), s.length > 1 ? s.join("/") : "/" } function qu(i, a, s, o) { return `Cannot include a '${i}' character in a manually specified \`to.${a}\` field [${JSON.stringify(o)}].  Please separate it out to the \`to.${s}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.` } function ox(i) { return i.filter((a, s) => s === 0 || a.route.path && a.route.path.length > 0) } function Tg(i) { let a = ox(i); return a.map((s, o) => o === a.length - 1 ? s.pathname : s.pathnameBase) } function wg(i, a, s, o = !1) { let c; typeof i == "string" ? c = Ai(i) : (c = { ...i }, Re(!c.pathname || !c.pathname.includes("?"), qu("?", "pathname", "search", c)), Re(!c.pathname || !c.pathname.includes("#"), qu("#", "pathname", "hash", c)), Re(!c.search || !c.search.includes("#"), qu("#", "search", "hash", c))); let f = i === "" || c.pathname === "", h = f ? "/" : c.pathname, g; if (h == null) g = s; else { let x = a.length - 1; if (!o && h.startsWith("..")) { let S = h.split("/"); for (; S[0] === "..";)S.shift(), x -= 1; c.pathname = S.join("/") } g = x >= 0 ? a[x] : "/" } let d = sx(c, g), m = h && h !== "/" && h.endsWith("/"), v = (f || h === ".") && s.endsWith("/"); return !d.pathname.endsWith("/") && (m || v) && (d.pathname += "/"), d } var gn = i => i.join("/").replace(/\/\/+/g, "/"), ux = i => i.replace(/\/+$/, "").replace(/^\/*/, "/"), cx = i => !i || i === "?" ? "" : i.startsWith("?") ? i : "?" + i, fx = i => !i || i === "#" ? "" : i.startsWith("#") ? i : "#" + i; function hx(i) { return i != null && typeof i.status == "number" && typeof i.statusText == "string" && typeof i.internal == "boolean" && "data" in i } var Ag = ["POST", "PUT", "PATCH", "DELETE"]; new Set(Ag); var dx = ["GET", ...Ag]; new Set(dx); var ya = C.createContext(null); ya.displayName = "DataRouter"; var br = C.createContext(null); br.displayName = "DataRouterState"; var Eg = C.createContext({ isTransitioning: !1 }); Eg.displayName = "ViewTransition"; var mx = C.createContext(new Map); mx.displayName = "Fetchers"; var px = C.createContext(null); px.displayName = "Await"; var $t = C.createContext(null); $t.displayName = "Navigation"; var Bl = C.createContext(null); Bl.displayName = "Location"; var Sn = C.createContext({ outlet: null, matches: [], isDataRoute: !1 }); Sn.displayName = "Route"; var Sc = C.createContext(null); Sc.displayName = "RouteError"; function gx(i, { relative: a } = {}) { Re(Ul(), "useHref() may be used only in the context of a <Router> component."); let { basename: s, navigator: o } = C.useContext($t), { hash: c, pathname: f, search: h } = Nl(i, { relative: a }), g = f; return s !== "/" && (g = f === "/" ? s : gn([s, f])), o.createHref({ pathname: g, search: h, hash: c }) } function Ul() { return C.useContext(Bl) != null } function Jn() { return Re(Ul(), "useLocation() may be used only in the context of a <Router> component."), C.useContext(Bl).location } var jg = "You should call navigate() in a React.useEffect(), not when your component is first rendered."; function Dg(i) { C.useContext($t).static || C.useLayoutEffect(i) } function Mg() { let { isDataRoute: i } = C.useContext(Sn); return i ? Rx() : yx() } function yx() { Re(Ul(), "useNavigate() may be used only in the context of a <Router> component."); let i = C.useContext(ya), { basename: a, navigator: s } = C.useContext($t), { matches: o } = C.useContext(Sn), { pathname: c } = Jn(), f = JSON.stringify(Tg(o)), h = C.useRef(!1); return Dg(() => { h.current = !0 }), C.useCallback((d, m = {}) => { if (qt(h.current, jg), !h.current) return; if (typeof d == "number") { s.go(d); return } let v = wg(d, JSON.parse(f), c, m.relative === "path"); i == null && a !== "/" && (v.pathname = v.pathname === "/" ? a : gn([a, v.pathname])), (m.replace ? s.replace : s.push)(v, m.state, m) }, [a, s, f, c, i]) } C.createContext(null); function Nl(i, { relative: a } = {}) { let { matches: s } = C.useContext(Sn), { pathname: o } = Jn(), c = JSON.stringify(Tg(s)); return C.useMemo(() => wg(i, JSON.parse(c), o, a === "path"), [i, c, o, a]) } function vx(i, a) { return Rg(i, a) } function Rg(i, a, s, o) {
    var L; Re(Ul(), "useRoutes() may be used only in the context of a <Router> component."); let { navigator: c, static: f } = C.useContext($t), { matches: h } = C.useContext(Sn), g = h[h.length - 1], d = g ? g.params : {}, m = g ? g.pathname : "/", v = g ? g.pathnameBase : "/", x = g && g.route; {
        let N = x && x.path || ""; Cg(m, !x || N.endsWith("*") || N.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${m}" (under <Route path="${N}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${N}"> to <Route path="${N === "/" ? "*" : `${N}/*`}">.`)
    } let S = Jn(), j; if (a) { let N = typeof a == "string" ? Ai(a) : a; Re(v === "/" || ((L = N.pathname) == null ? void 0 : L.startsWith(v)), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${v}" but pathname "${N.pathname}" was given in the \`location\` prop.`), j = N } else j = S; let D = j.pathname || "/", z = D; if (v !== "/") { let N = v.replace(/^\//, "").split("/"); z = "/" + D.replace(/^\//, "").split("/").slice(N.length).join("/") } let _ = !f && s && s.matches && s.matches.length > 0 ? s.matches : bg(i, { pathname: z }); qt(x || _ != null, `No routes matched location "${j.pathname}${j.search}${j.hash}" `), qt(_ == null || _[_.length - 1].route.element !== void 0 || _[_.length - 1].route.Component !== void 0 || _[_.length - 1].route.lazy !== void 0, `Matched leaf route at location "${j.pathname}${j.search}${j.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`); let O = wx(_ && _.map(N => Object.assign({}, N, { params: Object.assign({}, d, N.params), pathname: gn([v, c.encodeLocation ? c.encodeLocation(N.pathname).pathname : N.pathname]), pathnameBase: N.pathnameBase === "/" ? v : gn([v, c.encodeLocation ? c.encodeLocation(N.pathnameBase).pathname : N.pathnameBase]) })), h, s, o); return a && O ? C.createElement(Bl.Provider, { value: { location: { pathname: "/", search: "", hash: "", state: null, key: "default", ...j }, navigationType: "POP" } }, O) : O
} function bx() { let i = Mx(), a = hx(i) ? `${i.status} ${i.statusText}` : i instanceof Error ? i.message : JSON.stringify(i), s = i instanceof Error ? i.stack : null, o = "rgba(200,200,200, 0.5)", c = { padding: "0.5rem", backgroundColor: o }, f = { padding: "2px 4px", backgroundColor: o }, h = null; return console.error("Error handled by React Router default ErrorBoundary:", i), h = C.createElement(C.Fragment, null, C.createElement("p", null, "💿 Hey developer 👋"), C.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", C.createElement("code", { style: f }, "ErrorBoundary"), " or", " ", C.createElement("code", { style: f }, "errorElement"), " prop on your route.")), C.createElement(C.Fragment, null, C.createElement("h2", null, "Unexpected Application Error!"), C.createElement("h3", { style: { fontStyle: "italic" } }, a), s ? C.createElement("pre", { style: c }, s) : null, h) } var xx = C.createElement(bx, null), Sx = class extends C.Component { constructor(i) { super(i), this.state = { location: i.location, revalidation: i.revalidation, error: i.error } } static getDerivedStateFromError(i) { return { error: i } } static getDerivedStateFromProps(i, a) { return a.location !== i.location || a.revalidation !== "idle" && i.revalidation === "idle" ? { error: i.error, location: i.location, revalidation: i.revalidation } : { error: i.error !== void 0 ? i.error : a.error, location: a.location, revalidation: i.revalidation || a.revalidation } } componentDidCatch(i, a) { console.error("React Router caught the following error during render", i, a) } render() { return this.state.error !== void 0 ? C.createElement(Sn.Provider, { value: this.props.routeContext }, C.createElement(Sc.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } }; function Tx({ routeContext: i, match: a, children: s }) { let o = C.useContext(ya); return o && o.static && o.staticContext && (a.route.errorElement || a.route.ErrorBoundary) && (o.staticContext._deepestRenderedBoundaryId = a.route.id), C.createElement(Sn.Provider, { value: i }, s) } function wx(i, a = [], s = null, o = null) { if (i == null) { if (!s) return null; if (s.errors) i = s.matches; else if (a.length === 0 && !s.initialized && s.matches.length > 0) i = s.matches; else return null } let c = i, f = s == null ? void 0 : s.errors; if (f != null) { let d = c.findIndex(m => m.route.id && (f == null ? void 0 : f[m.route.id]) !== void 0); Re(d >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(f).join(",")}`), c = c.slice(0, Math.min(c.length, d + 1)) } let h = !1, g = -1; if (s) for (let d = 0; d < c.length; d++) { let m = c[d]; if ((m.route.HydrateFallback || m.route.hydrateFallbackElement) && (g = d), m.route.id) { let { loaderData: v, errors: x } = s, S = m.route.loader && !v.hasOwnProperty(m.route.id) && (!x || x[m.route.id] === void 0); if (m.route.lazy || S) { h = !0, g >= 0 ? c = c.slice(0, g + 1) : c = [c[0]]; break } } } return c.reduceRight((d, m, v) => { let x, S = !1, j = null, D = null; s && (x = f && m.route.id ? f[m.route.id] : void 0, j = m.route.errorElement || xx, h && (g < 0 && v === 0 ? (Cg("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), S = !0, D = null) : g === v && (S = !0, D = m.route.hydrateFallbackElement || null))); let z = a.concat(c.slice(0, v + 1)), _ = () => { let O; return x ? O = j : S ? O = D : m.route.Component ? O = C.createElement(m.route.Component, null) : m.route.element ? O = m.route.element : O = d, C.createElement(Tx, { match: m, routeContext: { outlet: d, matches: z, isDataRoute: s != null }, children: O }) }; return s && (m.route.ErrorBoundary || m.route.errorElement || v === 0) ? C.createElement(Sx, { location: s.location, revalidation: s.revalidation, component: j, error: x, children: _(), routeContext: { outlet: null, matches: z, isDataRoute: !0 } }) : _() }, null) } function Tc(i) { return `${i} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.` } function Ax(i) { let a = C.useContext(ya); return Re(a, Tc(i)), a } function Ex(i) { let a = C.useContext(br); return Re(a, Tc(i)), a } function jx(i) { let a = C.useContext(Sn); return Re(a, Tc(i)), a } function wc(i) { let a = jx(i), s = a.matches[a.matches.length - 1]; return Re(s.route.id, `${i} can only be used on routes that contain a unique "id"`), s.route.id } function Dx() { return wc("useRouteId") } function Mx() { var o; let i = C.useContext(Sc), a = Ex("useRouteError"), s = wc("useRouteError"); return i !== void 0 ? i : (o = a.errors) == null ? void 0 : o[s] } function Rx() { let { router: i } = Ax("useNavigate"), a = wc("useNavigate"), s = C.useRef(!1); return Dg(() => { s.current = !0 }), C.useCallback(async (c, f = {}) => { qt(s.current, jg), s.current && (typeof c == "number" ? i.navigate(c) : await i.navigate(c, { fromRouteId: a, ...f })) }, [i, a]) } var np = {}; function Cg(i, a, s) { !a && !np[i] && (np[i] = !0, qt(!1, s)) } C.memo(Cx); function Cx({ routes: i, future: a, state: s }) { return Rg(i, void 0, s, a) } function Qn(i) { Re(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") } function Ox({ basename: i = "/", children: a = null, location: s, navigationType: o = "POP", navigator: c, static: f = !1 }) { Re(!Ul(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."); let h = i.replace(/^\/*/, "/"), g = C.useMemo(() => ({ basename: h, navigator: c, static: f, future: {} }), [h, c, f]); typeof s == "string" && (s = Ai(s)); let { pathname: d = "/", search: m = "", hash: v = "", state: x = null, key: S = "default" } = s, j = C.useMemo(() => { let D = bn(d, h); return D == null ? null : { location: { pathname: D, search: m, hash: v, state: x, key: S }, navigationType: o } }, [h, d, m, v, x, S, o]); return qt(j != null, `<Router basename="${h}"> is not able to match the URL "${d}${m}${v}" because it does not start with the basename, so the <Router> won't render anything.`), j == null ? null : C.createElement($t.Provider, { value: g }, C.createElement(Bl.Provider, { children: a, value: j })) } function Vx({ children: i, location: a }) { return vx(ic(i), a) } function ic(i, a = []) { let s = []; return C.Children.forEach(i, (o, c) => { if (!C.isValidElement(o)) return; let f = [...a, c]; if (o.type === C.Fragment) { s.push.apply(s, ic(o.props.children, f)); return } Re(o.type === Qn, `[${typeof o.type == "string" ? o.type : o.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`), Re(!o.props.index || !o.props.children, "An index route cannot have child routes."); let h = { id: o.props.id || f.join("-"), caseSensitive: o.props.caseSensitive, element: o.props.element, Component: o.props.Component, index: o.props.index, path: o.props.path, loader: o.props.loader, action: o.props.action, hydrateFallbackElement: o.props.hydrateFallbackElement, HydrateFallback: o.props.HydrateFallback, errorElement: o.props.errorElement, ErrorBoundary: o.props.ErrorBoundary, hasErrorBoundary: o.props.hasErrorBoundary === !0 || o.props.ErrorBoundary != null || o.props.errorElement != null, shouldRevalidate: o.props.shouldRevalidate, handle: o.props.handle, lazy: o.props.lazy }; o.props.children && (h.children = ic(o.props.children, f)), s.push(h) }), s } var sr = "get", rr = "application/x-www-form-urlencoded"; function xr(i) { return i != null && typeof i.tagName == "string" } function zx(i) { return xr(i) && i.tagName.toLowerCase() === "button" } function _x(i) { return xr(i) && i.tagName.toLowerCase() === "form" } function Bx(i) { return xr(i) && i.tagName.toLowerCase() === "input" } function Ux(i) { return !!(i.metaKey || i.altKey || i.ctrlKey || i.shiftKey) } function Nx(i, a) { return i.button === 0 && (!a || a === "_self") && !Ux(i) } var nr = null; function Lx() { if (nr === null) try { new FormData(document.createElement("form"), 0), nr = !1 } catch { nr = !0 } return nr } var kx = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]); function Gu(i) { return i != null && !kx.has(i) ? (qt(!1, `"${i}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${rr}"`), null) : i } function Hx(i, a) { let s, o, c, f, h; if (_x(i)) { let g = i.getAttribute("action"); o = g ? bn(g, a) : null, s = i.getAttribute("method") || sr, c = Gu(i.getAttribute("enctype")) || rr, f = new FormData(i) } else if (zx(i) || Bx(i) && (i.type === "submit" || i.type === "image")) { let g = i.form; if (g == null) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>'); let d = i.getAttribute("formaction") || g.getAttribute("action"); if (o = d ? bn(d, a) : null, s = i.getAttribute("formmethod") || g.getAttribute("method") || sr, c = Gu(i.getAttribute("formenctype")) || Gu(g.getAttribute("enctype")) || rr, f = new FormData(g, i), !Lx()) { let { name: m, type: v, value: x } = i; if (v === "image") { let S = m ? `${m}.` : ""; f.append(`${S}x`, "0"), f.append(`${S}y`, "0") } else m && f.append(m, x) } } else { if (xr(i)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">'); s = sr, o = null, c = rr, h = i } return f && c === "text/plain" && (h = f, f = void 0), { action: o, method: s.toLowerCase(), encType: c, formData: f, body: h } } function Ac(i, a) { if (i === !1 || i === null || typeof i > "u") throw new Error(a) } async function qx(i, a) { if (i.id in a) return a[i.id]; try { let s = await import(i.module); return a[i.id] = s, s } catch (s) { return console.error(`Error loading route module \`${i.module}\`, reloading page...`), console.error(s), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => { }) } } function Gx(i) { return i == null ? !1 : i.href == null ? i.rel === "preload" && typeof i.imageSrcSet == "string" && typeof i.imageSizes == "string" : typeof i.rel == "string" && typeof i.href == "string" } async function Yx(i, a, s) { let o = await Promise.all(i.map(async c => { let f = a.routes[c.route.id]; if (f) { let h = await qx(f, s); return h.links ? h.links() : [] } return [] })); return Zx(o.flat(1).filter(Gx).filter(c => c.rel === "stylesheet" || c.rel === "preload").map(c => c.rel === "stylesheet" ? { ...c, rel: "prefetch", as: "style" } : { ...c, rel: "prefetch" })) } function ip(i, a, s, o, c, f) { let h = (d, m) => s[m] ? d.route.id !== s[m].route.id : !0, g = (d, m) => { var v; return s[m].pathname !== d.pathname || ((v = s[m].route.path) == null ? void 0 : v.endsWith("*")) && s[m].params["*"] !== d.params["*"] }; return f === "assets" ? a.filter((d, m) => h(d, m) || g(d, m)) : f === "data" ? a.filter((d, m) => { var x; let v = o.routes[d.route.id]; if (!v || !v.hasLoader) return !1; if (h(d, m) || g(d, m)) return !0; if (d.route.shouldRevalidate) { let S = d.route.shouldRevalidate({ currentUrl: new URL(c.pathname + c.search + c.hash, window.origin), currentParams: ((x = s[0]) == null ? void 0 : x.params) || {}, nextUrl: new URL(i, window.origin), nextParams: d.params, defaultShouldRevalidate: !0 }); if (typeof S == "boolean") return S } return !0 }) : [] } function Xx(i, a, { includeHydrateFallback: s } = {}) { return Kx(i.map(o => { let c = a.routes[o.route.id]; if (!c) return []; let f = [c.module]; return c.clientActionModule && (f = f.concat(c.clientActionModule)), c.clientLoaderModule && (f = f.concat(c.clientLoaderModule)), s && c.hydrateFallbackModule && (f = f.concat(c.hydrateFallbackModule)), c.imports && (f = f.concat(c.imports)), f }).flat(1)) } function Kx(i) { return [...new Set(i)] } function Qx(i) { let a = {}, s = Object.keys(i).sort(); for (let o of s) a[o] = i[o]; return a } function Zx(i, a) { let s = new Set; return new Set(a), i.reduce((o, c) => { let f = JSON.stringify(Qx(c)); return s.has(f) || (s.add(f), o.push({ key: f, link: c })), o }, []) } function Px(i, a) { let s = typeof i == "string" ? new URL(i, typeof window > "u" ? "server://singlefetch/" : window.location.origin) : i; return s.pathname === "/" ? s.pathname = "_root.data" : a && bn(s.pathname, a) === "/" ? s.pathname = `${a.replace(/\/$/, "")}/_root.data` : s.pathname = `${s.pathname.replace(/\/$/, "")}.data`, s } function Og() { let i = C.useContext(ya); return Ac(i, "You must render this element inside a <DataRouterContext.Provider> element"), i } function Fx() { let i = C.useContext(br); return Ac(i, "You must render this element inside a <DataRouterStateContext.Provider> element"), i } var Ec = C.createContext(void 0); Ec.displayName = "FrameworkContext"; function Vg() { let i = C.useContext(Ec); return Ac(i, "You must render this element inside a <HydratedRouter> element"), i } function Jx(i, a) { let s = C.useContext(Ec), [o, c] = C.useState(!1), [f, h] = C.useState(!1), { onFocus: g, onBlur: d, onMouseEnter: m, onMouseLeave: v, onTouchStart: x } = a, S = C.useRef(null); C.useEffect(() => { if (i === "render" && h(!0), i === "viewport") { let z = O => { O.forEach(L => { h(L.isIntersecting) }) }, _ = new IntersectionObserver(z, { threshold: .5 }); return S.current && _.observe(S.current), () => { _.disconnect() } } }, [i]), C.useEffect(() => { if (o) { let z = setTimeout(() => { h(!0) }, 100); return () => { clearTimeout(z) } } }, [o]); let j = () => { c(!0) }, D = () => { c(!1), h(!1) }; return s ? i !== "intent" ? [f, S, {}] : [f, S, { onFocus: xl(g, j), onBlur: xl(d, D), onMouseEnter: xl(m, j), onMouseLeave: xl(v, D), onTouchStart: xl(x, j) }] : [!1, S, {}] } function xl(i, a) { return s => { i && i(s), s.defaultPrevented || a(s) } } function $x({ page: i, ...a }) { let { router: s } = Og(), o = C.useMemo(() => bg(s.routes, i, s.basename), [s.routes, i, s.basename]); return o ? C.createElement(Ix, { page: i, matches: o, ...a }) : null } function Wx(i) { let { manifest: a, routeModules: s } = Vg(), [o, c] = C.useState([]); return C.useEffect(() => { let f = !1; return Yx(i, a, s).then(h => { f || c(h) }), () => { f = !0 } }, [i, a, s]), o } function Ix({ page: i, matches: a, ...s }) { let o = Jn(), { manifest: c, routeModules: f } = Vg(), { basename: h } = Og(), { loaderData: g, matches: d } = Fx(), m = C.useMemo(() => ip(i, a, d, c, o, "data"), [i, a, d, c, o]), v = C.useMemo(() => ip(i, a, d, c, o, "assets"), [i, a, d, c, o]), x = C.useMemo(() => { if (i === o.pathname + o.search + o.hash) return []; let D = new Set, z = !1; if (a.forEach(O => { var N; let L = c.routes[O.route.id]; !L || !L.hasLoader || (!m.some(J => J.route.id === O.route.id) && O.route.id in g && ((N = f[O.route.id]) != null && N.shouldRevalidate) || L.hasClientLoader ? z = !0 : D.add(O.route.id)) }), D.size === 0) return []; let _ = Px(i, h); return z && D.size > 0 && _.searchParams.set("_routes", a.filter(O => D.has(O.route.id)).map(O => O.route.id).join(",")), [_.pathname + _.search] }, [h, g, o, c, m, a, i, f]), S = C.useMemo(() => Xx(v, c), [v, c]), j = Wx(v); return C.createElement(C.Fragment, null, x.map(D => C.createElement("link", { key: D, rel: "prefetch", as: "fetch", href: D, ...s })), S.map(D => C.createElement("link", { key: D, rel: "modulepreload", href: D, ...s })), j.map(({ key: D, link: z }) => C.createElement("link", { key: D, ...z }))) } function e1(...i) { return a => { i.forEach(s => { typeof s == "function" ? s(a) : s != null && (s.current = a) }) } } var zg = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"; try { zg && (window.__reactRouterVersion = "7.4.0") } catch { } function t1({ basename: i, children: a, window: s }) { let o = C.useRef(); o.current == null && (o.current = Xb({ window: s, v5Compat: !0 })); let c = o.current, [f, h] = C.useState({ action: c.action, location: c.location }), g = C.useCallback(d => { C.startTransition(() => h(d)) }, [h]); return C.useLayoutEffect(() => c.listen(g), [c, g]), C.createElement(Ox, { basename: i, children: a, location: f.location, navigationType: f.action, navigator: c }) } var _g = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Ht = C.forwardRef(function ({ onClick: a, discover: s = "render", prefetch: o = "none", relative: c, reloadDocument: f, replace: h, state: g, target: d, to: m, preventScrollReset: v, viewTransition: x, ...S }, j) { let { basename: D } = C.useContext($t), z = typeof m == "string" && _g.test(m), _, O = !1; if (typeof m == "string" && z && (_ = m, zg)) try { let Y = new URL(window.location.href), I = m.startsWith("//") ? new URL(Y.protocol + m) : new URL(m), Ce = bn(I.pathname, D); I.origin === Y.origin && Ce != null ? m = Ce + I.search + I.hash : O = !0 } catch { qt(!1, `<Link to="${m}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`) } let L = gx(m, { relative: c }), [N, J, q] = Jx(o, S), ae = l1(m, { replace: h, state: g, target: d, preventScrollReset: v, relative: c, viewTransition: x }); function fe(Y) { a && a(Y), Y.defaultPrevented || ae(Y) } let W = C.createElement("a", { ...S, ...q, href: _ || L, onClick: O || f ? a : fe, ref: e1(j, J), target: d, "data-discover": !z && s === "render" ? "true" : void 0 }); return N && !z ? C.createElement(C.Fragment, null, W, C.createElement($x, { page: L })) : W }); Ht.displayName = "Link"; var n1 = C.forwardRef(function ({ "aria-current": a = "page", caseSensitive: s = !1, className: o = "", end: c = !1, style: f, to: h, viewTransition: g, children: d, ...m }, v) { let x = Nl(h, { relative: m.relative }), S = Jn(), j = C.useContext(br), { navigator: D, basename: z } = C.useContext($t), _ = j != null && c1(x) && g === !0, O = D.encodeLocation ? D.encodeLocation(x).pathname : x.pathname, L = S.pathname, N = j && j.navigation && j.navigation.location ? j.navigation.location.pathname : null; s || (L = L.toLowerCase(), N = N ? N.toLowerCase() : null, O = O.toLowerCase()), N && z && (N = bn(N, z) || N); const J = O !== "/" && O.endsWith("/") ? O.length - 1 : O.length; let q = L === O || !c && L.startsWith(O) && L.charAt(J) === "/", ae = N != null && (N === O || !c && N.startsWith(O) && N.charAt(O.length) === "/"), fe = { isActive: q, isPending: ae, isTransitioning: _ }, W = q ? a : void 0, Y; typeof o == "function" ? Y = o(fe) : Y = [o, q ? "active" : null, ae ? "pending" : null, _ ? "transitioning" : null].filter(Boolean).join(" "); let I = typeof f == "function" ? f(fe) : f; return C.createElement(Ht, { ...m, "aria-current": W, className: Y, ref: v, style: I, to: h, viewTransition: g }, typeof d == "function" ? d(fe) : d) }); n1.displayName = "NavLink"; var i1 = C.forwardRef(({ discover: i = "render", fetcherKey: a, navigate: s, reloadDocument: o, replace: c, state: f, method: h = sr, action: g, onSubmit: d, relative: m, preventScrollReset: v, viewTransition: x, ...S }, j) => { let D = o1(), z = u1(g, { relative: m }), _ = h.toLowerCase() === "get" ? "get" : "post", O = typeof g == "string" && _g.test(g), L = N => { if (d && d(N), N.defaultPrevented) return; N.preventDefault(); let J = N.nativeEvent.submitter, q = (J == null ? void 0 : J.getAttribute("formmethod")) || h; D(J || N.currentTarget, { fetcherKey: a, method: q, navigate: s, replace: c, state: f, relative: m, preventScrollReset: v, viewTransition: x }) }; return C.createElement("form", { ref: j, method: _, action: z, onSubmit: o ? d : L, ...S, "data-discover": !O && i === "render" ? "true" : void 0 }) }); i1.displayName = "Form"; function a1(i) { return `${i} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.` } function Bg(i) { let a = C.useContext(ya); return Re(a, a1(i)), a } function l1(i, { target: a, replace: s, state: o, preventScrollReset: c, relative: f, viewTransition: h } = {}) { let g = Mg(), d = Jn(), m = Nl(i, { relative: f }); return C.useCallback(v => { if (Nx(v, a)) { v.preventDefault(); let x = s !== void 0 ? s : Dl(d) === Dl(m); g(i, { replace: x, state: o, preventScrollReset: c, relative: f, viewTransition: h }) } }, [d, g, m, s, o, a, i, c, f, h]) } var s1 = 0, r1 = () => `__${String(++s1)}__`; function o1() { let { router: i } = Bg("useSubmit"), { basename: a } = C.useContext($t), s = Dx(); return C.useCallback(async (o, c = {}) => { let { action: f, method: h, encType: g, formData: d, body: m } = Hx(o, a); if (c.navigate === !1) { let v = c.fetcherKey || r1(); await i.fetch(v, s, c.action || f, { preventScrollReset: c.preventScrollReset, formData: d, body: m, formMethod: c.method || h, formEncType: c.encType || g, flushSync: c.flushSync }) } else await i.navigate(c.action || f, { preventScrollReset: c.preventScrollReset, formData: d, body: m, formMethod: c.method || h, formEncType: c.encType || g, replace: c.replace, state: c.state, fromRouteId: s, flushSync: c.flushSync, viewTransition: c.viewTransition }) }, [i, a, s]) } function u1(i, { relative: a } = {}) { let { basename: s } = C.useContext($t), o = C.useContext(Sn); Re(o, "useFormAction must be used inside a RouteContext"); let [c] = o.matches.slice(-1), f = { ...Nl(i || ".", { relative: a }) }, h = Jn(); if (i == null) { f.search = h.search; let g = new URLSearchParams(f.search), d = g.getAll("index"); if (d.some(v => v === "")) { g.delete("index"), d.filter(x => x).forEach(x => g.append("index", x)); let v = g.toString(); f.search = v ? `?${v}` : "" } } return (!i || i === ".") && c.route.index && (f.search = f.search ? f.search.replace(/^\?/, "?index&") : "?index"), s !== "/" && (f.pathname = f.pathname === "/" ? s : gn([s, f.pathname])), Dl(f) } function c1(i, a = {}) { let s = C.useContext(Eg); Re(s != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"); let { basename: o } = Bg("useViewTransitionState"), c = Nl(i, { relative: a.relative }); if (!s.isTransitioning) return !1; let f = bn(s.currentLocation.pathname, o) || s.currentLocation.pathname, h = bn(s.nextLocation.pathname, o) || s.nextLocation.pathname; return fr(c.pathname, h) != null || fr(c.pathname, f) != null } new TextEncoder; function Yu({ imageUrl: i, title: a, description: s, navigate: o }) { const [c, f] = C.useState(!1), h = Mg(), g = () => { h(o) }; return y.jsxs("div", { className: `hover-card ${c ? "hovered" : ""}`, onMouseEnter: () => f(!0), onMouseLeave: () => f(!1), onClick: g, children: [y.jsx("img", { src: i, alt: "Background", className: "card-image" }), y.jsxs("div", { className: "overlay", children: [y.jsx("h3", { className: "title", style: { color: "white", fontSize: "1.5vw" }, children: a }), y.jsx("p", { className: "description", style: { fontSize: "1.3vw" }, children: s })] })] }) } function f1() { return y.jsx("div", { children: y.jsxs("div", { className: "content", children: [y.jsx("h2", { children: "Projects" }), y.jsx("p", { children: "Please explore my projects below!" }), y.jsxs("div", { style: { display: "flex", paddingRight: "2vw", paddingLeft: "2vw", paddingTop: "2vh", paddingBottom: "2vh", justifyContent: "space-evenly" }, children: [y.jsx(Yu, { imageUrl: "src/assets/design annotation.jpg", title: "Accesible Redesign", description: "Analyzing and remaking multi-select from popular websites.", navigate: "/demo" }), y.jsx(Yu, { imageUrl: "src/assets/Ari_Persona.png", title: "Personas & Storyboarding", description: "Inspecting a public interface then illustrating user needs and experiences based on empirical observations through personas and storyboarding", navigate: "/demo2" })] }), y.jsx("div", { style: { display: "flex", paddingRight: "2vw", paddingLeft: "2vw", paddingTop: "2vh", paddingBottom: "2vh", justifyContent: "space-evenly" }, children: y.jsx(Yu, { imageUrl: "src/assets/Redesign_Computer.png", title: "Responsive Redesign", description: "Identifing flaws in an existing interface, create mockups for various screen sizes, and building a responsive website based on those prototypes.", navigate: "/demo3" }) })] }) }) } function h1() { return y.jsx("div", { className: "content", children: y.jsx("p", { children: 'Click the "Projects" button to go to the projects for CS1300' }) }) } function d1() { return y.jsx(y.Fragment, {}) }/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const m1 = i => i.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), Ug = (...i) => i.filter((a, s, o) => !!a && a.trim() !== "" && o.indexOf(a) === s).join(" ").trim();/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var p1 = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const g1 = C.forwardRef(({ color: i = "currentColor", size: a = 24, strokeWidth: s = 2, absoluteStrokeWidth: o, className: c = "", children: f, iconNode: h, ...g }, d) => C.createElement("svg", { ref: d, ...p1, width: a, height: a, stroke: i, strokeWidth: o ? Number(s) * 24 / Number(a) : s, className: Ug("lucide", c), ...g }, [...h.map(([m, v]) => C.createElement(m, v)), ...Array.isArray(f) ? f : [f]]));/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const y1 = (i, a) => { const s = C.forwardRef(({ className: o, ...c }, f) => C.createElement(g1, { ref: f, iconNode: a, className: Ug(`lucide-${m1(i)}`, o), ...c })); return s.displayName = `${i}`, s };/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const v1 = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], b1 = y1("ChevronUp", v1), Ng = C.createContext({}); function x1(i) { const a = C.useRef(null); return a.current === null && (a.current = i()), a.current } const jc = C.createContext(null), Lg = C.createContext({ transformPagePoint: i => i, isStatic: !1, reducedMotion: "never" }); function S1(i = !0) { const a = C.useContext(jc); if (a === null) return [!0, null]; const { isPresent: s, onExitComplete: o, register: c } = a, f = C.useId(); C.useEffect(() => { if (i) return c(f) }, [i]); const h = C.useCallback(() => i && o && o(f), [f, o, i]); return !s && o ? [!1, h] : [!0] } const Dc = typeof window < "u", T1 = Dc ? C.useLayoutEffect : C.useEffect, yt = i => i; let kg = yt; function Mc(i) { let a; return () => (a === void 0 && (a = i()), a) } const ma = (i, a, s) => { const o = a - i; return o === 0 ? 1 : (s - i) / o }, yn = i => i * 1e3, vn = i => i / 1e3, w1 = { useManualTiming: !1 }, ir = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"], ap = { value: null }; function A1(i, a) { let s = new Set, o = new Set, c = !1, f = !1; const h = new WeakSet; let g = { delta: 0, timestamp: 0, isProcessing: !1 }, d = 0; function m(x) { h.has(x) && (v.schedule(x), i()), d++, x(g) } const v = { schedule: (x, S = !1, j = !1) => { const z = j && c ? s : o; return S && h.add(x), z.has(x) || z.add(x), x }, cancel: x => { o.delete(x), h.delete(x) }, process: x => { if (g = x, c) { f = !0; return } c = !0, [s, o] = [o, s], s.forEach(m), a && ap.value && ap.value.frameloop[a].push(d), d = 0, s.clear(), c = !1, f && (f = !1, v.process(x)) } }; return v } const E1 = 40; function Hg(i, a) { let s = !1, o = !0; const c = { delta: 0, timestamp: 0, isProcessing: !1 }, f = () => s = !0, h = ir.reduce((O, L) => (O[L] = A1(f, a ? L : void 0), O), {}), { read: g, resolveKeyframes: d, update: m, preRender: v, render: x, postRender: S } = h, j = () => { const O = performance.now(); s = !1, c.delta = o ? 1e3 / 60 : Math.max(Math.min(O - c.timestamp, E1), 1), c.timestamp = O, c.isProcessing = !0, g.process(c), d.process(c), m.process(c), v.process(c), x.process(c), S.process(c), c.isProcessing = !1, s && a && (o = !1, i(j)) }, D = () => { s = !0, o = !0, c.isProcessing || i(j) }; return { schedule: ir.reduce((O, L) => { const N = h[L]; return O[L] = (J, q = !1, ae = !1) => (s || D(), N.schedule(J, q, ae)), O }, {}), cancel: O => { for (let L = 0; L < ir.length; L++)h[ir[L]].cancel(O) }, state: c, steps: h } } const { schedule: Ae, cancel: Pn, state: Je, steps: Xu } = Hg(typeof requestAnimationFrame < "u" ? requestAnimationFrame : yt, !0), qg = C.createContext({ strict: !1 }), lp = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, pa = {}; for (const i in lp) pa[i] = { isEnabled: a => lp[i].some(s => !!a[s]) }; function j1(i) { for (const a in i) pa[a] = { ...pa[a], ...i[a] } } const D1 = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function hr(i) { return i.startsWith("while") || i.startsWith("drag") && i !== "draggable" || i.startsWith("layout") || i.startsWith("onTap") || i.startsWith("onPan") || i.startsWith("onLayout") || D1.has(i) } let Gg = i => !hr(i); function M1(i) { i && (Gg = a => a.startsWith("on") ? !hr(a) : i(a)) } try { M1(require("@emotion/is-prop-valid").default) } catch { } function R1(i, a, s) { const o = {}; for (const c in i) c === "values" && typeof i.values == "object" || (Gg(c) || s === !0 && hr(c) || !a && !hr(c) || i.draggable && c.startsWith("onDrag")) && (o[c] = i[c]); return o } function C1(i) { if (typeof Proxy > "u") return i; const a = new Map, s = (...o) => i(...o); return new Proxy(s, { get: (o, c) => c === "create" ? i : (a.has(c) || a.set(c, i(c)), a.get(c)) }) } const Sr = C.createContext({}); function Tr(i) { return i !== null && typeof i == "object" && typeof i.start == "function" } function Ml(i) { return typeof i == "string" || Array.isArray(i) } const Rc = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], Cc = ["initial", ...Rc]; function wr(i) { return Tr(i.animate) || Cc.some(a => Ml(i[a])) } function Yg(i) { return !!(wr(i) || i.variants) } function O1(i, a) { if (wr(i)) { const { initial: s, animate: o } = i; return { initial: s === !1 || Ml(s) ? s : void 0, animate: Ml(o) ? o : void 0 } } return i.inherit !== !1 ? a : {} } function V1(i) { const { initial: a, animate: s } = O1(i, C.useContext(Sr)); return C.useMemo(() => ({ initial: a, animate: s }), [sp(a), sp(s)]) } function sp(i) { return Array.isArray(i) ? i.join(" ") : i } const z1 = Symbol.for("motionComponentSymbol"); function oa(i) { return i && typeof i == "object" && Object.prototype.hasOwnProperty.call(i, "current") } function _1(i, a, s) { return C.useCallback(o => { o && i.onMount && i.onMount(o), a && (o ? a.mount(o) : a.unmount()), s && (typeof s == "function" ? s(o) : oa(s) && (s.current = o)) }, [a]) } const Oc = i => i.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), B1 = "framerAppearId", Xg = "data-" + Oc(B1), { schedule: Vc } = Hg(queueMicrotask, !1), Kg = C.createContext({}); function U1(i, a, s, o, c) { var f, h; const { visualElement: g } = C.useContext(Sr), d = C.useContext(qg), m = C.useContext(jc), v = C.useContext(Lg).reducedMotion, x = C.useRef(null); o = o || d.renderer, !x.current && o && (x.current = o(i, { visualState: a, parent: g, props: s, presenceContext: m, blockInitialAnimation: m ? m.initial === !1 : !1, reducedMotionConfig: v })); const S = x.current, j = C.useContext(Kg); S && !S.projection && c && (S.type === "html" || S.type === "svg") && N1(x.current, s, c, j); const D = C.useRef(!1); C.useInsertionEffect(() => { S && D.current && S.update(s, m) }); const z = s[Xg], _ = C.useRef(!!z && !(!((f = window.MotionHandoffIsComplete) === null || f === void 0) && f.call(window, z)) && ((h = window.MotionHasOptimisedAnimation) === null || h === void 0 ? void 0 : h.call(window, z))); return T1(() => { S && (D.current = !0, window.MotionIsMounted = !0, S.updateFeatures(), Vc.render(S.render), _.current && S.animationState && S.animationState.animateChanges()) }), C.useEffect(() => { S && (!_.current && S.animationState && S.animationState.animateChanges(), _.current && (queueMicrotask(() => { var O; (O = window.MotionHandoffMarkAsComplete) === null || O === void 0 || O.call(window, z) }), _.current = !1)) }), S } function N1(i, a, s, o) { const { layoutId: c, layout: f, drag: h, dragConstraints: g, layoutScroll: d, layoutRoot: m } = a; i.projection = new s(i.latestValues, a["data-framer-portal-id"] ? void 0 : Qg(i.parent)), i.projection.setOptions({ layoutId: c, layout: f, alwaysMeasureLayout: !!h || g && oa(g), visualElement: i, animationType: typeof f == "string" ? f : "both", initialPromotionConfig: o, layoutScroll: d, layoutRoot: m }) } function Qg(i) { if (i) return i.options.allowProjection !== !1 ? i.projection : Qg(i.parent) } function L1({ preloadedFeatures: i, createVisualElement: a, useRender: s, useVisualState: o, Component: c }) { var f, h; i && j1(i); function g(m, v) { let x; const S = { ...C.useContext(Lg), ...m, layoutId: k1(m) }, { isStatic: j } = S, D = V1(m), z = o(m, j); if (!j && Dc) { H1(); const _ = q1(S); x = _.MeasureLayout, D.visualElement = U1(c, z, S, a, _.ProjectionNode) } return y.jsxs(Sr.Provider, { value: D, children: [x && D.visualElement ? y.jsx(x, { visualElement: D.visualElement, ...S }) : null, s(c, m, _1(z, D.visualElement, v), z, j, D.visualElement)] }) } g.displayName = `motion.${typeof c == "string" ? c : `create(${(h = (f = c.displayName) !== null && f !== void 0 ? f : c.name) !== null && h !== void 0 ? h : ""})`}`; const d = C.forwardRef(g); return d[z1] = c, d } function k1({ layoutId: i }) { const a = C.useContext(Ng).id; return a && i !== void 0 ? a + "-" + i : i } function H1(i, a) { C.useContext(qg).strict } function q1(i) { const { drag: a, layout: s } = pa; if (!a && !s) return {}; const o = { ...a, ...s }; return { MeasureLayout: a != null && a.isEnabled(i) || s != null && s.isEnabled(i) ? o.MeasureLayout : void 0, ProjectionNode: o.ProjectionNode } } const Zg = i => a => typeof a == "string" && a.startsWith(i), zc = Zg("--"), G1 = Zg("var(--"), _c = i => G1(i) ? Y1.test(i.split("/*")[0].trim()) : !1, Y1 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, Rl = {}; function X1(i) { for (const a in i) Rl[a] = i[a], zc(a) && (Rl[a].isCSSVariable = !0) } const va = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], Ei = new Set(va); function Pg(i, { layout: a, layoutId: s }) { return Ei.has(i) || i.startsWith("origin") || (a || s !== void 0) && (!!Rl[i] || i === "opacity") } const tt = i => !!(i && i.getVelocity), Fg = (i, a) => a && typeof i == "number" ? a.transform(i) : i, xn = (i, a, s) => s > a ? a : s < i ? i : s, ba = { test: i => typeof i == "number", parse: parseFloat, transform: i => i }, Cl = { ...ba, transform: i => xn(0, 1, i) }, ar = { ...ba, default: 1 }, Ll = i => ({ test: a => typeof a == "string" && a.endsWith(i) && a.split(" ").length === 1, parse: parseFloat, transform: a => `${a}${i}` }), Zn = Ll("deg"), Ft = Ll("%"), ne = Ll("px"), K1 = Ll("vh"), Q1 = Ll("vw"), rp = { ...Ft, parse: i => Ft.parse(i) / 100, transform: i => Ft.transform(i * 100) }, Z1 = { borderWidth: ne, borderTopWidth: ne, borderRightWidth: ne, borderBottomWidth: ne, borderLeftWidth: ne, borderRadius: ne, radius: ne, borderTopLeftRadius: ne, borderTopRightRadius: ne, borderBottomRightRadius: ne, borderBottomLeftRadius: ne, width: ne, maxWidth: ne, height: ne, maxHeight: ne, top: ne, right: ne, bottom: ne, left: ne, padding: ne, paddingTop: ne, paddingRight: ne, paddingBottom: ne, paddingLeft: ne, margin: ne, marginTop: ne, marginRight: ne, marginBottom: ne, marginLeft: ne, backgroundPositionX: ne, backgroundPositionY: ne }, P1 = { rotate: Zn, rotateX: Zn, rotateY: Zn, rotateZ: Zn, scale: ar, scaleX: ar, scaleY: ar, scaleZ: ar, skew: Zn, skewX: Zn, skewY: Zn, distance: ne, translateX: ne, translateY: ne, translateZ: ne, x: ne, y: ne, z: ne, perspective: ne, transformPerspective: ne, opacity: Cl, originX: rp, originY: rp, originZ: ne }, op = { ...ba, transform: Math.round }, Bc = { ...Z1, ...P1, zIndex: op, size: ne, fillOpacity: Cl, strokeOpacity: Cl, numOctaves: op }, F1 = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, J1 = va.length; function $1(i, a, s) { let o = "", c = !0; for (let f = 0; f < J1; f++) { const h = va[f], g = i[h]; if (g === void 0) continue; let d = !0; if (typeof g == "number" ? d = g === (h.startsWith("scale") ? 1 : 0) : d = parseFloat(g) === 0, !d || s) { const m = Fg(g, Bc[h]); if (!d) { c = !1; const v = F1[h] || h; o += `${v}(${m}) ` } s && (a[h] = m) } } return o = o.trim(), s ? o = s(a, c ? "" : o) : c && (o = "none"), o } function Uc(i, a, s) { const { style: o, vars: c, transformOrigin: f } = i; let h = !1, g = !1; for (const d in a) { const m = a[d]; if (Ei.has(d)) { h = !0; continue } else if (zc(d)) { c[d] = m; continue } else { const v = Fg(m, Bc[d]); d.startsWith("origin") ? (g = !0, f[d] = v) : o[d] = v } } if (a.transform || (h || s ? o.transform = $1(a, i.transform, s) : o.transform && (o.transform = "none")), g) { const { originX: d = "50%", originY: m = "50%", originZ: v = 0 } = f; o.transformOrigin = `${d} ${m} ${v}` } } const Nc = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function Jg(i, a, s) { for (const o in a) !tt(a[o]) && !Pg(o, s) && (i[o] = a[o]) } function W1({ transformTemplate: i }, a) { return C.useMemo(() => { const s = Nc(); return Uc(s, a, i), Object.assign({}, s.vars, s.style) }, [a]) } function I1(i, a) { const s = i.style || {}, o = {}; return Jg(o, s, i), Object.assign(o, W1(i, a)), o } function eS(i, a) { const s = {}, o = I1(i, a); return i.drag && i.dragListener !== !1 && (s.draggable = !1, o.userSelect = o.WebkitUserSelect = o.WebkitTouchCallout = "none", o.touchAction = i.drag === !0 ? "none" : `pan-${i.drag === "x" ? "y" : "x"}`), i.tabIndex === void 0 && (i.onTap || i.onTapStart || i.whileTap) && (s.tabIndex = 0), s.style = o, s } const tS = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function Lc(i) { return typeof i != "string" || i.includes("-") ? !1 : !!(tS.indexOf(i) > -1 || /[A-Z]/u.test(i)) } const nS = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, iS = { offset: "strokeDashoffset", array: "strokeDasharray" }; function aS(i, a, s = 1, o = 0, c = !0) { i.pathLength = 1; const f = c ? nS : iS; i[f.offset] = ne.transform(-o); const h = ne.transform(a), g = ne.transform(s); i[f.array] = `${h} ${g}` } function up(i, a, s) { return typeof i == "string" ? i : ne.transform(a + s * i) } function lS(i, a, s) { const o = up(a, i.x, i.width), c = up(s, i.y, i.height); return `${o} ${c}` } function kc(i, { attrX: a, attrY: s, attrScale: o, originX: c, originY: f, pathLength: h, pathSpacing: g = 1, pathOffset: d = 0, ...m }, v, x) { if (Uc(i, m, x), v) { i.style.viewBox && (i.attrs.viewBox = i.style.viewBox); return } i.attrs = i.style, i.style = {}; const { attrs: S, style: j, dimensions: D } = i; S.transform && (D && (j.transform = S.transform), delete S.transform), D && (c !== void 0 || f !== void 0 || j.transform) && (j.transformOrigin = lS(D, c !== void 0 ? c : .5, f !== void 0 ? f : .5)), a !== void 0 && (S.x = a), s !== void 0 && (S.y = s), o !== void 0 && (S.scale = o), h !== void 0 && aS(S, h, g, d, !1) } const $g = () => ({ ...Nc(), attrs: {} }), Hc = i => typeof i == "string" && i.toLowerCase() === "svg"; function sS(i, a, s, o) { const c = C.useMemo(() => { const f = $g(); return kc(f, a, Hc(o), i.transformTemplate), { ...f.attrs, style: { ...f.style } } }, [a]); if (i.style) { const f = {}; Jg(f, i.style, i), c.style = { ...f, ...c.style } } return c } function rS(i = !1) { return (s, o, c, { latestValues: f }, h) => { const d = (Lc(s) ? sS : eS)(o, f, h, s), m = R1(o, typeof s == "string", i), v = s !== C.Fragment ? { ...m, ...d, ref: c } : {}, { children: x } = o, S = C.useMemo(() => tt(x) ? x.get() : x, [x]); return C.createElement(s, { ...v, children: S }) } } function cp(i) { const a = [{}, {}]; return i == null || i.values.forEach((s, o) => { a[0][o] = s.get(), a[1][o] = s.getVelocity() }), a } function qc(i, a, s, o) { if (typeof a == "function") { const [c, f] = cp(o); a = a(s !== void 0 ? s : i.custom, c, f) } if (typeof a == "string" && (a = i.variants && i.variants[a]), typeof a == "function") { const [c, f] = cp(o); a = a(s !== void 0 ? s : i.custom, c, f) } return a } const ac = i => Array.isArray(i), oS = i => !!(i && typeof i == "object" && i.mix && i.toValue), uS = i => ac(i) ? i[i.length - 1] || 0 : i; function or(i) { const a = tt(i) ? i.get() : i; return oS(a) ? a.toValue() : a } function cS({ scrapeMotionValuesFromProps: i, createRenderState: a, onUpdate: s }, o, c, f) { const h = { latestValues: fS(o, c, f, i), renderState: a() }; return s && (h.onMount = g => s({ props: o, current: g, ...h }), h.onUpdate = g => s(g)), h } const Wg = i => (a, s) => { const o = C.useContext(Sr), c = C.useContext(jc), f = () => cS(i, a, o, c); return s ? f() : x1(f) }; function fS(i, a, s, o) { const c = {}, f = o(i, {}); for (const S in f) c[S] = or(f[S]); let { initial: h, animate: g } = i; const d = wr(i), m = Yg(i); a && m && !d && i.inherit !== !1 && (h === void 0 && (h = a.initial), g === void 0 && (g = a.animate)); let v = s ? s.initial === !1 : !1; v = v || h === !1; const x = v ? g : h; if (x && typeof x != "boolean" && !Tr(x)) { const S = Array.isArray(x) ? x : [x]; for (let j = 0; j < S.length; j++) { const D = qc(i, S[j]); if (D) { const { transitionEnd: z, transition: _, ...O } = D; for (const L in O) { let N = O[L]; if (Array.isArray(N)) { const J = v ? N.length - 1 : 0; N = N[J] } N !== null && (c[L] = N) } for (const L in z) c[L] = z[L] } } } return c } function Gc(i, a, s) { var o; const { style: c } = i, f = {}; for (const h in c) (tt(c[h]) || a.style && tt(a.style[h]) || Pg(h, i) || ((o = s == null ? void 0 : s.getValue(h)) === null || o === void 0 ? void 0 : o.liveStyle) !== void 0) && (f[h] = c[h]); return f } const hS = { useVisualState: Wg({ scrapeMotionValuesFromProps: Gc, createRenderState: Nc }) }; function Ig(i, a) { try { a.dimensions = typeof i.getBBox == "function" ? i.getBBox() : i.getBoundingClientRect() } catch { a.dimensions = { x: 0, y: 0, width: 0, height: 0 } } } function ey(i, { style: a, vars: s }, o, c) { Object.assign(i.style, a, c && c.getProjectionStyles(o)); for (const f in s) i.style.setProperty(f, s[f]) } const ty = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function ny(i, a, s, o) { ey(i, a, void 0, o); for (const c in a.attrs) i.setAttribute(ty.has(c) ? c : Oc(c), a.attrs[c]) } function iy(i, a, s) { const o = Gc(i, a, s); for (const c in i) if (tt(i[c]) || tt(a[c])) { const f = va.indexOf(c) !== -1 ? "attr" + c.charAt(0).toUpperCase() + c.substring(1) : c; o[f] = i[c] } return o } const fp = ["x", "y", "width", "height", "cx", "cy", "r"], dS = { useVisualState: Wg({ scrapeMotionValuesFromProps: iy, createRenderState: $g, onUpdate: ({ props: i, prevProps: a, current: s, renderState: o, latestValues: c }) => { if (!s) return; let f = !!i.drag; if (!f) { for (const g in c) if (Ei.has(g)) { f = !0; break } } if (!f) return; let h = !a; if (a) for (let g = 0; g < fp.length; g++) { const d = fp[g]; i[d] !== a[d] && (h = !0) } h && Ae.read(() => { Ig(s, o), Ae.render(() => { kc(o, c, Hc(s.tagName), i.transformTemplate), ny(s, o) }) }) } }) }; function mS(i, a) { return function (o, { forwardMotionProps: c } = { forwardMotionProps: !1 }) { const h = { ...Lc(o) ? dS : hS, preloadedFeatures: i, useRender: rS(c), createVisualElement: a, Component: o }; return L1(h) } } function Ol(i, a, s) { const o = i.getProps(); return qc(o, a, s !== void 0 ? s : o.custom, i) } const pS = Mc(() => window.ScrollTimeline !== void 0); class gS { constructor(a) { this.stop = () => this.runAll("stop"), this.animations = a.filter(Boolean) } get finished() { return Promise.all(this.animations.map(a => "finished" in a ? a.finished : a)) } getAll(a) { return this.animations[0][a] } setAll(a, s) { for (let o = 0; o < this.animations.length; o++)this.animations[o][a] = s } attachTimeline(a, s) { const o = this.animations.map(c => { if (pS() && c.attachTimeline) return c.attachTimeline(a); if (typeof s == "function") return s(c) }); return () => { o.forEach((c, f) => { c && c(), this.animations[f].stop() }) } } get time() { return this.getAll("time") } set time(a) { this.setAll("time", a) } get speed() { return this.getAll("speed") } set speed(a) { this.setAll("speed", a) } get startTime() { return this.getAll("startTime") } get duration() { let a = 0; for (let s = 0; s < this.animations.length; s++)a = Math.max(a, this.animations[s].duration); return a } runAll(a) { this.animations.forEach(s => s[a]()) } flatten() { this.runAll("flatten") } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } } class yS extends gS { then(a, s) { return Promise.all(this.animations).then(a).catch(s) } } function Yc(i, a) { return i ? i[a] || i.default || i : void 0 } const lc = 2e4; function ay(i) { let a = 0; const s = 50; let o = i.next(a); for (; !o.done && a < lc;)a += s, o = i.next(a); return a >= lc ? 1 / 0 : a } function Xc(i) { return typeof i == "function" } function hp(i, a) { i.timeline = a, i.onfinish = null } const Kc = i => Array.isArray(i) && typeof i[0] == "number", vS = { linearEasing: void 0 }; function bS(i, a) { const s = Mc(i); return () => { var o; return (o = vS[a]) !== null && o !== void 0 ? o : s() } } const dr = bS(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"), ly = (i, a, s = 10) => { let o = ""; const c = Math.max(Math.round(a / s), 2); for (let f = 0; f < c; f++)o += i(ma(0, c - 1, f)) + ", "; return `linear(${o.substring(0, o.length - 2)})` }; function sy(i) { return !!(typeof i == "function" && dr() || !i || typeof i == "string" && (i in sc || dr()) || Kc(i) || Array.isArray(i) && i.every(sy)) } const Tl = ([i, a, s, o]) => `cubic-bezier(${i}, ${a}, ${s}, ${o})`, sc = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: Tl([0, .65, .55, 1]), circOut: Tl([.55, 0, 1, .45]), backIn: Tl([.31, .01, .66, -.59]), backOut: Tl([.33, 1.53, .69, .99]) }; function ry(i, a) { if (i) return typeof i == "function" && dr() ? ly(i, a) : Kc(i) ? Tl(i) : Array.isArray(i) ? i.map(s => ry(s, a) || sc.easeOut) : sc[i] } const kt = { x: !1, y: !1 }; function oy() { return kt.x || kt.y } function xS(i, a, s) { var o; if (i instanceof EventTarget) return [i]; if (typeof i == "string") { let c = document; const f = (o = void 0) !== null && o !== void 0 ? o : c.querySelectorAll(i); return f ? Array.from(f) : [] } return Array.from(i) } function uy(i, a) { const s = xS(i), o = new AbortController, c = { passive: !0, ...a, signal: o.signal }; return [s, c, () => o.abort()] } function dp(i) { return !(i.pointerType === "touch" || oy()) } function SS(i, a, s = {}) { const [o, c, f] = uy(i, s), h = g => { if (!dp(g)) return; const { target: d } = g, m = a(d, g); if (typeof m != "function" || !d) return; const v = x => { dp(x) && (m(x), d.removeEventListener("pointerleave", v)) }; d.addEventListener("pointerleave", v, c) }; return o.forEach(g => { g.addEventListener("pointerenter", h, c) }), f } function mr(i, a) { const s = `${a}PointerCapture`; if (i.target instanceof Element && s in i.target && i.pointerId !== void 0) try { i.target[s](i.pointerId) } catch { } } const cy = (i, a) => a ? i === a ? !0 : cy(i, a.parentElement) : !1, Qc = i => i.pointerType === "mouse" ? typeof i.button != "number" || i.button <= 0 : i.isPrimary !== !1, TS = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function wS(i) { return TS.has(i.tagName) || i.tabIndex !== -1 } const wl = new WeakSet; function mp(i) { return a => { a.key === "Enter" && i(a) } } function Ku(i, a) { i.dispatchEvent(new PointerEvent("pointer" + a, { isPrimary: !0, bubbles: !0 })) } const AS = (i, a) => { const s = i.currentTarget; if (!s) return; const o = mp(() => { if (wl.has(s)) return; Ku(s, "down"); const c = mp(() => { Ku(s, "up") }), f = () => Ku(s, "cancel"); s.addEventListener("keyup", c, a), s.addEventListener("blur", f, a) }); s.addEventListener("keydown", o, a), s.addEventListener("blur", () => s.removeEventListener("keydown", o), a) }; function pp(i) { return Qc(i) && !oy() } function ES(i, a, s = {}) { const [o, c, f] = uy(i, s), h = g => { const d = g.currentTarget; if (!d || !pp(g) || wl.has(d)) return; wl.add(d), mr(g, "set"); const m = a(d, g), v = (j, D) => { d.removeEventListener("pointerup", x), d.removeEventListener("pointercancel", S), mr(j, "release"), !(!pp(j) || !wl.has(d)) && (wl.delete(d), typeof m == "function" && m(j, { success: D })) }, x = j => { (j.isTrusted ? jS(j, d instanceof Element ? d.getBoundingClientRect() : { left: 0, top: 0, right: window.innerWidth, bottom: window.innerHeight }) : !1) ? v(j, !1) : v(j, !(d instanceof Element) || cy(d, j.target)) }, S = j => { v(j, !1) }; d.addEventListener("pointerup", x, c), d.addEventListener("pointercancel", S, c), d.addEventListener("lostpointercapture", S, c) }; return o.forEach(g => { g = s.useGlobalTarget ? window : g; let d = !1; g instanceof HTMLElement && (d = !0, !wS(g) && g.getAttribute("tabindex") === null && (g.tabIndex = 0)), g.addEventListener("pointerdown", h, c), d && g.addEventListener("focus", m => AS(m, c), c) }), f } function jS(i, a) { return i.clientX < a.left || i.clientX > a.right || i.clientY < a.top || i.clientY > a.bottom } function DS(i) { return i === "x" || i === "y" ? kt[i] ? null : (kt[i] = !0, () => { kt[i] = !1 }) : kt.x || kt.y ? null : (kt.x = kt.y = !0, () => { kt.x = kt.y = !1 }) } const fy = new Set(["width", "height", "top", "left", "right", "bottom", ...va]); let ur; function MS() { ur = void 0 } const Jt = { now: () => (ur === void 0 && Jt.set(Je.isProcessing || w1.useManualTiming ? Je.timestamp : performance.now()), ur), set: i => { ur = i, queueMicrotask(MS) } }; function Zc(i, a) { i.indexOf(a) === -1 && i.push(a) } function Pc(i, a) { const s = i.indexOf(a); s > -1 && i.splice(s, 1) } class Fc { constructor() { this.subscriptions = [] } add(a) { return Zc(this.subscriptions, a), () => Pc(this.subscriptions, a) } notify(a, s, o) { const c = this.subscriptions.length; if (c) if (c === 1) this.subscriptions[0](a, s, o); else for (let f = 0; f < c; f++) { const h = this.subscriptions[f]; h && h(a, s, o) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } function hy(i, a) { return a ? i * (1e3 / a) : 0 } const gp = 30, RS = i => !isNaN(parseFloat(i)); class CS { constructor(a, s = {}) { this.version = "12.4.7", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (o, c = !0) => { const f = Jt.now(); this.updatedAt !== f && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(o), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), c && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(a), this.owner = s.owner } setCurrent(a) { this.current = a, this.updatedAt = Jt.now(), this.canTrackVelocity === null && a !== void 0 && (this.canTrackVelocity = RS(this.current)) } setPrevFrameValue(a = this.current) { this.prevFrameValue = a, this.prevUpdatedAt = this.updatedAt } onChange(a) { return this.on("change", a) } on(a, s) { this.events[a] || (this.events[a] = new Fc); const o = this.events[a].add(s); return a === "change" ? () => { o(), Ae.read(() => { this.events.change.getSize() || this.stop() }) } : o } clearListeners() { for (const a in this.events) this.events[a].clear() } attach(a, s) { this.passiveEffect = a, this.stopPassiveEffect = s } set(a, s = !0) { !s || !this.passiveEffect ? this.updateAndNotify(a, s) : this.passiveEffect(a, this.updateAndNotify) } setWithVelocity(a, s, o) { this.set(s), this.prev = void 0, this.prevFrameValue = a, this.prevUpdatedAt = this.updatedAt - o } jump(a, s = !0) { this.updateAndNotify(a), this.prev = a, this.prevUpdatedAt = this.prevFrameValue = void 0, s && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const a = Jt.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || a - this.updatedAt > gp) return 0; const s = Math.min(this.updatedAt - this.prevUpdatedAt, gp); return hy(parseFloat(this.current) - parseFloat(this.prevFrameValue), s) } start(a) { return this.stop(), new Promise(s => { this.hasAnimated = !0, this.animation = a(s), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function Vl(i, a) { return new CS(i, a) } function OS(i, a, s) { i.hasValue(a) ? i.getValue(a).set(s) : i.addValue(a, Vl(s)) } function VS(i, a) { const s = Ol(i, a); let { transitionEnd: o = {}, transition: c = {}, ...f } = s || {}; f = { ...f, ...o }; for (const h in f) { const g = uS(f[h]); OS(i, h, g) } } function zS(i) { return !!(tt(i) && i.add) } function rc(i, a) { const s = i.getValue("willChange"); if (zS(s)) return s.add(a) } function dy(i) { return i.props[Xg] } const my = (i, a, s) => (((1 - 3 * s + 3 * a) * i + (3 * s - 6 * a)) * i + 3 * a) * i, _S = 1e-7, BS = 12; function US(i, a, s, o, c) { let f, h, g = 0; do h = a + (s - a) / 2, f = my(h, o, c) - i, f > 0 ? s = h : a = h; while (Math.abs(f) > _S && ++g < BS); return h } function kl(i, a, s, o) { if (i === a && s === o) return yt; const c = f => US(f, 0, 1, i, s); return f => f === 0 || f === 1 ? f : my(c(f), a, o) } const py = i => a => a <= .5 ? i(2 * a) / 2 : (2 - i(2 * (1 - a))) / 2, gy = i => a => 1 - i(1 - a), yy = kl(.33, 1.53, .69, .99), Jc = gy(yy), vy = py(Jc), by = i => (i *= 2) < 1 ? .5 * Jc(i) : .5 * (2 - Math.pow(2, -10 * (i - 1))), $c = i => 1 - Math.sin(Math.acos(i)), xy = gy($c), Sy = py($c), Ty = i => /^0[^.\s]+$/u.test(i); function NS(i) { return typeof i == "number" ? i === 0 : i !== null ? i === "none" || i === "0" || Ty(i) : !0 } const Al = i => Math.round(i * 1e5) / 1e5, Wc = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function LS(i) { return i == null } const kS = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Ic = (i, a) => s => !!(typeof s == "string" && kS.test(s) && s.startsWith(i) || a && !LS(s) && Object.prototype.hasOwnProperty.call(s, a)), wy = (i, a, s) => o => { if (typeof o != "string") return o; const [c, f, h, g] = o.match(Wc); return { [i]: parseFloat(c), [a]: parseFloat(f), [s]: parseFloat(h), alpha: g !== void 0 ? parseFloat(g) : 1 } }, HS = i => xn(0, 255, i), Qu = { ...ba, transform: i => Math.round(HS(i)) }, Ti = { test: Ic("rgb", "red"), parse: wy("red", "green", "blue"), transform: ({ red: i, green: a, blue: s, alpha: o = 1 }) => "rgba(" + Qu.transform(i) + ", " + Qu.transform(a) + ", " + Qu.transform(s) + ", " + Al(Cl.transform(o)) + ")" }; function qS(i) { let a = "", s = "", o = "", c = ""; return i.length > 5 ? (a = i.substring(1, 3), s = i.substring(3, 5), o = i.substring(5, 7), c = i.substring(7, 9)) : (a = i.substring(1, 2), s = i.substring(2, 3), o = i.substring(3, 4), c = i.substring(4, 5), a += a, s += s, o += o, c += c), { red: parseInt(a, 16), green: parseInt(s, 16), blue: parseInt(o, 16), alpha: c ? parseInt(c, 16) / 255 : 1 } } const oc = { test: Ic("#"), parse: qS, transform: Ti.transform }, ua = { test: Ic("hsl", "hue"), parse: wy("hue", "saturation", "lightness"), transform: ({ hue: i, saturation: a, lightness: s, alpha: o = 1 }) => "hsla(" + Math.round(i) + ", " + Ft.transform(Al(a)) + ", " + Ft.transform(Al(s)) + ", " + Al(Cl.transform(o)) + ")" }, et = { test: i => Ti.test(i) || oc.test(i) || ua.test(i), parse: i => Ti.test(i) ? Ti.parse(i) : ua.test(i) ? ua.parse(i) : oc.parse(i), transform: i => typeof i == "string" ? i : i.hasOwnProperty("red") ? Ti.transform(i) : ua.transform(i) }, GS = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function YS(i) { var a, s; return isNaN(i) && typeof i == "string" && (((a = i.match(Wc)) === null || a === void 0 ? void 0 : a.length) || 0) + (((s = i.match(GS)) === null || s === void 0 ? void 0 : s.length) || 0) > 0 } const Ay = "number", Ey = "color", XS = "var", KS = "var(", yp = "${}", QS = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function zl(i) { const a = i.toString(), s = [], o = { color: [], number: [], var: [] }, c = []; let f = 0; const g = a.replace(QS, d => (et.test(d) ? (o.color.push(f), c.push(Ey), s.push(et.parse(d))) : d.startsWith(KS) ? (o.var.push(f), c.push(XS), s.push(d)) : (o.number.push(f), c.push(Ay), s.push(parseFloat(d))), ++f, yp)).split(yp); return { values: s, split: g, indexes: o, types: c } } function jy(i) { return zl(i).values } function Dy(i) { const { split: a, types: s } = zl(i), o = a.length; return c => { let f = ""; for (let h = 0; h < o; h++)if (f += a[h], c[h] !== void 0) { const g = s[h]; g === Ay ? f += Al(c[h]) : g === Ey ? f += et.transform(c[h]) : f += c[h] } return f } } const ZS = i => typeof i == "number" ? 0 : i; function PS(i) { const a = jy(i); return Dy(i)(a.map(ZS)) } const Fn = { test: YS, parse: jy, createTransformer: Dy, getAnimatableNone: PS }, FS = new Set(["brightness", "contrast", "saturate", "opacity"]); function JS(i) { const [a, s] = i.slice(0, -1).split("("); if (a === "drop-shadow") return i; const [o] = s.match(Wc) || []; if (!o) return i; const c = s.replace(o, ""); let f = FS.has(a) ? 1 : 0; return o !== s && (f *= 100), a + "(" + f + c + ")" } const $S = /\b([a-z-]*)\(.*?\)/gu, uc = { ...Fn, getAnimatableNone: i => { const a = i.match($S); return a ? a.map(JS).join(" ") : i } }, WS = { ...Bc, color: et, backgroundColor: et, outlineColor: et, fill: et, stroke: et, borderColor: et, borderTopColor: et, borderRightColor: et, borderBottomColor: et, borderLeftColor: et, filter: uc, WebkitFilter: uc }, ef = i => WS[i]; function My(i, a) { let s = ef(i); return s !== uc && (s = Fn), s.getAnimatableNone ? s.getAnimatableNone(a) : void 0 } const IS = new Set(["auto", "none", "0"]); function eT(i, a, s) { let o = 0, c; for (; o < i.length && !c;) { const f = i[o]; typeof f == "string" && !IS.has(f) && zl(f).values.length && (c = i[o]), o++ } if (c && s) for (const f of a) i[f] = My(s, c) } const vp = i => i === ba || i === ne, bp = (i, a) => parseFloat(i.split(", ")[a]), xp = (i, a) => (s, { transform: o }) => { if (o === "none" || !o) return 0; const c = o.match(/^matrix3d\((.+)\)$/u); if (c) return bp(c[1], a); { const f = o.match(/^matrix\((.+)\)$/u); return f ? bp(f[1], i) : 0 } }, tT = new Set(["x", "y", "z"]), nT = va.filter(i => !tT.has(i)); function iT(i) { const a = []; return nT.forEach(s => { const o = i.getValue(s); o !== void 0 && (a.push([s, o.get()]), o.set(s.startsWith("scale") ? 1 : 0)) }), a } const ga = { width: ({ x: i }, { paddingLeft: a = "0", paddingRight: s = "0" }) => i.max - i.min - parseFloat(a) - parseFloat(s), height: ({ y: i }, { paddingTop: a = "0", paddingBottom: s = "0" }) => i.max - i.min - parseFloat(a) - parseFloat(s), top: (i, { top: a }) => parseFloat(a), left: (i, { left: a }) => parseFloat(a), bottom: ({ y: i }, { top: a }) => parseFloat(a) + (i.max - i.min), right: ({ x: i }, { left: a }) => parseFloat(a) + (i.max - i.min), x: xp(4, 13), y: xp(5, 14) }; ga.translateX = ga.x; ga.translateY = ga.y; const wi = new Set; let cc = !1, fc = !1; function Ry() { if (fc) { const i = Array.from(wi).filter(o => o.needsMeasurement), a = new Set(i.map(o => o.element)), s = new Map; a.forEach(o => { const c = iT(o); c.length && (s.set(o, c), o.render()) }), i.forEach(o => o.measureInitialState()), a.forEach(o => { o.render(); const c = s.get(o); c && c.forEach(([f, h]) => { var g; (g = o.getValue(f)) === null || g === void 0 || g.set(h) }) }), i.forEach(o => o.measureEndState()), i.forEach(o => { o.suspendedScrollY !== void 0 && window.scrollTo(0, o.suspendedScrollY) }) } fc = !1, cc = !1, wi.forEach(i => i.complete()), wi.clear() } function Cy() { wi.forEach(i => { i.readKeyframes(), i.needsMeasurement && (fc = !0) }) } function aT() { Cy(), Ry() } class tf { constructor(a, s, o, c, f, h = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...a], this.onComplete = s, this.name = o, this.motionValue = c, this.element = f, this.isAsync = h } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (wi.add(this), cc || (cc = !0, Ae.read(Cy), Ae.resolveKeyframes(Ry))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: a, name: s, element: o, motionValue: c } = this; for (let f = 0; f < a.length; f++)if (a[f] === null) if (f === 0) { const h = c == null ? void 0 : c.get(), g = a[a.length - 1]; if (h !== void 0) a[0] = h; else if (o && s) { const d = o.readValue(s, g); d != null && (a[0] = d) } a[0] === void 0 && (a[0] = g), c && h === void 0 && c.set(a[0]) } else a[f] = a[f - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), wi.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, wi.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } } const Oy = i => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(i), lT = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function sT(i) { const a = lT.exec(i); if (!a) return [,]; const [, s, o, c] = a; return [`--${s ?? o}`, c] } function Vy(i, a, s = 1) { const [o, c] = sT(i); if (!o) return; const f = window.getComputedStyle(a).getPropertyValue(o); if (f) { const h = f.trim(); return Oy(h) ? parseFloat(h) : h } return _c(c) ? Vy(c, a, s + 1) : c } const zy = i => a => a.test(i), rT = { test: i => i === "auto", parse: i => i }, _y = [ba, ne, Ft, Zn, Q1, K1, rT], Sp = i => _y.find(zy(i)); class By extends tf { constructor(a, s, o, c, f) { super(a, s, o, c, f, !0) } readKeyframes() { const { unresolvedKeyframes: a, element: s, name: o } = this; if (!s || !s.current) return; super.readKeyframes(); for (let d = 0; d < a.length; d++) { let m = a[d]; if (typeof m == "string" && (m = m.trim(), _c(m))) { const v = Vy(m, s.current); v !== void 0 && (a[d] = v), d === a.length - 1 && (this.finalKeyframe = m) } } if (this.resolveNoneKeyframes(), !fy.has(o) || a.length !== 2) return; const [c, f] = a, h = Sp(c), g = Sp(f); if (h !== g) if (vp(h) && vp(g)) for (let d = 0; d < a.length; d++) { const m = a[d]; typeof m == "string" && (a[d] = parseFloat(m)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { const { unresolvedKeyframes: a, name: s } = this, o = []; for (let c = 0; c < a.length; c++)NS(a[c]) && o.push(c); o.length && eT(a, o, s) } measureInitialState() { const { element: a, unresolvedKeyframes: s, name: o } = this; if (!a || !a.current) return; o === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = ga[o](a.measureViewportBox(), window.getComputedStyle(a.current)), s[0] = this.measuredOrigin; const c = s[s.length - 1]; c !== void 0 && a.getValue(o, c).jump(c, !1) } measureEndState() { var a; const { element: s, name: o, unresolvedKeyframes: c } = this; if (!s || !s.current) return; const f = s.getValue(o); f && f.jump(this.measuredOrigin, !1); const h = c.length - 1, g = c[h]; c[h] = ga[o](s.measureViewportBox(), window.getComputedStyle(s.current)), g !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = g), !((a = this.removedTransforms) === null || a === void 0) && a.length && this.removedTransforms.forEach(([d, m]) => { s.getValue(d).set(m) }), this.resolveNoneKeyframes() } } const Tp = (i, a) => a === "zIndex" ? !1 : !!(typeof i == "number" || Array.isArray(i) || typeof i == "string" && (Fn.test(i) || i === "0") && !i.startsWith("url(")); function oT(i) { const a = i[0]; if (i.length === 1) return !0; for (let s = 0; s < i.length; s++)if (i[s] !== a) return !0 } function uT(i, a, s, o) { const c = i[0]; if (c === null) return !1; if (a === "display" || a === "visibility") return !0; const f = i[i.length - 1], h = Tp(c, a), g = Tp(f, a); return !h || !g ? !1 : oT(i) || (s === "spring" || Xc(s)) && o } const cT = i => i !== null; function Ar(i, { repeat: a, repeatType: s = "loop" }, o) { const c = i.filter(cT), f = a && s !== "loop" && a % 2 === 1 ? 0 : c.length - 1; return !f || o === void 0 ? c[f] : o } const fT = 40; class Uy { constructor({ autoplay: a = !0, delay: s = 0, type: o = "keyframes", repeat: c = 0, repeatDelay: f = 0, repeatType: h = "loop", ...g }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Jt.now(), this.options = { autoplay: a, delay: s, type: o, repeat: c, repeatDelay: f, repeatType: h, ...g }, this.updateFinishedPromise() } calcStartTime() { return this.resolvedAt ? this.resolvedAt - this.createdAt > fT ? this.resolvedAt : this.createdAt : this.createdAt } get resolved() { return !this._resolved && !this.hasAttemptedResolve && aT(), this._resolved } onKeyframesResolved(a, s) { this.resolvedAt = Jt.now(), this.hasAttemptedResolve = !0; const { name: o, type: c, velocity: f, delay: h, onComplete: g, onUpdate: d, isGenerator: m } = this.options; if (!m && !uT(a, o, c, f)) if (h) this.options.duration = 0; else { d && d(Ar(a, this.options, s)), g && g(), this.resolveFinishedPromise(); return } const v = this.initPlayback(a, s); v !== !1 && (this._resolved = { keyframes: a, finalKeyframe: s, ...v }, this.onPostResolved()) } onPostResolved() { } then(a, s) { return this.currentFinishedPromise.then(a, s) } flatten() { this.options.type = "keyframes", this.options.ease = "linear" } updateFinishedPromise() { this.currentFinishedPromise = new Promise(a => { this.resolveFinishedPromise = a }) } } const Me = (i, a, s) => i + (a - i) * s; function Zu(i, a, s) { return s < 0 && (s += 1), s > 1 && (s -= 1), s < 1 / 6 ? i + (a - i) * 6 * s : s < 1 / 2 ? a : s < 2 / 3 ? i + (a - i) * (2 / 3 - s) * 6 : i } function hT({ hue: i, saturation: a, lightness: s, alpha: o }) { i /= 360, a /= 100, s /= 100; let c = 0, f = 0, h = 0; if (!a) c = f = h = s; else { const g = s < .5 ? s * (1 + a) : s + a - s * a, d = 2 * s - g; c = Zu(d, g, i + 1 / 3), f = Zu(d, g, i), h = Zu(d, g, i - 1 / 3) } return { red: Math.round(c * 255), green: Math.round(f * 255), blue: Math.round(h * 255), alpha: o } } function pr(i, a) { return s => s > 0 ? a : i } const Pu = (i, a, s) => { const o = i * i, c = s * (a * a - o) + o; return c < 0 ? 0 : Math.sqrt(c) }, dT = [oc, Ti, ua], mT = i => dT.find(a => a.test(i)); function wp(i) { const a = mT(i); if (!a) return !1; let s = a.parse(i); return a === ua && (s = hT(s)), s } const Ap = (i, a) => { const s = wp(i), o = wp(a); if (!s || !o) return pr(i, a); const c = { ...s }; return f => (c.red = Pu(s.red, o.red, f), c.green = Pu(s.green, o.green, f), c.blue = Pu(s.blue, o.blue, f), c.alpha = Me(s.alpha, o.alpha, f), Ti.transform(c)) }, pT = (i, a) => s => a(i(s)), Hl = (...i) => i.reduce(pT), hc = new Set(["none", "hidden"]); function gT(i, a) { return hc.has(i) ? s => s <= 0 ? i : a : s => s >= 1 ? a : i } function yT(i, a) { return s => Me(i, a, s) } function nf(i) { return typeof i == "number" ? yT : typeof i == "string" ? _c(i) ? pr : et.test(i) ? Ap : xT : Array.isArray(i) ? Ny : typeof i == "object" ? et.test(i) ? Ap : vT : pr } function Ny(i, a) { const s = [...i], o = s.length, c = i.map((f, h) => nf(f)(f, a[h])); return f => { for (let h = 0; h < o; h++)s[h] = c[h](f); return s } } function vT(i, a) { const s = { ...i, ...a }, o = {}; for (const c in s) i[c] !== void 0 && a[c] !== void 0 && (o[c] = nf(i[c])(i[c], a[c])); return c => { for (const f in o) s[f] = o[f](c); return s } } function bT(i, a) { var s; const o = [], c = { color: 0, var: 0, number: 0 }; for (let f = 0; f < a.values.length; f++) { const h = a.types[f], g = i.indexes[h][c[h]], d = (s = i.values[g]) !== null && s !== void 0 ? s : 0; o[f] = d, c[h]++ } return o } const xT = (i, a) => { const s = Fn.createTransformer(a), o = zl(i), c = zl(a); return o.indexes.var.length === c.indexes.var.length && o.indexes.color.length === c.indexes.color.length && o.indexes.number.length >= c.indexes.number.length ? hc.has(i) && !c.values.length || hc.has(a) && !o.values.length ? gT(i, a) : Hl(Ny(bT(o, c), c.values), s) : pr(i, a) }; function Ly(i, a, s) { return typeof i == "number" && typeof a == "number" && typeof s == "number" ? Me(i, a, s) : nf(i)(i, a) } const ST = 5; function ky(i, a, s) { const o = Math.max(a - ST, 0); return hy(s - i(o), a - o) } const _e = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, Ep = .001; function TT({ duration: i = _e.duration, bounce: a = _e.bounce, velocity: s = _e.velocity, mass: o = _e.mass }) { let c, f, h = 1 - a; h = xn(_e.minDamping, _e.maxDamping, h), i = xn(_e.minDuration, _e.maxDuration, vn(i)), h < 1 ? (c = m => { const v = m * h, x = v * i, S = v - s, j = dc(m, h), D = Math.exp(-x); return Ep - S / j * D }, f = m => { const x = m * h * i, S = x * s + s, j = Math.pow(h, 2) * Math.pow(m, 2) * i, D = Math.exp(-x), z = dc(Math.pow(m, 2), h); return (-c(m) + Ep > 0 ? -1 : 1) * ((S - j) * D) / z }) : (c = m => { const v = Math.exp(-m * i), x = (m - s) * i + 1; return -.001 + v * x }, f = m => { const v = Math.exp(-m * i), x = (s - m) * (i * i); return v * x }); const g = 5 / i, d = AT(c, f, g); if (i = yn(i), isNaN(d)) return { stiffness: _e.stiffness, damping: _e.damping, duration: i }; { const m = Math.pow(d, 2) * o; return { stiffness: m, damping: h * 2 * Math.sqrt(o * m), duration: i } } } const wT = 12; function AT(i, a, s) { let o = s; for (let c = 1; c < wT; c++)o = o - i(o) / a(o); return o } function dc(i, a) { return i * Math.sqrt(1 - a * a) } const ET = ["duration", "bounce"], jT = ["stiffness", "damping", "mass"]; function jp(i, a) { return a.some(s => i[s] !== void 0) } function DT(i) { let a = { velocity: _e.velocity, stiffness: _e.stiffness, damping: _e.damping, mass: _e.mass, isResolvedFromDuration: !1, ...i }; if (!jp(i, jT) && jp(i, ET)) if (i.visualDuration) { const s = i.visualDuration, o = 2 * Math.PI / (s * 1.2), c = o * o, f = 2 * xn(.05, 1, 1 - (i.bounce || 0)) * Math.sqrt(c); a = { ...a, mass: _e.mass, stiffness: c, damping: f } } else { const s = TT(i); a = { ...a, ...s, mass: _e.mass }, a.isResolvedFromDuration = !0 } return a } function Hy(i = _e.visualDuration, a = _e.bounce) { const s = typeof i != "object" ? { visualDuration: i, keyframes: [0, 1], bounce: a } : i; let { restSpeed: o, restDelta: c } = s; const f = s.keyframes[0], h = s.keyframes[s.keyframes.length - 1], g = { done: !1, value: f }, { stiffness: d, damping: m, mass: v, duration: x, velocity: S, isResolvedFromDuration: j } = DT({ ...s, velocity: -vn(s.velocity || 0) }), D = S || 0, z = m / (2 * Math.sqrt(d * v)), _ = h - f, O = vn(Math.sqrt(d / v)), L = Math.abs(_) < 5; o || (o = L ? _e.restSpeed.granular : _e.restSpeed.default), c || (c = L ? _e.restDelta.granular : _e.restDelta.default); let N; if (z < 1) { const q = dc(O, z); N = ae => { const fe = Math.exp(-z * O * ae); return h - fe * ((D + z * O * _) / q * Math.sin(q * ae) + _ * Math.cos(q * ae)) } } else if (z === 1) N = q => h - Math.exp(-O * q) * (_ + (D + O * _) * q); else { const q = O * Math.sqrt(z * z - 1); N = ae => { const fe = Math.exp(-z * O * ae), W = Math.min(q * ae, 300); return h - fe * ((D + z * O * _) * Math.sinh(W) + q * _ * Math.cosh(W)) / q } } const J = { calculatedDuration: j && x || null, next: q => { const ae = N(q); if (j) g.done = q >= x; else { let fe = 0; z < 1 && (fe = q === 0 ? yn(D) : ky(N, q, ae)); const W = Math.abs(fe) <= o, Y = Math.abs(h - ae) <= c; g.done = W && Y } return g.value = g.done ? h : ae, g }, toString: () => { const q = Math.min(ay(J), lc), ae = ly(fe => J.next(q * fe).value, q, 30); return q + "ms " + ae } }; return J } function Dp({ keyframes: i, velocity: a = 0, power: s = .8, timeConstant: o = 325, bounceDamping: c = 10, bounceStiffness: f = 500, modifyTarget: h, min: g, max: d, restDelta: m = .5, restSpeed: v }) { const x = i[0], S = { done: !1, value: x }, j = W => g !== void 0 && W < g || d !== void 0 && W > d, D = W => g === void 0 ? d : d === void 0 || Math.abs(g - W) < Math.abs(d - W) ? g : d; let z = s * a; const _ = x + z, O = h === void 0 ? _ : h(_); O !== _ && (z = O - x); const L = W => -z * Math.exp(-W / o), N = W => O + L(W), J = W => { const Y = L(W), I = N(W); S.done = Math.abs(Y) <= m, S.value = S.done ? O : I }; let q, ae; const fe = W => { j(S.value) && (q = W, ae = Hy({ keyframes: [S.value, D(S.value)], velocity: ky(N, W, S.value), damping: c, stiffness: f, restDelta: m, restSpeed: v })) }; return fe(0), { calculatedDuration: null, next: W => { let Y = !1; return !ae && q === void 0 && (Y = !0, J(W), fe(W)), q !== void 0 && W >= q ? ae.next(W - q) : (!Y && J(W), S) } } } const MT = kl(.42, 0, 1, 1), RT = kl(0, 0, .58, 1), qy = kl(.42, 0, .58, 1), CT = i => Array.isArray(i) && typeof i[0] != "number", OT = { linear: yt, easeIn: MT, easeInOut: qy, easeOut: RT, circIn: $c, circInOut: Sy, circOut: xy, backIn: Jc, backInOut: vy, backOut: yy, anticipate: by }, Mp = i => { if (Kc(i)) { kg(i.length === 4); const [a, s, o, c] = i; return kl(a, s, o, c) } else if (typeof i == "string") return OT[i]; return i }; function VT(i, a, s) { const o = [], c = s || Ly, f = i.length - 1; for (let h = 0; h < f; h++) { let g = c(i[h], i[h + 1]); if (a) { const d = Array.isArray(a) ? a[h] || yt : a; g = Hl(d, g) } o.push(g) } return o } function zT(i, a, { clamp: s = !0, ease: o, mixer: c } = {}) { const f = i.length; if (kg(f === a.length), f === 1) return () => a[0]; if (f === 2 && a[0] === a[1]) return () => a[1]; const h = i[0] === i[1]; i[0] > i[f - 1] && (i = [...i].reverse(), a = [...a].reverse()); const g = VT(a, o, c), d = g.length, m = v => { if (h && v < i[0]) return a[0]; let x = 0; if (d > 1) for (; x < i.length - 2 && !(v < i[x + 1]); x++); const S = ma(i[x], i[x + 1], v); return g[x](S) }; return s ? v => m(xn(i[0], i[f - 1], v)) : m } function _T(i, a) { const s = i[i.length - 1]; for (let o = 1; o <= a; o++) { const c = ma(0, a, o); i.push(Me(s, 1, c)) } } function BT(i) { const a = [0]; return _T(a, i.length - 1), a } function UT(i, a) { return i.map(s => s * a) } function NT(i, a) { return i.map(() => a || qy).splice(0, i.length - 1) } function gr({ duration: i = 300, keyframes: a, times: s, ease: o = "easeInOut" }) { const c = CT(o) ? o.map(Mp) : Mp(o), f = { done: !1, value: a[0] }, h = UT(s && s.length === a.length ? s : BT(a), i), g = zT(h, a, { ease: Array.isArray(c) ? c : NT(a, c) }); return { calculatedDuration: i, next: d => (f.value = g(d), f.done = d >= i, f) } } const LT = i => { const a = ({ timestamp: s }) => i(s); return { start: () => Ae.update(a, !0), stop: () => Pn(a), now: () => Je.isProcessing ? Je.timestamp : Jt.now() } }, kT = { decay: Dp, inertia: Dp, tween: gr, keyframes: gr, spring: Hy }, HT = i => i / 100; class af extends Uy { constructor(a) { super(a), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.teardown(); const { onStop: d } = this.options; d && d() }; const { name: s, motionValue: o, element: c, keyframes: f } = this.options, h = (c == null ? void 0 : c.KeyframeResolver) || tf, g = (d, m) => this.onKeyframesResolved(d, m); this.resolver = new h(f, g, s, o, c), this.resolver.scheduleResolve() } flatten() { super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes)) } initPlayback(a) { const { type: s = "keyframes", repeat: o = 0, repeatDelay: c = 0, repeatType: f, velocity: h = 0 } = this.options, g = Xc(s) ? s : kT[s] || gr; let d, m; g !== gr && typeof a[0] != "number" && (d = Hl(HT, Ly(a[0], a[1])), a = [0, 100]); const v = g({ ...this.options, keyframes: a }); f === "mirror" && (m = g({ ...this.options, keyframes: [...a].reverse(), velocity: -h })), v.calculatedDuration === null && (v.calculatedDuration = ay(v)); const { calculatedDuration: x } = v, S = x + c, j = S * (o + 1) - c; return { generator: v, mirroredGenerator: m, mapPercentToKeyframes: d, calculatedDuration: x, resolvedDuration: S, totalDuration: j } } onPostResolved() { const { autoplay: a = !0 } = this.options; this.play(), this.pendingPlayState === "paused" || !a ? this.pause() : this.state = this.pendingPlayState } tick(a, s = !1) { const { resolved: o } = this; if (!o) { const { keyframes: W } = this.options; return { done: !0, value: W[W.length - 1] } } const { finalKeyframe: c, generator: f, mirroredGenerator: h, mapPercentToKeyframes: g, keyframes: d, calculatedDuration: m, totalDuration: v, resolvedDuration: x } = o; if (this.startTime === null) return f.next(0); const { delay: S, repeat: j, repeatType: D, repeatDelay: z, onUpdate: _ } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, a) : this.speed < 0 && (this.startTime = Math.min(a - v / this.speed, this.startTime)), s ? this.currentTime = a : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(a - this.startTime) * this.speed; const O = this.currentTime - S * (this.speed >= 0 ? 1 : -1), L = this.speed >= 0 ? O < 0 : O > v; this.currentTime = Math.max(O, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = v); let N = this.currentTime, J = f; if (j) { const W = Math.min(this.currentTime, v) / x; let Y = Math.floor(W), I = W % 1; !I && W >= 1 && (I = 1), I === 1 && Y--, Y = Math.min(Y, j + 1), !!(Y % 2) && (D === "reverse" ? (I = 1 - I, z && (I -= z / x)) : D === "mirror" && (J = h)), N = xn(0, 1, I) * x } const q = L ? { done: !1, value: d[0] } : J.next(N); g && (q.value = g(q.value)); let { done: ae } = q; !L && m !== null && (ae = this.speed >= 0 ? this.currentTime >= v : this.currentTime <= 0); const fe = this.holdTime === null && (this.state === "finished" || this.state === "running" && ae); return fe && c !== void 0 && (q.value = Ar(d, this.options, c)), _ && _(q.value), fe && this.finish(), q } get duration() { const { resolved: a } = this; return a ? vn(a.calculatedDuration) : 0 } get time() { return vn(this.currentTime) } set time(a) { a = yn(a), this.currentTime = a, this.holdTime !== null || this.speed === 0 ? this.holdTime = a : this.driver && (this.startTime = this.driver.now() - a / this.speed) } get speed() { return this.playbackSpeed } set speed(a) { const s = this.playbackSpeed !== a; this.playbackSpeed = a, s && (this.time = vn(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; const { driver: a = LT, onPlay: s, startTime: o } = this.options; this.driver || (this.driver = a(f => this.tick(f))), s && s(); const c = this.driver.now(); this.holdTime !== null ? this.startTime = c - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = c) : this.startTime = o ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var a; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (a = this.currentTime) !== null && a !== void 0 ? a : 0 } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; const { onComplete: a } = this.options; a && a() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(a) { return this.startTime = 0, this.tick(a, !0) } } const qT = new Set(["opacity", "clipPath", "filter", "transform"]); function GT(i, a, s, { delay: o = 0, duration: c = 300, repeat: f = 0, repeatType: h = "loop", ease: g = "easeInOut", times: d } = {}) { const m = { [a]: s }; d && (m.offset = d); const v = ry(g, c); return Array.isArray(v) && (m.easing = v), i.animate(m, { delay: o, duration: c, easing: Array.isArray(v) ? "linear" : v, fill: "both", iterations: f + 1, direction: h === "reverse" ? "alternate" : "normal" }) } const YT = Mc(() => Object.hasOwnProperty.call(Element.prototype, "animate")), yr = 10, XT = 2e4; function KT(i) { return Xc(i.type) || i.type === "spring" || !sy(i.ease) } function QT(i, a) { const s = new af({ ...a, keyframes: i, repeat: 0, delay: 0, isGenerator: !0 }); let o = { done: !1, value: i[0] }; const c = []; let f = 0; for (; !o.done && f < XT;)o = s.sample(f), c.push(o.value), f += yr; return { times: void 0, keyframes: c, duration: f - yr, ease: "linear" } } const Gy = { anticipate: by, backInOut: vy, circInOut: Sy }; function ZT(i) { return i in Gy } class Rp extends Uy { constructor(a) { super(a); const { name: s, motionValue: o, element: c, keyframes: f } = this.options; this.resolver = new By(f, (h, g) => this.onKeyframesResolved(h, g), s, o, c), this.resolver.scheduleResolve() } initPlayback(a, s) { let { duration: o = 300, times: c, ease: f, type: h, motionValue: g, name: d, startTime: m } = this.options; if (!g.owner || !g.owner.current) return !1; if (typeof f == "string" && dr() && ZT(f) && (f = Gy[f]), KT(this.options)) { const { onComplete: x, onUpdate: S, motionValue: j, element: D, ...z } = this.options, _ = QT(a, z); a = _.keyframes, a.length === 1 && (a[1] = a[0]), o = _.duration, c = _.times, f = _.ease, h = "keyframes" } const v = GT(g.owner.current, d, a, { ...this.options, duration: o, times: c, ease: f }); return v.startTime = m ?? this.calcStartTime(), this.pendingTimeline ? (hp(v, this.pendingTimeline), this.pendingTimeline = void 0) : v.onfinish = () => { const { onComplete: x } = this.options; g.set(Ar(a, this.options, s)), x && x(), this.cancel(), this.resolveFinishedPromise() }, { animation: v, duration: o, times: c, type: h, ease: f, keyframes: a } } get duration() { const { resolved: a } = this; if (!a) return 0; const { duration: s } = a; return vn(s) } get time() { const { resolved: a } = this; if (!a) return 0; const { animation: s } = a; return vn(s.currentTime || 0) } set time(a) { const { resolved: s } = this; if (!s) return; const { animation: o } = s; o.currentTime = yn(a) } get speed() { const { resolved: a } = this; if (!a) return 1; const { animation: s } = a; return s.playbackRate } set speed(a) { const { resolved: s } = this; if (!s) return; const { animation: o } = s; o.playbackRate = a } get state() { const { resolved: a } = this; if (!a) return "idle"; const { animation: s } = a; return s.playState } get startTime() { const { resolved: a } = this; if (!a) return null; const { animation: s } = a; return s.startTime } attachTimeline(a) { if (!this._resolved) this.pendingTimeline = a; else { const { resolved: s } = this; if (!s) return yt; const { animation: o } = s; hp(o, a) } return yt } play() { if (this.isStopped) return; const { resolved: a } = this; if (!a) return; const { animation: s } = a; s.playState === "finished" && this.updateFinishedPromise(), s.play() } pause() { const { resolved: a } = this; if (!a) return; const { animation: s } = a; s.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.resolveFinishedPromise(), this.updateFinishedPromise(); const { resolved: a } = this; if (!a) return; const { animation: s, keyframes: o, duration: c, type: f, ease: h, times: g } = a; if (s.playState === "idle" || s.playState === "finished") return; if (this.time) { const { motionValue: m, onUpdate: v, onComplete: x, element: S, ...j } = this.options, D = new af({ ...j, keyframes: o, duration: c, type: f, ease: h, times: g, isGenerator: !0 }), z = yn(this.time); m.setWithVelocity(D.sample(z - yr).value, D.sample(z).value, yr) } const { onStop: d } = this.options; d && d(), this.cancel() } complete() { const { resolved: a } = this; a && a.animation.finish() } cancel() { const { resolved: a } = this; a && a.animation.cancel() } static supports(a) { const { motionValue: s, name: o, repeatDelay: c, repeatType: f, damping: h, type: g } = a; if (!s || !s.owner || !(s.owner.current instanceof HTMLElement)) return !1; const { onUpdate: d, transformTemplate: m } = s.owner.getProps(); return YT() && o && qT.has(o) && !d && !m && !c && f !== "mirror" && h !== 0 && g !== "inertia" } } const PT = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, FT = i => ({ type: "spring", stiffness: 550, damping: i === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), JT = { type: "keyframes", duration: .8 }, $T = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, WT = (i, { keyframes: a }) => a.length > 2 ? JT : Ei.has(i) ? i.startsWith("scale") ? FT(a[1]) : PT : $T; function IT({ when: i, delay: a, delayChildren: s, staggerChildren: o, staggerDirection: c, repeat: f, repeatType: h, repeatDelay: g, from: d, elapsed: m, ...v }) { return !!Object.keys(v).length } const lf = (i, a, s, o = {}, c, f) => h => { const g = Yc(o, i) || {}, d = g.delay || o.delay || 0; let { elapsed: m = 0 } = o; m = m - yn(d); let v = { keyframes: Array.isArray(s) ? s : [null, s], ease: "easeOut", velocity: a.getVelocity(), ...g, delay: -m, onUpdate: S => { a.set(S), g.onUpdate && g.onUpdate(S) }, onComplete: () => { h(), g.onComplete && g.onComplete() }, name: i, motionValue: a, element: f ? void 0 : c }; IT(g) || (v = { ...v, ...WT(i, v) }), v.duration && (v.duration = yn(v.duration)), v.repeatDelay && (v.repeatDelay = yn(v.repeatDelay)), v.from !== void 0 && (v.keyframes[0] = v.from); let x = !1; if ((v.type === !1 || v.duration === 0 && !v.repeatDelay) && (v.duration = 0, v.delay === 0 && (x = !0)), x && !f && a.get() !== void 0) { const S = Ar(v.keyframes, g); if (S !== void 0) return Ae.update(() => { v.onUpdate(S), v.onComplete() }), new yS([]) } return !f && Rp.supports(v) ? new Rp(v) : new af(v) }; function ew({ protectedKeys: i, needsAnimating: a }, s) { const o = i.hasOwnProperty(s) && a[s] !== !0; return a[s] = !1, o } function Yy(i, a, { delay: s = 0, transitionOverride: o, type: c } = {}) { var f; let { transition: h = i.getDefaultTransition(), transitionEnd: g, ...d } = a; o && (h = o); const m = [], v = c && i.animationState && i.animationState.getState()[c]; for (const x in d) { const S = i.getValue(x, (f = i.latestValues[x]) !== null && f !== void 0 ? f : null), j = d[x]; if (j === void 0 || v && ew(v, x)) continue; const D = { delay: s, ...Yc(h || {}, x) }; let z = !1; if (window.MotionHandoffAnimation) { const O = dy(i); if (O) { const L = window.MotionHandoffAnimation(O, x, Ae); L !== null && (D.startTime = L, z = !0) } } rc(i, x), S.start(lf(x, S, j, i.shouldReduceMotion && fy.has(x) ? { type: !1 } : D, i, z)); const _ = S.animation; _ && m.push(_) } return g && Promise.all(m).then(() => { Ae.update(() => { g && VS(i, g) }) }), m } function mc(i, a, s = {}) { var o; const c = Ol(i, a, s.type === "exit" ? (o = i.presenceContext) === null || o === void 0 ? void 0 : o.custom : void 0); let { transition: f = i.getDefaultTransition() || {} } = c || {}; s.transitionOverride && (f = s.transitionOverride); const h = c ? () => Promise.all(Yy(i, c, s)) : () => Promise.resolve(), g = i.variantChildren && i.variantChildren.size ? (m = 0) => { const { delayChildren: v = 0, staggerChildren: x, staggerDirection: S } = f; return tw(i, a, v + m, x, S, s) } : () => Promise.resolve(), { when: d } = f; if (d) { const [m, v] = d === "beforeChildren" ? [h, g] : [g, h]; return m().then(() => v()) } else return Promise.all([h(), g(s.delay)]) } function tw(i, a, s = 0, o = 0, c = 1, f) { const h = [], g = (i.variantChildren.size - 1) * o, d = c === 1 ? (m = 0) => m * o : (m = 0) => g - m * o; return Array.from(i.variantChildren).sort(nw).forEach((m, v) => { m.notify("AnimationStart", a), h.push(mc(m, a, { ...f, delay: s + d(v) }).then(() => m.notify("AnimationComplete", a))) }), Promise.all(h) } function nw(i, a) { return i.sortNodePosition(a) } function iw(i, a, s = {}) { i.notify("AnimationStart", a); let o; if (Array.isArray(a)) { const c = a.map(f => mc(i, f, s)); o = Promise.all(c) } else if (typeof a == "string") o = mc(i, a, s); else { const c = typeof a == "function" ? Ol(i, a, s.custom) : a; o = Promise.all(Yy(i, c, s)) } return o.then(() => { i.notify("AnimationComplete", a) }) } function Xy(i, a) { if (!Array.isArray(a)) return !1; const s = a.length; if (s !== i.length) return !1; for (let o = 0; o < s; o++)if (a[o] !== i[o]) return !1; return !0 } const aw = Cc.length; function Ky(i) { if (!i) return; if (!i.isControllingVariants) { const s = i.parent ? Ky(i.parent) || {} : {}; return i.props.initial !== void 0 && (s.initial = i.props.initial), s } const a = {}; for (let s = 0; s < aw; s++) { const o = Cc[s], c = i.props[o]; (Ml(c) || c === !1) && (a[o] = c) } return a } const lw = [...Rc].reverse(), sw = Rc.length; function rw(i) { return a => Promise.all(a.map(({ animation: s, options: o }) => iw(i, s, o))) } function ow(i) { let a = rw(i), s = Cp(), o = !0; const c = d => (m, v) => { var x; const S = Ol(i, v, d === "exit" ? (x = i.presenceContext) === null || x === void 0 ? void 0 : x.custom : void 0); if (S) { const { transition: j, transitionEnd: D, ...z } = S; m = { ...m, ...z, ...D } } return m }; function f(d) { a = d(i) } function h(d) { const { props: m } = i, v = Ky(i.parent) || {}, x = [], S = new Set; let j = {}, D = 1 / 0; for (let _ = 0; _ < sw; _++) { const O = lw[_], L = s[O], N = m[O] !== void 0 ? m[O] : v[O], J = Ml(N), q = O === d ? L.isActive : null; q === !1 && (D = _); let ae = N === v[O] && N !== m[O] && J; if (ae && o && i.manuallyAnimateOnMount && (ae = !1), L.protectedKeys = { ...j }, !L.isActive && q === null || !N && !L.prevProp || Tr(N) || typeof N == "boolean") continue; const fe = uw(L.prevProp, N); let W = fe || O === d && L.isActive && !ae && J || _ > D && J, Y = !1; const I = Array.isArray(N) ? N : [N]; let Ce = I.reduce(c(O), {}); q === !1 && (Ce = {}); const { prevResolvedValues: vt = {} } = L, bt = { ...vt, ...Ce }, xt = P => { W = !0, S.has(P) && (Y = !0, S.delete(P)), L.needsAnimating[P] = !0; const F = i.getValue(P); F && (F.liveStyle = !1) }; for (const P in bt) { const F = Ce[P], ye = vt[P]; if (j.hasOwnProperty(P)) continue; let w = !1; ac(F) && ac(ye) ? w = !Xy(F, ye) : w = F !== ye, w ? F != null ? xt(P) : S.add(P) : F !== void 0 && S.has(P) ? xt(P) : L.protectedKeys[P] = !0 } L.prevProp = N, L.prevResolvedValues = Ce, L.isActive && (j = { ...j, ...Ce }), o && i.blockInitialAnimation && (W = !1), W && (!(ae && fe) || Y) && x.push(...I.map(P => ({ animation: P, options: { type: O } }))) } if (S.size) { const _ = {}; if (typeof m.initial != "boolean") { const O = Ol(i, Array.isArray(m.initial) ? m.initial[0] : m.initial); O && O.transition && (_.transition = O.transition) } S.forEach(O => { const L = i.getBaseTarget(O), N = i.getValue(O); N && (N.liveStyle = !0), _[O] = L ?? null }), x.push({ animation: _ }) } let z = !!x.length; return o && (m.initial === !1 || m.initial === m.animate) && !i.manuallyAnimateOnMount && (z = !1), o = !1, z ? a(x) : Promise.resolve() } function g(d, m) { var v; if (s[d].isActive === m) return Promise.resolve(); (v = i.variantChildren) === null || v === void 0 || v.forEach(S => { var j; return (j = S.animationState) === null || j === void 0 ? void 0 : j.setActive(d, m) }), s[d].isActive = m; const x = h(d); for (const S in s) s[S].protectedKeys = {}; return x } return { animateChanges: h, setActive: g, setAnimateFunction: f, getState: () => s, reset: () => { s = Cp(), o = !0 } } } function uw(i, a) { return typeof a == "string" ? a !== i : Array.isArray(a) ? !Xy(a, i) : !1 } function xi(i = !1) { return { isActive: i, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function Cp() { return { animate: xi(!0), whileInView: xi(), whileHover: xi(), whileTap: xi(), whileDrag: xi(), whileFocus: xi(), exit: xi() } } class $n { constructor(a) { this.isMounted = !1, this.node = a } update() { } } class cw extends $n { constructor(a) { super(a), a.animationState || (a.animationState = ow(a)) } updateAnimationControlsSubscription() { const { animate: a } = this.node.getProps(); Tr(a) && (this.unmountControls = a.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: a } = this.node.getProps(), { animate: s } = this.node.prevProps || {}; a !== s && this.updateAnimationControlsSubscription() } unmount() { var a; this.node.animationState.reset(), (a = this.unmountControls) === null || a === void 0 || a.call(this) } } let fw = 0; class hw extends $n { constructor() { super(...arguments), this.id = fw++ } update() { if (!this.node.presenceContext) return; const { isPresent: a, onExitComplete: s } = this.node.presenceContext, { isPresent: o } = this.node.prevPresenceContext || {}; if (!this.node.animationState || a === o) return; const c = this.node.animationState.setActive("exit", !a); s && !a && c.then(() => { s(this.id) }) } mount() { const { register: a, onExitComplete: s } = this.node.presenceContext || {}; s && s(this.id), a && (this.unmount = a(this.id)) } unmount() { } } const dw = { animation: { Feature: cw }, exit: { Feature: hw } }; function _l(i, a, s, o = { passive: !0 }) { return i.addEventListener(a, s, o), () => i.removeEventListener(a, s) } function ql(i) { return { point: { x: i.pageX, y: i.pageY } } } const mw = i => a => Qc(a) && i(a, ql(a)); function ca(i, a, s, o) { return _l(i, a, mw(s), o) } function Qy({ top: i, left: a, right: s, bottom: o }) { return { x: { min: a, max: s }, y: { min: i, max: o } } } function pw({ x: i, y: a }) { return { top: a.min, right: i.max, bottom: a.max, left: i.min } } function gw(i, a) { if (!a) return i; const s = a({ x: i.left, y: i.top }), o = a({ x: i.right, y: i.bottom }); return { top: s.y, left: s.x, bottom: o.y, right: o.x } } const Zy = 1e-4, yw = 1 - Zy, vw = 1 + Zy, Py = .01, bw = 0 - Py, xw = 0 + Py; function st(i) { return i.max - i.min } function Sw(i, a, s) { return Math.abs(i - a) <= s } function Op(i, a, s, o = .5) { i.origin = o, i.originPoint = Me(a.min, a.max, i.origin), i.scale = st(s) / st(a), i.translate = Me(s.min, s.max, i.origin) - i.originPoint, (i.scale >= yw && i.scale <= vw || isNaN(i.scale)) && (i.scale = 1), (i.translate >= bw && i.translate <= xw || isNaN(i.translate)) && (i.translate = 0) } function El(i, a, s, o) { Op(i.x, a.x, s.x, o ? o.originX : void 0), Op(i.y, a.y, s.y, o ? o.originY : void 0) } function Vp(i, a, s) { i.min = s.min + a.min, i.max = i.min + st(a) } function Tw(i, a, s) { Vp(i.x, a.x, s.x), Vp(i.y, a.y, s.y) } function zp(i, a, s) { i.min = a.min - s.min, i.max = i.min + st(a) } function jl(i, a, s) { zp(i.x, a.x, s.x), zp(i.y, a.y, s.y) } const _p = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), fa = () => ({ x: _p(), y: _p() }), Bp = () => ({ min: 0, max: 0 }), Ue = () => ({ x: Bp(), y: Bp() }); function _t(i) { return [i("x"), i("y")] } function Fu(i) { return i === void 0 || i === 1 } function pc({ scale: i, scaleX: a, scaleY: s }) { return !Fu(i) || !Fu(a) || !Fu(s) } function Si(i) { return pc(i) || Fy(i) || i.z || i.rotate || i.rotateX || i.rotateY || i.skewX || i.skewY } function Fy(i) { return Up(i.x) || Up(i.y) } function Up(i) { return i && i !== "0%" } function vr(i, a, s) { const o = i - s, c = a * o; return s + c } function Np(i, a, s, o, c) { return c !== void 0 && (i = vr(i, c, o)), vr(i, s, o) + a } function gc(i, a = 0, s = 1, o, c) { i.min = Np(i.min, a, s, o, c), i.max = Np(i.max, a, s, o, c) } function Jy(i, { x: a, y: s }) { gc(i.x, a.translate, a.scale, a.originPoint), gc(i.y, s.translate, s.scale, s.originPoint) } const Lp = .999999999999, kp = 1.0000000000001; function ww(i, a, s, o = !1) { const c = s.length; if (!c) return; a.x = a.y = 1; let f, h; for (let g = 0; g < c; g++) { f = s[g], h = f.projectionDelta; const { visualElement: d } = f.options; d && d.props.style && d.props.style.display === "contents" || (o && f.options.layoutScroll && f.scroll && f !== f.root && da(i, { x: -f.scroll.offset.x, y: -f.scroll.offset.y }), h && (a.x *= h.x.scale, a.y *= h.y.scale, Jy(i, h)), o && Si(f.latestValues) && da(i, f.latestValues)) } a.x < kp && a.x > Lp && (a.x = 1), a.y < kp && a.y > Lp && (a.y = 1) } function ha(i, a) { i.min = i.min + a, i.max = i.max + a } function Hp(i, a, s, o, c = .5) { const f = Me(i.min, i.max, c); gc(i, a, s, f, o) } function da(i, a) { Hp(i.x, a.x, a.scaleX, a.scale, a.originX), Hp(i.y, a.y, a.scaleY, a.scale, a.originY) } function $y(i, a) { return Qy(gw(i.getBoundingClientRect(), a)) } function Aw(i, a, s) { const o = $y(i, s), { scroll: c } = a; return c && (ha(o.x, c.offset.x), ha(o.y, c.offset.y)), o } const qp = (i, a) => Math.abs(i - a); function Ew(i, a) { const s = qp(i.x, a.x), o = qp(i.y, a.y); return Math.sqrt(s ** 2 + o ** 2) } class Wy { constructor(a, s, { transformPagePoint: o, dragSnapToOrigin: c = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const v = $u(this.lastMoveEventInfo, this.history), x = this.startEvent !== null, S = Ew(v.offset, { x: 0, y: 0 }) >= 3; if (!x && !S) return; const { point: j } = v, { timestamp: D } = Je; this.history.push({ ...j, timestamp: D }); const { onStart: z, onMove: _ } = this.handlers; x || (z && z(this.lastMoveEvent, v), this.startEvent = this.lastMoveEvent), _ && _(this.lastMoveEvent, v) }, this.handlePointerMove = (v, x) => { if (v.target instanceof Element && v.target.hasPointerCapture && v.pointerId !== void 0) try { if (!v.target.hasPointerCapture(v.pointerId)) return } catch { } this.lastMoveEvent = v, this.lastMoveEventInfo = Ju(x, this.transformPagePoint), Ae.update(this.updatePoint, !0) }, this.handlePointerUp = (v, x) => { mr(v, "release"), this.end(); const { onEnd: S, onSessionEnd: j, resumeAnimation: D } = this.handlers; if (this.dragSnapToOrigin && D && D(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const z = $u(v.type === "pointercancel" || v.type === "lostpointercapture" ? this.lastMoveEventInfo : Ju(x, this.transformPagePoint), this.history); this.startEvent && S && S(v, z), j && j(v, z) }, !Qc(a)) return; this.dragSnapToOrigin = c, this.handlers = s, this.transformPagePoint = o; const f = ql(a), h = Ju(f, this.transformPagePoint), { point: g } = h, { timestamp: d } = Je; this.history = [{ ...g, timestamp: d }]; const { onSessionStart: m } = s; m && m(a, $u(h, this.history)), mr(a, "set"), this.removeListeners = Hl(ca(a.currentTarget, "pointermove", this.handlePointerMove), ca(a.currentTarget, "pointerup", this.handlePointerUp), ca(a.currentTarget, "pointercancel", this.handlePointerUp), ca(a.currentTarget, "lostpointercapture", this.handlePointerUp)) } updateHandlers(a) { this.handlers = a } end() { this.removeListeners && this.removeListeners(), Pn(this.updatePoint) } } function Ju(i, a) { return a ? { point: a(i.point) } : i } function Gp(i, a) { return { x: i.x - a.x, y: i.y - a.y } } function $u({ point: i }, a) { return { point: i, delta: Gp(i, Iy(a)), offset: Gp(i, jw(a)), velocity: Dw(a, .1) } } function jw(i) { return i[0] } function Iy(i) { return i[i.length - 1] } function Dw(i, a) { if (i.length < 2) return { x: 0, y: 0 }; let s = i.length - 1, o = null; const c = Iy(i); for (; s >= 0 && (o = i[s], !(c.timestamp - o.timestamp > yn(a)));)s--; if (!o) return { x: 0, y: 0 }; const f = vn(c.timestamp - o.timestamp); if (f === 0) return { x: 0, y: 0 }; const h = { x: (c.x - o.x) / f, y: (c.y - o.y) / f }; return h.x === 1 / 0 && (h.x = 0), h.y === 1 / 0 && (h.y = 0), h } function Mw(i, { min: a, max: s }, o) { return a !== void 0 && i < a ? i = o ? Me(a, i, o.min) : Math.max(i, a) : s !== void 0 && i > s && (i = o ? Me(s, i, o.max) : Math.min(i, s)), i } function Yp(i, a, s) { return { min: a !== void 0 ? i.min + a : void 0, max: s !== void 0 ? i.max + s - (i.max - i.min) : void 0 } } function Rw(i, { top: a, left: s, bottom: o, right: c }) { return { x: Yp(i.x, s, c), y: Yp(i.y, a, o) } } function Xp(i, a) { let s = a.min - i.min, o = a.max - i.max; return a.max - a.min < i.max - i.min && ([s, o] = [o, s]), { min: s, max: o } } function Cw(i, a) { return { x: Xp(i.x, a.x), y: Xp(i.y, a.y) } } function Ow(i, a) { let s = .5; const o = st(i), c = st(a); return c > o ? s = ma(a.min, a.max - o, i.min) : o > c && (s = ma(i.min, i.max - c, a.min)), xn(0, 1, s) } function Vw(i, a) { const s = {}; return a.min !== void 0 && (s.min = a.min - i.min), a.max !== void 0 && (s.max = a.max - i.min), s } const yc = .35; function zw(i = yc) { return i === !1 ? i = 0 : i === !0 && (i = yc), { x: Kp(i, "left", "right"), y: Kp(i, "top", "bottom") } } function Kp(i, a, s) { return { min: Qp(i, a), max: Qp(i, s) } } function Qp(i, a) { return typeof i == "number" ? i : i[a] || 0 } const _w = new WeakMap; class Bw { constructor(a) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Ue(), this.visualElement = a } start(a, { snapToCursor: s = !1 } = {}) { const { presenceContext: o } = this.visualElement; if (o && o.isPresent === !1) return; const c = v => { const { dragSnapToOrigin: x } = this.getProps(); x ? this.pauseAnimation() : this.stopAnimation(), s && this.snapToCursor(ql(v).point) }, f = (v, x) => { const { drag: S, dragPropagation: j, onDragStart: D } = this.getProps(); if (S && !j && (this.openDragLock && this.openDragLock(), this.openDragLock = DS(S), !this.openDragLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), _t(_ => { let O = this.getAxisMotionValue(_).get() || 0; if (Ft.test(O)) { const { projection: L } = this.visualElement; if (L && L.layout) { const N = L.layout.layoutBox[_]; N && (O = st(N) * (parseFloat(O) / 100)) } } this.originPoint[_] = O }), D && Ae.postRender(() => D(v, x)), rc(this.visualElement, "transform"); const { animationState: z } = this.visualElement; z && z.setActive("whileDrag", !0) }, h = (v, x) => { const { dragPropagation: S, dragDirectionLock: j, onDirectionLock: D, onDrag: z } = this.getProps(); if (!S && !this.openDragLock) return; const { offset: _ } = x; if (j && this.currentDirection === null) { this.currentDirection = Uw(_), this.currentDirection !== null && D && D(this.currentDirection); return } this.updateAxis("x", x.point, _), this.updateAxis("y", x.point, _), this.visualElement.render(), z && z(v, x) }, g = (v, x) => this.stop(v, x), d = () => _t(v => { var x; return this.getAnimationState(v) === "paused" && ((x = this.getAxisMotionValue(v).animation) === null || x === void 0 ? void 0 : x.play()) }), { dragSnapToOrigin: m } = this.getProps(); this.panSession = new Wy(a, { onSessionStart: c, onStart: f, onMove: h, onSessionEnd: g, resumeAnimation: d }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: m }) } stop(a, s) { const o = this.isDragging; if (this.cancel(), !o) return; const { velocity: c } = s; this.startAnimation(c); const { onDragEnd: f } = this.getProps(); f && Ae.postRender(() => f(a, s)) } cancel() { this.isDragging = !1; const { projection: a, animationState: s } = this.visualElement; a && (a.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: o } = this.getProps(); !o && this.openDragLock && (this.openDragLock(), this.openDragLock = null), s && s.setActive("whileDrag", !1) } updateAxis(a, s, o) { const { drag: c } = this.getProps(); if (!o || !lr(a, c, this.currentDirection)) return; const f = this.getAxisMotionValue(a); let h = this.originPoint[a] + o[a]; this.constraints && this.constraints[a] && (h = Mw(h, this.constraints[a], this.elastic[a])), f.set(h) } resolveConstraints() { var a; const { dragConstraints: s, dragElastic: o } = this.getProps(), c = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (a = this.visualElement.projection) === null || a === void 0 ? void 0 : a.layout, f = this.constraints; s && oa(s) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : s && c ? this.constraints = Rw(c.layoutBox, s) : this.constraints = !1, this.elastic = zw(o), f !== this.constraints && c && this.constraints && !this.hasMutatedConstraints && _t(h => { this.constraints !== !1 && this.getAxisMotionValue(h) && (this.constraints[h] = Vw(c.layoutBox[h], this.constraints[h])) }) } resolveRefConstraints() { const { dragConstraints: a, onMeasureDragConstraints: s } = this.getProps(); if (!a || !oa(a)) return !1; const o = a.current, { projection: c } = this.visualElement; if (!c || !c.layout) return !1; const f = Aw(o, c.root, this.visualElement.getTransformPagePoint()); let h = Cw(c.layout.layoutBox, f); if (s) { const g = s(pw(h)); this.hasMutatedConstraints = !!g, g && (h = Qy(g)) } return h } startAnimation(a) { const { drag: s, dragMomentum: o, dragElastic: c, dragTransition: f, dragSnapToOrigin: h, onDragTransitionEnd: g } = this.getProps(), d = this.constraints || {}, m = _t(v => { if (!lr(v, s, this.currentDirection)) return; let x = d && d[v] || {}; h && (x = { min: 0, max: 0 }); const S = c ? 200 : 1e6, j = c ? 40 : 1e7, D = { type: "inertia", velocity: o ? a[v] : 0, bounceStiffness: S, bounceDamping: j, timeConstant: 750, restDelta: 1, restSpeed: 10, ...f, ...x }; return this.startAxisValueAnimation(v, D) }); return Promise.all(m).then(g) } startAxisValueAnimation(a, s) { const o = this.getAxisMotionValue(a); return rc(this.visualElement, a), o.start(lf(a, o, 0, s, this.visualElement, !1)) } stopAnimation() { _t(a => this.getAxisMotionValue(a).stop()) } pauseAnimation() { _t(a => { var s; return (s = this.getAxisMotionValue(a).animation) === null || s === void 0 ? void 0 : s.pause() }) } getAnimationState(a) { var s; return (s = this.getAxisMotionValue(a).animation) === null || s === void 0 ? void 0 : s.state } getAxisMotionValue(a) { const s = `_drag${a.toUpperCase()}`, o = this.visualElement.getProps(), c = o[s]; return c || this.visualElement.getValue(a, (o.initial ? o.initial[a] : void 0) || 0) } snapToCursor(a) { _t(s => { const { drag: o } = this.getProps(); if (!lr(s, o, this.currentDirection)) return; const { projection: c } = this.visualElement, f = this.getAxisMotionValue(s); if (c && c.layout) { const { min: h, max: g } = c.layout.layoutBox[s]; f.set(a[s] - Me(h, g, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: a, dragConstraints: s } = this.getProps(), { projection: o } = this.visualElement; if (!oa(s) || !o || !this.constraints) return; this.stopAnimation(); const c = { x: 0, y: 0 }; _t(h => { const g = this.getAxisMotionValue(h); if (g && this.constraints !== !1) { const d = g.get(); c[h] = Ow({ min: d, max: d }, this.constraints[h]) } }); const { transformTemplate: f } = this.visualElement.getProps(); this.visualElement.current.style.transform = f ? f({}, "") : "none", o.root && o.root.updateScroll(), o.updateLayout(), this.resolveConstraints(), _t(h => { if (!lr(h, a, null)) return; const g = this.getAxisMotionValue(h), { min: d, max: m } = this.constraints[h]; g.set(Me(d, m, c[h])) }) } addListeners() { if (!this.visualElement.current) return; _w.set(this.visualElement, this); const a = this.visualElement.current, s = ca(a, "pointerdown", d => { const { drag: m, dragListener: v = !0 } = this.getProps(); m && v && this.start(d) }), o = () => { const { dragConstraints: d } = this.getProps(); oa(d) && d.current && (this.constraints = this.resolveRefConstraints()) }, { projection: c } = this.visualElement, f = c.addEventListener("measure", o); c && !c.layout && (c.root && c.root.updateScroll(), c.updateLayout()), Ae.read(o); const h = _l(window, "resize", () => this.scalePositionWithinConstraints()), g = c.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: m }) => { this.isDragging && m && (_t(v => { const x = this.getAxisMotionValue(v); x && (this.originPoint[v] += d[v].translate, x.set(x.get() + d[v].translate)) }), this.visualElement.render()) }); return () => { h(), s(), f(), g && g() } } getProps() { const a = this.visualElement.getProps(), { drag: s = !1, dragDirectionLock: o = !1, dragPropagation: c = !1, dragConstraints: f = !1, dragElastic: h = yc, dragMomentum: g = !0 } = a; return { ...a, drag: s, dragDirectionLock: o, dragPropagation: c, dragConstraints: f, dragElastic: h, dragMomentum: g } } } function lr(i, a, s) { return (a === !0 || a === i) && (s === null || s === i) } function Uw(i, a = 10) { let s = null; return Math.abs(i.y) > a ? s = "y" : Math.abs(i.x) > a && (s = "x"), s } class Nw extends $n { constructor(a) { super(a), this.removeGroupControls = yt, this.removeListeners = yt, this.controls = new Bw(a) } mount() { const { dragControls: a } = this.node.getProps(); a && (this.removeGroupControls = a.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || yt } unmount() { this.removeGroupControls(), this.removeListeners() } } const Zp = i => (a, s) => { i && Ae.postRender(() => i(a, s)) }; class Lw extends $n { constructor() { super(...arguments), this.removePointerDownListener = yt } onPointerDown(a) { this.session = new Wy(a, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint() }) } createPanHandlers() { const { onPanSessionStart: a, onPanStart: s, onPan: o, onPanEnd: c } = this.node.getProps(); return { onSessionStart: Zp(a), onStart: Zp(s), onMove: o, onEnd: (f, h) => { delete this.session, c && Ae.postRender(() => c(f, h)) } } } mount() { this.removePointerDownListener = ca(this.node.current, "pointerdown", a => this.onPointerDown(a)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } const cr = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function Pp(i, a) { return a.max === a.min ? 0 : i / (a.max - a.min) * 100 } const Sl = { correct: (i, a) => { if (!a.target) return i; if (typeof i == "string") if (ne.test(i)) i = parseFloat(i); else return i; const s = Pp(i, a.target.x), o = Pp(i, a.target.y); return `${s}% ${o}%` } }, kw = { correct: (i, { treeScale: a, projectionDelta: s }) => { const o = i, c = Fn.parse(i); if (c.length > 5) return o; const f = Fn.createTransformer(i), h = typeof c[0] != "number" ? 1 : 0, g = s.x.scale * a.x, d = s.y.scale * a.y; c[0 + h] /= g, c[1 + h] /= d; const m = Me(g, d, .5); return typeof c[2 + h] == "number" && (c[2 + h] /= m), typeof c[3 + h] == "number" && (c[3 + h] /= m), f(c) } }; class Hw extends C.Component { componentDidMount() { const { visualElement: a, layoutGroup: s, switchLayoutGroup: o, layoutId: c } = this.props, { projection: f } = a; X1(qw), f && (s.group && s.group.add(f), o && o.register && c && o.register(f), f.root.didUpdate(), f.addEventListener("animationComplete", () => { this.safeToRemove() }), f.setOptions({ ...f.options, onExitComplete: () => this.safeToRemove() })), cr.hasEverUpdated = !0 } getSnapshotBeforeUpdate(a) { const { layoutDependency: s, visualElement: o, drag: c, isPresent: f } = this.props, h = o.projection; return h && (h.isPresent = f, c || a.layoutDependency !== s || s === void 0 ? h.willUpdate() : this.safeToRemove(), a.isPresent !== f && (f ? h.promote() : h.relegate() || Ae.postRender(() => { const g = h.getStack(); (!g || !g.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: a } = this.props.visualElement; a && (a.root.didUpdate(), Vc.postRender(() => { !a.currentAnimation && a.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: a, layoutGroup: s, switchLayoutGroup: o } = this.props, { projection: c } = a; c && (c.scheduleCheckAfterUnmount(), s && s.group && s.group.remove(c), o && o.deregister && o.deregister(c)) } safeToRemove() { const { safeToRemove: a } = this.props; a && a() } render() { return null } } function ev(i) { const [a, s] = S1(), o = C.useContext(Ng); return y.jsx(Hw, { ...i, layoutGroup: o, switchLayoutGroup: C.useContext(Kg), isPresent: a, safeToRemove: s }) } const qw = { borderRadius: { ...Sl, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: Sl, borderTopRightRadius: Sl, borderBottomLeftRadius: Sl, borderBottomRightRadius: Sl, boxShadow: kw }; function Gw(i, a, s) { const o = tt(i) ? i : Vl(i); return o.start(lf("", o, a, s)), o.animation } function Yw(i) { return i instanceof SVGElement && i.tagName !== "svg" } const Xw = (i, a) => i.depth - a.depth; class Kw { constructor() { this.children = [], this.isDirty = !1 } add(a) { Zc(this.children, a), this.isDirty = !0 } remove(a) { Pc(this.children, a), this.isDirty = !0 } forEach(a) { this.isDirty && this.children.sort(Xw), this.isDirty = !1, this.children.forEach(a) } } function Qw(i, a) { const s = Jt.now(), o = ({ timestamp: c }) => { const f = c - s; f >= a && (Pn(o), i(f - a)) }; return Ae.read(o, !0), () => Pn(o) } const tv = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], Zw = tv.length, Fp = i => typeof i == "string" ? parseFloat(i) : i, Jp = i => typeof i == "number" || ne.test(i); function Pw(i, a, s, o, c, f) { c ? (i.opacity = Me(0, s.opacity !== void 0 ? s.opacity : 1, Fw(o)), i.opacityExit = Me(a.opacity !== void 0 ? a.opacity : 1, 0, Jw(o))) : f && (i.opacity = Me(a.opacity !== void 0 ? a.opacity : 1, s.opacity !== void 0 ? s.opacity : 1, o)); for (let h = 0; h < Zw; h++) { const g = `border${tv[h]}Radius`; let d = $p(a, g), m = $p(s, g); if (d === void 0 && m === void 0) continue; d || (d = 0), m || (m = 0), d === 0 || m === 0 || Jp(d) === Jp(m) ? (i[g] = Math.max(Me(Fp(d), Fp(m), o), 0), (Ft.test(m) || Ft.test(d)) && (i[g] += "%")) : i[g] = m } (a.rotate || s.rotate) && (i.rotate = Me(a.rotate || 0, s.rotate || 0, o)) } function $p(i, a) { return i[a] !== void 0 ? i[a] : i.borderRadius } const Fw = nv(0, .5, xy), Jw = nv(.5, .95, yt); function nv(i, a, s) { return o => o < i ? 0 : o > a ? 1 : s(ma(i, a, o)) } function Wp(i, a) { i.min = a.min, i.max = a.max } function zt(i, a) { Wp(i.x, a.x), Wp(i.y, a.y) } function Ip(i, a) { i.translate = a.translate, i.scale = a.scale, i.originPoint = a.originPoint, i.origin = a.origin } function eg(i, a, s, o, c) { return i -= a, i = vr(i, 1 / s, o), c !== void 0 && (i = vr(i, 1 / c, o)), i } function $w(i, a = 0, s = 1, o = .5, c, f = i, h = i) { if (Ft.test(a) && (a = parseFloat(a), a = Me(h.min, h.max, a / 100) - h.min), typeof a != "number") return; let g = Me(f.min, f.max, o); i === f && (g -= a), i.min = eg(i.min, a, s, g, c), i.max = eg(i.max, a, s, g, c) } function tg(i, a, [s, o, c], f, h) { $w(i, a[s], a[o], a[c], a.scale, f, h) } const Ww = ["x", "scaleX", "originX"], Iw = ["y", "scaleY", "originY"]; function ng(i, a, s, o) { tg(i.x, a, Ww, s ? s.x : void 0, o ? o.x : void 0), tg(i.y, a, Iw, s ? s.y : void 0, o ? o.y : void 0) } function ig(i) { return i.translate === 0 && i.scale === 1 } function iv(i) { return ig(i.x) && ig(i.y) } function ag(i, a) { return i.min === a.min && i.max === a.max } function eA(i, a) { return ag(i.x, a.x) && ag(i.y, a.y) } function lg(i, a) { return Math.round(i.min) === Math.round(a.min) && Math.round(i.max) === Math.round(a.max) } function av(i, a) { return lg(i.x, a.x) && lg(i.y, a.y) } function sg(i) { return st(i.x) / st(i.y) } function rg(i, a) { return i.translate === a.translate && i.scale === a.scale && i.originPoint === a.originPoint } class tA { constructor() { this.members = [] } add(a) { Zc(this.members, a), a.scheduleRender() } remove(a) { if (Pc(this.members, a), a === this.prevLead && (this.prevLead = void 0), a === this.lead) { const s = this.members[this.members.length - 1]; s && this.promote(s) } } relegate(a) { const s = this.members.findIndex(c => a === c); if (s === 0) return !1; let o; for (let c = s; c >= 0; c--) { const f = this.members[c]; if (f.isPresent !== !1) { o = f; break } } return o ? (this.promote(o), !0) : !1 } promote(a, s) { const o = this.lead; if (a !== o && (this.prevLead = o, this.lead = a, a.show(), o)) { o.instance && o.scheduleRender(), a.scheduleRender(), a.resumeFrom = o, s && (a.resumeFrom.preserveOpacity = !0), o.snapshot && (a.snapshot = o.snapshot, a.snapshot.latestValues = o.animationValues || o.latestValues), a.root && a.root.isUpdating && (a.isLayoutDirty = !0); const { crossfade: c } = a.options; c === !1 && o.hide() } } exitAnimationComplete() { this.members.forEach(a => { const { options: s, resumingFrom: o } = a; s.onExitComplete && s.onExitComplete(), o && o.options.onExitComplete && o.options.onExitComplete() }) } scheduleRender() { this.members.forEach(a => { a.instance && a.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function nA(i, a, s) { let o = ""; const c = i.x.translate / a.x, f = i.y.translate / a.y, h = (s == null ? void 0 : s.z) || 0; if ((c || f || h) && (o = `translate3d(${c}px, ${f}px, ${h}px) `), (a.x !== 1 || a.y !== 1) && (o += `scale(${1 / a.x}, ${1 / a.y}) `), s) { const { transformPerspective: m, rotate: v, rotateX: x, rotateY: S, skewX: j, skewY: D } = s; m && (o = `perspective(${m}px) ${o}`), v && (o += `rotate(${v}deg) `), x && (o += `rotateX(${x}deg) `), S && (o += `rotateY(${S}deg) `), j && (o += `skewX(${j}deg) `), D && (o += `skewY(${D}deg) `) } const g = i.x.scale * a.x, d = i.y.scale * a.y; return (g !== 1 || d !== 1) && (o += `scale(${g}, ${d})`), o || "none" } const Wu = ["", "X", "Y", "Z"], iA = { visibility: "hidden" }, og = 1e3; let aA = 0; function Iu(i, a, s, o) { const { latestValues: c } = a; c[i] && (s[i] = c[i], a.setStaticValue(i, 0), o && (o[i] = 0)) } function lv(i) { if (i.hasCheckedOptimisedAppear = !0, i.root === i) return; const { visualElement: a } = i.options; if (!a) return; const s = dy(a); if (window.MotionHasOptimisedAnimation(s, "transform")) { const { layout: c, layoutId: f } = i.options; window.MotionCancelOptimisedAnimation(s, "transform", Ae, !(c || f)) } const { parent: o } = i; o && !o.hasCheckedOptimisedAppear && lv(o) } function sv({ attachResizeListener: i, defaultParent: a, measureScroll: s, checkIsScrollRoot: o, resetTransform: c }) { return class { constructor(h = {}, g = a == null ? void 0 : a()) { this.id = aA++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, this.nodes.forEach(rA), this.nodes.forEach(hA), this.nodes.forEach(dA), this.nodes.forEach(oA) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = h, this.root = g ? g.root || g : this, this.path = g ? [...g.path, g] : [], this.parent = g, this.depth = g ? g.depth + 1 : 0; for (let d = 0; d < this.path.length; d++)this.path[d].shouldResetTransform = !0; this.root === this && (this.nodes = new Kw) } addEventListener(h, g) { return this.eventHandlers.has(h) || this.eventHandlers.set(h, new Fc), this.eventHandlers.get(h).add(g) } notifyListeners(h, ...g) { const d = this.eventHandlers.get(h); d && d.notify(...g) } hasListeners(h) { return this.eventHandlers.has(h) } mount(h, g = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = Yw(h), this.instance = h; const { layoutId: d, layout: m, visualElement: v } = this.options; if (v && !v.current && v.mount(h), this.root.nodes.add(this), this.parent && this.parent.children.add(this), g && (m || d) && (this.isLayoutDirty = !0), i) { let x; const S = () => this.root.updateBlockedByResize = !1; i(h, () => { this.root.updateBlockedByResize = !0, x && x(), x = Qw(S, 250), cr.hasAnimatedSinceResize && (cr.hasAnimatedSinceResize = !1, this.nodes.forEach(cg)) }) } d && this.root.registerSharedNode(d, this), this.options.animate !== !1 && v && (d || m) && this.addEventListener("didUpdate", ({ delta: x, hasLayoutChanged: S, hasRelativeLayoutChanged: j, layout: D }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const z = this.options.transition || v.getDefaultTransition() || vA, { onLayoutAnimationStart: _, onLayoutAnimationComplete: O } = v.getProps(), L = !this.targetLayout || !av(this.targetLayout, D), N = !S && j; if (this.options.layoutRoot || this.resumeFrom || N || S && (L || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(x, N); const J = { ...Yc(z, "layout"), onPlay: _, onComplete: O }; (v.shouldReduceMotion || this.options.layoutRoot) && (J.delay = 0, J.type = !1), this.startAnimation(J) } else S || cg(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = D }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const h = this.getStack(); h && h.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Pn(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(mA), this.animationId++) } getTransformTemplate() { const { visualElement: h } = this.options; return h && h.getProps().transformTemplate } willUpdate(h = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && lv(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let v = 0; v < this.path.length; v++) { const x = this.path[v]; x.shouldResetTransform = !0, x.updateScroll("snapshot"), x.options.layoutRoot && x.willUpdate(!1) } const { layoutId: g, layout: d } = this.options; if (g === void 0 && !d) return; const m = this.getTransformTemplate(); this.prevTransformTemplateValue = m ? m(this.latestValues, "") : void 0, this.updateSnapshot(), h && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(ug); return } this.isUpdating || this.nodes.forEach(cA), this.isUpdating = !1, this.nodes.forEach(fA), this.nodes.forEach(lA), this.nodes.forEach(sA), this.clearAllSnapshots(); const g = Jt.now(); Je.delta = xn(0, 1e3 / 60, g - Je.timestamp), Je.timestamp = g, Je.isProcessing = !0, Xu.update.process(Je), Xu.preRender.process(Je), Xu.render.process(Je), Je.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Vc.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(uA), this.sharedNodes.forEach(pA) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Ae.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Ae.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !st(this.snapshot.measuredBox.x) && !st(this.snapshot.measuredBox.y) && (this.snapshot = void 0)) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let d = 0; d < this.path.length; d++)this.path[d].updateScroll(); const h = this.layout; this.layout = this.measure(!1), this.layoutCorrected = Ue(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: g } = this.options; g && g.notify("LayoutMeasure", this.layout.layoutBox, h ? h.layoutBox : void 0) } updateScroll(h = "measure") { let g = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === h && (g = !1), g) { const d = o(this.instance); this.scroll = { animationId: this.root.animationId, phase: h, isRoot: d, offset: s(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : d } } } resetTransform() { if (!c) return; const h = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, g = this.projectionDelta && !iv(this.projectionDelta), d = this.getTransformTemplate(), m = d ? d(this.latestValues, "") : void 0, v = m !== this.prevTransformTemplateValue; h && (g || Si(this.latestValues) || v) && (c(this.instance, m), this.shouldResetTransform = !1, this.scheduleRender()) } measure(h = !0) { const g = this.measurePageBox(); let d = this.removeElementScroll(g); return h && (d = this.removeTransform(d)), bA(d), { animationId: this.root.animationId, measuredBox: g, layoutBox: d, latestValues: {}, source: this.id } } measurePageBox() { var h; const { visualElement: g } = this.options; if (!g) return Ue(); const d = g.measureViewportBox(); if (!(((h = this.scroll) === null || h === void 0 ? void 0 : h.wasRoot) || this.path.some(xA))) { const { scroll: v } = this.root; v && (ha(d.x, v.offset.x), ha(d.y, v.offset.y)) } return d } removeElementScroll(h) { var g; const d = Ue(); if (zt(d, h), !((g = this.scroll) === null || g === void 0) && g.wasRoot) return d; for (let m = 0; m < this.path.length; m++) { const v = this.path[m], { scroll: x, options: S } = v; v !== this.root && x && S.layoutScroll && (x.wasRoot && zt(d, h), ha(d.x, x.offset.x), ha(d.y, x.offset.y)) } return d } applyTransform(h, g = !1) { const d = Ue(); zt(d, h); for (let m = 0; m < this.path.length; m++) { const v = this.path[m]; !g && v.options.layoutScroll && v.scroll && v !== v.root && da(d, { x: -v.scroll.offset.x, y: -v.scroll.offset.y }), Si(v.latestValues) && da(d, v.latestValues) } return Si(this.latestValues) && da(d, this.latestValues), d } removeTransform(h) { const g = Ue(); zt(g, h); for (let d = 0; d < this.path.length; d++) { const m = this.path[d]; if (!m.instance || !Si(m.latestValues)) continue; pc(m.latestValues) && m.updateSnapshot(); const v = Ue(), x = m.measurePageBox(); zt(v, x), ng(g, m.latestValues, m.snapshot ? m.snapshot.layoutBox : void 0, v) } return Si(this.latestValues) && ng(g, this.latestValues), g } setTargetDelta(h) { this.targetDelta = h, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(h) { this.options = { ...this.options, ...h, crossfade: h.crossfade !== void 0 ? h.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Je.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(h = !1) { var g; const d = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = d.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = d.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = d.isSharedProjectionDirty); const m = !!this.resumingFrom || this !== d; if (!(h || m && this.isSharedProjectionDirty || this.isProjectionDirty || !((g = this.parent) === null || g === void 0) && g.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: x, layoutId: S } = this.options; if (!(!this.layout || !(x || S))) { if (this.resolvedRelativeTargetAt = Je.timestamp, !this.targetDelta && !this.relativeTarget) { const j = this.getClosestProjectingParent(); j && j.layout && this.animationProgress !== 1 ? (this.relativeParent = j, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Ue(), this.relativeTargetOrigin = Ue(), jl(this.relativeTargetOrigin, this.layout.layoutBox, j.layout.layoutBox), zt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = Ue(), this.targetWithTransforms = Ue()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), Tw(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : zt(this.target, this.layout.layoutBox), Jy(this.target, this.targetDelta)) : zt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) { this.attemptToResolveRelativeTarget = !1; const j = this.getClosestProjectingParent(); j && !!j.resumingFrom == !!this.resumingFrom && !j.options.layoutScroll && j.target && this.animationProgress !== 1 ? (this.relativeParent = j, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Ue(), this.relativeTargetOrigin = Ue(), jl(this.relativeTargetOrigin, this.target, j.target), zt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } } } getClosestProjectingParent() { if (!(!this.parent || pc(this.parent.latestValues) || Fy(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var h; const g = this.getLead(), d = !!this.resumingFrom || this !== g; let m = !0; if ((this.isProjectionDirty || !((h = this.parent) === null || h === void 0) && h.isProjectionDirty) && (m = !1), d && (this.isSharedProjectionDirty || this.isTransformDirty) && (m = !1), this.resolvedRelativeTargetAt === Je.timestamp && (m = !1), m) return; const { layout: v, layoutId: x } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(v || x)) return; zt(this.layoutCorrected, this.layout.layoutBox); const S = this.treeScale.x, j = this.treeScale.y; ww(this.layoutCorrected, this.treeScale, this.path, d), g.layout && !g.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (g.target = g.layout.layoutBox, g.targetWithTransforms = Ue()); const { target: D } = g; if (!D) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Ip(this.prevProjectionDelta.x, this.projectionDelta.x), Ip(this.prevProjectionDelta.y, this.projectionDelta.y)), El(this.projectionDelta, this.layoutCorrected, D, this.latestValues), (this.treeScale.x !== S || this.treeScale.y !== j || !rg(this.projectionDelta.x, this.prevProjectionDelta.x) || !rg(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", D)) } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(h = !0) { var g; if ((g = this.options.visualElement) === null || g === void 0 || g.scheduleRender(), h) { const d = this.getStack(); d && d.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = fa(), this.projectionDelta = fa(), this.projectionDeltaWithTransform = fa() } setAnimationOrigin(h, g = !1) { const d = this.snapshot, m = d ? d.latestValues : {}, v = { ...this.latestValues }, x = fa(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !g; const S = Ue(), j = d ? d.source : void 0, D = this.layout ? this.layout.source : void 0, z = j !== D, _ = this.getStack(), O = !_ || _.members.length <= 1, L = !!(z && !O && this.options.crossfade === !0 && !this.path.some(yA)); this.animationProgress = 0; let N; this.mixTargetDelta = J => { const q = J / 1e3; fg(x.x, h.x, q), fg(x.y, h.y, q), this.setTargetDelta(x), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (jl(S, this.layout.layoutBox, this.relativeParent.layout.layoutBox), gA(this.relativeTarget, this.relativeTargetOrigin, S, q), N && eA(this.relativeTarget, N) && (this.isProjectionDirty = !1), N || (N = Ue()), zt(N, this.relativeTarget)), z && (this.animationValues = v, Pw(v, m, this.latestValues, q, L, O)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = q }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(h) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Pn(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Ae.update(() => { cr.hasAnimatedSinceResize = !0, this.currentAnimation = Gw(0, og, { ...h, onUpdate: g => { this.mixTargetDelta(g), h.onUpdate && h.onUpdate(g) }, onStop: () => { }, onComplete: () => { h.onComplete && h.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const h = this.getStack(); h && h.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(og), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const h = this.getLead(); let { targetWithTransforms: g, target: d, layout: m, latestValues: v } = h; if (!(!g || !d || !m)) { if (this !== h && this.layout && m && rv(this.options.animationType, this.layout.layoutBox, m.layoutBox)) { d = this.target || Ue(); const x = st(this.layout.layoutBox.x); d.x.min = h.target.x.min, d.x.max = d.x.min + x; const S = st(this.layout.layoutBox.y); d.y.min = h.target.y.min, d.y.max = d.y.min + S } zt(g, d), da(g, v), El(this.projectionDeltaWithTransform, this.layoutCorrected, g, v) } } registerSharedNode(h, g) { this.sharedNodes.has(h) || this.sharedNodes.set(h, new tA), this.sharedNodes.get(h).add(g); const m = g.options.initialPromotionConfig; g.promote({ transition: m ? m.transition : void 0, preserveFollowOpacity: m && m.shouldPreserveFollowOpacity ? m.shouldPreserveFollowOpacity(g) : void 0 }) } isLead() { const h = this.getStack(); return h ? h.lead === this : !0 } getLead() { var h; const { layoutId: g } = this.options; return g ? ((h = this.getStack()) === null || h === void 0 ? void 0 : h.lead) || this : this } getPrevLead() { var h; const { layoutId: g } = this.options; return g ? (h = this.getStack()) === null || h === void 0 ? void 0 : h.prevLead : void 0 } getStack() { const { layoutId: h } = this.options; if (h) return this.root.sharedNodes.get(h) } promote({ needsReset: h, transition: g, preserveFollowOpacity: d } = {}) { const m = this.getStack(); m && m.promote(this, d), h && (this.projectionDelta = void 0, this.needsReset = !0), g && this.setOptions({ transition: g }) } relegate() { const h = this.getStack(); return h ? h.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: h } = this.options; if (!h) return; let g = !1; const { latestValues: d } = h; if ((d.z || d.rotate || d.rotateX || d.rotateY || d.rotateZ || d.skewX || d.skewY) && (g = !0), !g) return; const m = {}; d.z && Iu("z", h, m, this.animationValues); for (let v = 0; v < Wu.length; v++)Iu(`rotate${Wu[v]}`, h, m, this.animationValues), Iu(`skew${Wu[v]}`, h, m, this.animationValues); h.render(); for (const v in m) h.setStaticValue(v, m[v]), this.animationValues && (this.animationValues[v] = m[v]); h.scheduleRender() } getProjectionStyles(h) { var g, d; if (!this.instance || this.isSVG) return; if (!this.isVisible) return iA; const m = { visibility: "" }, v = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, m.opacity = "", m.pointerEvents = or(h == null ? void 0 : h.pointerEvents) || "", m.transform = v ? v(this.latestValues, "") : "none", m; const x = this.getLead(); if (!this.projectionDelta || !this.layout || !x.target) { const z = {}; return this.options.layoutId && (z.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, z.pointerEvents = or(h == null ? void 0 : h.pointerEvents) || ""), this.hasProjected && !Si(this.latestValues) && (z.transform = v ? v({}, "") : "none", this.hasProjected = !1), z } const S = x.animationValues || x.latestValues; this.applyTransformsToTarget(), m.transform = nA(this.projectionDeltaWithTransform, this.treeScale, S), v && (m.transform = v(S, m.transform)); const { x: j, y: D } = this.projectionDelta; m.transformOrigin = `${j.origin * 100}% ${D.origin * 100}% 0`, x.animationValues ? m.opacity = x === this ? (d = (g = S.opacity) !== null && g !== void 0 ? g : this.latestValues.opacity) !== null && d !== void 0 ? d : 1 : this.preserveOpacity ? this.latestValues.opacity : S.opacityExit : m.opacity = x === this ? S.opacity !== void 0 ? S.opacity : "" : S.opacityExit !== void 0 ? S.opacityExit : 0; for (const z in Rl) { if (S[z] === void 0) continue; const { correct: _, applyTo: O, isCSSVariable: L } = Rl[z], N = m.transform === "none" ? S[z] : _(S[z], x); if (O) { const J = O.length; for (let q = 0; q < J; q++)m[O[q]] = N } else L ? this.options.visualElement.renderState.vars[z] = N : m[z] = N } return this.options.layoutId && (m.pointerEvents = x === this ? or(h == null ? void 0 : h.pointerEvents) || "" : "none"), m } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(h => { var g; return (g = h.currentAnimation) === null || g === void 0 ? void 0 : g.stop() }), this.root.nodes.forEach(ug), this.root.sharedNodes.clear() } } } function lA(i) { i.updateLayout() } function sA(i) { var a; const s = ((a = i.resumeFrom) === null || a === void 0 ? void 0 : a.snapshot) || i.snapshot; if (i.isLead() && i.layout && s && i.hasListeners("didUpdate")) { const { layoutBox: o, measuredBox: c } = i.layout, { animationType: f } = i.options, h = s.source !== i.layout.source; f === "size" ? _t(x => { const S = h ? s.measuredBox[x] : s.layoutBox[x], j = st(S); S.min = o[x].min, S.max = S.min + j }) : rv(f, s.layoutBox, o) && _t(x => { const S = h ? s.measuredBox[x] : s.layoutBox[x], j = st(o[x]); S.max = S.min + j, i.relativeTarget && !i.currentAnimation && (i.isProjectionDirty = !0, i.relativeTarget[x].max = i.relativeTarget[x].min + j) }); const g = fa(); El(g, o, s.layoutBox); const d = fa(); h ? El(d, i.applyTransform(c, !0), s.measuredBox) : El(d, o, s.layoutBox); const m = !iv(g); let v = !1; if (!i.resumeFrom) { const x = i.getClosestProjectingParent(); if (x && !x.resumeFrom) { const { snapshot: S, layout: j } = x; if (S && j) { const D = Ue(); jl(D, s.layoutBox, S.layoutBox); const z = Ue(); jl(z, o, j.layoutBox), av(D, z) || (v = !0), x.options.layoutRoot && (i.relativeTarget = z, i.relativeTargetOrigin = D, i.relativeParent = x) } } } i.notifyListeners("didUpdate", { layout: o, snapshot: s, delta: d, layoutDelta: g, hasLayoutChanged: m, hasRelativeLayoutChanged: v }) } else if (i.isLead()) { const { onExitComplete: o } = i.options; o && o() } i.options.transition = void 0 } function rA(i) { i.parent && (i.isProjecting() || (i.isProjectionDirty = i.parent.isProjectionDirty), i.isSharedProjectionDirty || (i.isSharedProjectionDirty = !!(i.isProjectionDirty || i.parent.isProjectionDirty || i.parent.isSharedProjectionDirty)), i.isTransformDirty || (i.isTransformDirty = i.parent.isTransformDirty)) } function oA(i) { i.isProjectionDirty = i.isSharedProjectionDirty = i.isTransformDirty = !1 } function uA(i) { i.clearSnapshot() } function ug(i) { i.clearMeasurements() } function cA(i) { i.isLayoutDirty = !1 } function fA(i) { const { visualElement: a } = i.options; a && a.getProps().onBeforeLayoutMeasure && a.notify("BeforeLayoutMeasure"), i.resetTransform() } function cg(i) { i.finishAnimation(), i.targetDelta = i.relativeTarget = i.target = void 0, i.isProjectionDirty = !0 } function hA(i) { i.resolveTargetDelta() } function dA(i) { i.calcProjection() } function mA(i) { i.resetSkewAndRotation() } function pA(i) { i.removeLeadSnapshot() } function fg(i, a, s) { i.translate = Me(a.translate, 0, s), i.scale = Me(a.scale, 1, s), i.origin = a.origin, i.originPoint = a.originPoint } function hg(i, a, s, o) { i.min = Me(a.min, s.min, o), i.max = Me(a.max, s.max, o) } function gA(i, a, s, o) { hg(i.x, a.x, s.x, o), hg(i.y, a.y, s.y, o) } function yA(i) { return i.animationValues && i.animationValues.opacityExit !== void 0 } const vA = { duration: .45, ease: [.4, 0, .1, 1] }, dg = i => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(i), mg = dg("applewebkit/") && !dg("chrome/") ? Math.round : yt; function pg(i) { i.min = mg(i.min), i.max = mg(i.max) } function bA(i) { pg(i.x), pg(i.y) } function rv(i, a, s) { return i === "position" || i === "preserve-aspect" && !Sw(sg(a), sg(s), .2) } function xA(i) { var a; return i !== i.root && ((a = i.scroll) === null || a === void 0 ? void 0 : a.wasRoot) } const SA = sv({ attachResizeListener: (i, a) => _l(i, "resize", a), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), ec = { current: void 0 }, ov = sv({ measureScroll: i => ({ x: i.scrollLeft, y: i.scrollTop }), defaultParent: () => { if (!ec.current) { const i = new SA({}); i.mount(window), i.setOptions({ layoutScroll: !0 }), ec.current = i } return ec.current }, resetTransform: (i, a) => { i.style.transform = a !== void 0 ? a : "none" }, checkIsScrollRoot: i => window.getComputedStyle(i).position === "fixed" }), TA = { pan: { Feature: Lw }, drag: { Feature: Nw, ProjectionNode: ov, MeasureLayout: ev } }; function gg(i, a, s) { const { props: o } = i; i.animationState && o.whileHover && i.animationState.setActive("whileHover", s === "Start"); const c = "onHover" + s, f = o[c]; f && Ae.postRender(() => f(a, ql(a))) } class wA extends $n { mount() { const { current: a } = this.node; a && (this.unmount = SS(a, (s, o) => (gg(this.node, o, "Start"), c => gg(this.node, c, "End")))) } unmount() { } } class AA extends $n { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let a = !1; try { a = this.node.current.matches(":focus-visible") } catch { a = !0 } !a || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = Hl(_l(this.node.current, "focus", () => this.onFocus()), _l(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function yg(i, a, s) { const { props: o } = i; if (i.current instanceof HTMLButtonElement && i.current.disabled) return; i.animationState && o.whileTap && i.animationState.setActive("whileTap", s === "Start"); const c = "onTap" + (s === "End" ? "" : s), f = o[c]; f && Ae.postRender(() => f(a, ql(a))) } class EA extends $n { mount() { const { current: a } = this.node; a && (this.unmount = ES(a, (s, o) => (yg(this.node, o, "Start"), (c, { success: f }) => yg(this.node, c, f ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } } const vc = new WeakMap, tc = new WeakMap, jA = i => { const a = vc.get(i.target); a && a(i) }, DA = i => { i.forEach(jA) }; function MA({ root: i, ...a }) { const s = i || document; tc.has(s) || tc.set(s, {}); const o = tc.get(s), c = JSON.stringify(a); return o[c] || (o[c] = new IntersectionObserver(DA, { root: i, ...a })), o[c] } function RA(i, a, s) { const o = MA(a); return vc.set(i, s), o.observe(i), () => { vc.delete(i), o.unobserve(i) } } const CA = { some: 0, all: 1 }; class OA extends $n { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: a = {} } = this.node.getProps(), { root: s, margin: o, amount: c = "some", once: f } = a, h = { root: s ? s.current : void 0, rootMargin: o, threshold: typeof c == "number" ? c : CA[c] }, g = d => { const { isIntersecting: m } = d; if (this.isInView === m || (this.isInView = m, f && !m && this.hasEnteredView)) return; m && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", m); const { onViewportEnter: v, onViewportLeave: x } = this.node.getProps(), S = m ? v : x; S && S(d) }; return RA(this.node.current, h, g) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: a, prevProps: s } = this.node;["amount", "margin", "root"].some(VA(a, s)) && this.startObserver() } unmount() { } } function VA({ viewport: i = {} }, { viewport: a = {} } = {}) { return s => i[s] !== a[s] } const zA = { inView: { Feature: OA }, tap: { Feature: EA }, focus: { Feature: AA }, hover: { Feature: wA } }, _A = { layout: { ProjectionNode: ov, MeasureLayout: ev } }, bc = { current: null }, uv = { current: !1 }; function BA() { if (uv.current = !0, !!Dc) if (window.matchMedia) { const i = window.matchMedia("(prefers-reduced-motion)"), a = () => bc.current = i.matches; i.addListener(a), a() } else bc.current = !1 } const UA = [..._y, et, Fn], NA = i => UA.find(zy(i)), LA = new WeakMap; function kA(i, a, s) { for (const o in a) { const c = a[o], f = s[o]; if (tt(c)) i.addValue(o, c); else if (tt(f)) i.addValue(o, Vl(c, { owner: i })); else if (f !== c) if (i.hasValue(o)) { const h = i.getValue(o); h.liveStyle === !0 ? h.jump(c) : h.hasAnimated || h.set(c) } else { const h = i.getStaticValue(o); i.addValue(o, Vl(h !== void 0 ? h : c, { owner: i })) } } for (const o in s) a[o] === void 0 && i.removeValue(o); return a } const vg = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class HA { scrapeMotionValuesFromProps(a, s, o) { return {} } constructor({ parent: a, props: s, presenceContext: o, reducedMotionConfig: c, blockInitialAnimation: f, visualState: h }, g = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = tf, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const j = Jt.now(); this.renderScheduledAt < j && (this.renderScheduledAt = j, Ae.render(this.render, !1, !0)) }; const { latestValues: d, renderState: m, onUpdate: v } = h; this.onUpdate = v, this.latestValues = d, this.baseTarget = { ...d }, this.initialValues = s.initial ? { ...d } : {}, this.renderState = m, this.parent = a, this.props = s, this.presenceContext = o, this.depth = a ? a.depth + 1 : 0, this.reducedMotionConfig = c, this.options = g, this.blockInitialAnimation = !!f, this.isControllingVariants = wr(s), this.isVariantNode = Yg(s), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(a && a.current); const { willChange: x, ...S } = this.scrapeMotionValuesFromProps(s, {}, this); for (const j in S) { const D = S[j]; d[j] !== void 0 && tt(D) && D.set(d[j], !1) } } mount(a) { this.current = a, LA.set(a, this), this.projection && !this.projection.instance && this.projection.mount(a), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((s, o) => this.bindToMotionValue(o, s)), uv.current || BA(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : bc.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { this.projection && this.projection.unmount(), Pn(this.notifyUpdate), Pn(this.render), this.valueSubscriptions.forEach(a => a()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const a in this.events) this.events[a].clear(); for (const a in this.features) { const s = this.features[a]; s && (s.unmount(), s.isMounted = !1) } this.current = null } bindToMotionValue(a, s) { this.valueSubscriptions.has(a) && this.valueSubscriptions.get(a)(); const o = Ei.has(a); o && this.onBindTransform && this.onBindTransform(); const c = s.on("change", g => { this.latestValues[a] = g, this.props.onUpdate && Ae.preRender(this.notifyUpdate), o && this.projection && (this.projection.isTransformDirty = !0) }), f = s.on("renderRequest", this.scheduleRender); let h; window.MotionCheckAppearSync && (h = window.MotionCheckAppearSync(this, a, s)), this.valueSubscriptions.set(a, () => { c(), f(), h && h(), s.owner && s.stop() }) } sortNodePosition(a) { return !this.current || !this.sortInstanceNodePosition || this.type !== a.type ? 0 : this.sortInstanceNodePosition(this.current, a.current) } updateFeatures() { let a = "animation"; for (a in pa) { const s = pa[a]; if (!s) continue; const { isEnabled: o, Feature: c } = s; if (!this.features[a] && c && o(this.props) && (this.features[a] = new c(this)), this.features[a]) { const f = this.features[a]; f.isMounted ? f.update() : (f.mount(), f.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Ue() } getStaticValue(a) { return this.latestValues[a] } setStaticValue(a, s) { this.latestValues[a] = s } update(a, s) { (a.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = a, this.prevPresenceContext = this.presenceContext, this.presenceContext = s; for (let o = 0; o < vg.length; o++) { const c = vg[o]; this.propEventSubscriptions[c] && (this.propEventSubscriptions[c](), delete this.propEventSubscriptions[c]); const f = "on" + c, h = a[f]; h && (this.propEventSubscriptions[c] = this.on(c, h)) } this.prevMotionValues = kA(this, this.scrapeMotionValuesFromProps(a, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue(), this.onUpdate && this.onUpdate(this) } getProps() { return this.props } getVariant(a) { return this.props.variants ? this.props.variants[a] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(a) { const s = this.getClosestVariantNode(); if (s) return s.variantChildren && s.variantChildren.add(a), () => s.variantChildren.delete(a) } addValue(a, s) { const o = this.values.get(a); s !== o && (o && this.removeValue(a), this.bindToMotionValue(a, s), this.values.set(a, s), this.latestValues[a] = s.get()) } removeValue(a) { this.values.delete(a); const s = this.valueSubscriptions.get(a); s && (s(), this.valueSubscriptions.delete(a)), delete this.latestValues[a], this.removeValueFromRenderState(a, this.renderState) } hasValue(a) { return this.values.has(a) } getValue(a, s) { if (this.props.values && this.props.values[a]) return this.props.values[a]; let o = this.values.get(a); return o === void 0 && s !== void 0 && (o = Vl(s === null ? void 0 : s, { owner: this }), this.addValue(a, o)), o } readValue(a, s) { var o; let c = this.latestValues[a] !== void 0 || !this.current ? this.latestValues[a] : (o = this.getBaseTargetFromProps(this.props, a)) !== null && o !== void 0 ? o : this.readValueFromInstance(this.current, a, this.options); return c != null && (typeof c == "string" && (Oy(c) || Ty(c)) ? c = parseFloat(c) : !NA(c) && Fn.test(s) && (c = My(a, s)), this.setBaseTarget(a, tt(c) ? c.get() : c)), tt(c) ? c.get() : c } setBaseTarget(a, s) { this.baseTarget[a] = s } getBaseTarget(a) { var s; const { initial: o } = this.props; let c; if (typeof o == "string" || typeof o == "object") { const h = qc(this.props, o, (s = this.presenceContext) === null || s === void 0 ? void 0 : s.custom); h && (c = h[a]) } if (o && c !== void 0) return c; const f = this.getBaseTargetFromProps(this.props, a); return f !== void 0 && !tt(f) ? f : this.initialValues[a] !== void 0 && c === void 0 ? void 0 : this.baseTarget[a] } on(a, s) { return this.events[a] || (this.events[a] = new Fc), this.events[a].add(s) } notify(a, ...s) { this.events[a] && this.events[a].notify(...s) } } class cv extends HA { constructor() { super(...arguments), this.KeyframeResolver = By } sortInstanceNodePosition(a, s) { return a.compareDocumentPosition(s) & 2 ? 1 : -1 } getBaseTargetFromProps(a, s) { return a.style ? a.style[s] : void 0 } removeValueFromRenderState(a, { vars: s, style: o }) { delete s[a], delete o[a] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: a } = this.props; tt(a) && (this.childSubscription = a.on("change", s => { this.current && (this.current.textContent = `${s}`) })) } } function qA(i) { return window.getComputedStyle(i) } class GA extends cv { constructor() { super(...arguments), this.type = "html", this.renderInstance = ey } readValueFromInstance(a, s) { if (Ei.has(s)) { const o = ef(s); return o && o.default || 0 } else { const o = qA(a), c = (zc(s) ? o.getPropertyValue(s) : o[s]) || 0; return typeof c == "string" ? c.trim() : c } } measureInstanceViewportBox(a, { transformPagePoint: s }) { return $y(a, s) } build(a, s, o) { Uc(a, s, o.transformTemplate) } scrapeMotionValuesFromProps(a, s, o) { return Gc(a, s, o) } } class YA extends cv { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Ue, this.updateDimensions = () => { this.current && !this.renderState.dimensions && Ig(this.current, this.renderState) } } getBaseTargetFromProps(a, s) { return a[s] } readValueFromInstance(a, s) { if (Ei.has(s)) { const o = ef(s); return o && o.default || 0 } return s = ty.has(s) ? s : Oc(s), a.getAttribute(s) } scrapeMotionValuesFromProps(a, s, o) { return iy(a, s, o) } onBindTransform() { this.current && !this.renderState.dimensions && Ae.postRender(this.updateDimensions) } build(a, s, o) { kc(a, s, this.isSVGTag, o.transformTemplate) } renderInstance(a, s, o, c) { ny(a, s, o, c) } mount(a) { this.isSVGTag = Hc(a.tagName), super.mount(a) } } const XA = (i, a) => Lc(i) ? new YA(a) : new GA(a, { allowProjection: i !== C.Fragment }), KA = mS({ ...dw, ...zA, ...TA, ..._A }, XA), QA = C1(KA); function ZA({ title: i, options: a, selectedValues: s, onChange: o }) { const [c, f] = C.useState(!1), h = g => { let d = []; d = s.includes(g) ? s.filter(m => m !== g) : [...s.filter(m => m !== "All"), g], o(d) }; return y.jsxs("div", { className: "back-multi", children: [y.jsxs("div", { className: "title-multi", children: [y.jsx("span", { className: "title_text", children: i }), y.jsx("button", { onClick: () => f(!c), className: "alt-button", children: y.jsx(QA.div, { animate: { rotate: c ? 0 : 180 }, transition: { duration: .5, ease: "easeInOut" }, children: y.jsx(b1, { size: 16 }) }) })] }), c && y.jsxs(y.Fragment, { children: [y.jsx("div", { className: "options-multi", children: a.map(({ value: g, label: d }) => y.jsxs("label", { className: "option-label", children: [y.jsx("input", { type: "checkbox", checked: s.includes(g), onChange: () => h(g) }), y.jsx("span", { children: d })] }, g)) }), y.jsxs("div", { className: "bottom_buttons", children: [y.jsx("button", { onClick: () => o([]), className: "alt-button", children: "Clear" }), y.jsx("button", { onClick: () => f(!c), className: "alt-button", children: "Done" })] })] })] }) } function PA() { const [i, a] = C.useState([]), s = [{ value: "inexpensive", label: "$" }, { value: "moderately inexpensive", label: "$$" }, { value: "moderately expensive", label: "$$$" }, { value: "expensive", label: "$$$$" }]; return y.jsx(y.Fragment, { children: y.jsxs("div", { children: [y.jsxs("div", { className: "content", style: { backgroundColor: "#ffffff" }, children: [y.jsxs("h1", { children: ["Part 1:", y.jsx("br", {}), "Input"] }), y.jsx("h2", { children: "The Concept" }), y.jsx("p", { children: "I decided that I wanted to look into the multi-select dropdown tool, as I wanted to use it in a project I had in mind. My first step was to investigate the use of multi-select dropdown tools online. I looked specifically at Google Maps (price dropdown), Bing Shopping (brand dropdown), and Google Calendar (calendar dropdown). Below, I have some images from each application throughout their use stages." }), y.jsxs("table", { children: [y.jsxs("tr", { children: [y.jsx("th", { children: " Use Stages" }), y.jsx("th", { children: "Google Maps" }), y.jsx("th", { children: "Google Calendar" }), y.jsx("th", { children: "Bing Shopping" })] }), y.jsxs("tr", { children: [y.jsx("td", { children: "closed state" }), y.jsx("td", { children: y.jsx("img", { src: "src/assets/Screenshot 2025-02-11 at 1.50.40 PM.png", alt: "Price drop down of google maps" }) }), y.jsx("td", { children: y.jsx("img", { src: "src/assets/Screenshot 2025-02-11 at 1.31.35 PM.png", alt: "Google calendar dropdown other claendar closed" }) }), y.jsx("td", { children: y.jsx("img", { src: "src/assets/Screenshot 2025-02-11 at 5.38.30 PM.png", alt: "Bing shopping Brand dropdown closed" }) })] }), y.jsxs("tr", { children: [y.jsx("td", { children: "open state" }), y.jsx("td", { children: y.jsx("img", { src: "src/assets/Screenshot 2025-02-11 at 1.57.12 PM.png", alt: "price dropdown on google maps open, with price options unchecked" }) }), y.jsx("td", { children: y.jsx("img", { src: "src/assets/Screenshot 2025-02-11 at 1.31.53 PM.png", alt: "Other calendar dropdown open, with options of several calendars unchecked" }) }), y.jsx("td", { children: y.jsx("img", { src: "src/assets/Screenshot 2025-02-11 at 5.38.48 PM.png", alt: "Brand dropdown open, word show more are at bottom, fiev unchecked optiosn displayed" }) })] }), y.jsxs("tr", { children: [y.jsx("td", { children: "options clicked" }), y.jsx("td", { children: y.jsx("img", { src: "src/assets/Screenshot 2025-02-11 at 1.58.41 PM.png", alt: "multiple price options checked" }) }), y.jsx("td", { children: y.jsx("img", { src: "src/assets/Screenshot 2025-02-11 at 1.32.39 PM.png", alt: "multiple calendar options checked" }) }), y.jsx("td", { children: y.jsx("img", { src: "src/assets/Screenshot 2025-02-11 at 5.39.05 PM.png", alt: "multiple brand options checked" }) })] })] }), y.jsx("p", { children: "I found that there are a few important differences when it comes to these different multi-select tools. Most multi select tools are defaulted to be open. All multiselect tools have an arrow that is pointing down when the select bar is open, and up when the select bar is closed. The select bar does not usually state what you have selected. If it does not show you what you have selected, it will show you what you have selected in another area of the screen somehow. Usually, there is a nice animation when you open and close the select tool. Also, when you hover over the button to “checkmark” (all three applications used box like squares and checkmarks) there usually is an indication that it is clickable, done through shading or highlighting." }), y.jsxs("p", { children: ["Something neat is that while on google calendars, I can navigate through the dropdown with my keyboard when I press on the dropdown. I can use space, to select a button, the arrow keys to navigate the options in the dropdown, and tab to navigate through the buttons on one of the options. There is a similar but slightly different functionality for google maps price dropdown.", y.jsx("br", {}), "Bing allows you to see more/ show less, which is very useful for a long list. However, navigating with the keyboard is much more difficult. I can only use tab, but arrow keys and other buttons prove ineffective. I can’t seem to copy the text of the brands, but I can drag and drop the options into new tabs, which is neat. There seems to be a small error with the alignment of the dropdown arrow, as it keeps moving horizontally when I open and close the dropdown."] }), y.jsx("p", { children: "As I mentioned before, the functionalities and memorable items of these dropdowns all have checkmark boxes and a clickable arrow on the right side of the title word. If I want to create a dropdown, keeping these features is important. " }), y.jsx("p", { children: " Here is a simple table I made in regards to the usabliltiy of each application." }), y.jsxs("table", { children: [y.jsxs("tr", { children: [y.jsx("th", { children: "Interaction Type" }), y.jsx("th", { children: " Google Maps" }), y.jsx("th", { children: " Google Calendar" }), y.jsx("th", { children: " Google Maps" })] }), y.jsxs("tr", { children: [y.jsx("td", { children: "mouse" }), y.jsx("td", { children: "works fine, there are some nice features in order to clear and finish out of the dropdown, but there is a lack of animations." }), y.jsx("td", { children: "works well, the ui is smooth, uses animations, and several indicative highlights to suggest what is being clicked/ selected." }), y.jsx("td", { children: "works well, the ui could be smoohter, uses animation, but there are no almsot highlights to suggest what is being clicked." })] }), y.jsxs("tr", { children: [y.jsx("td", { children: "keyboard" }), y.jsx("td", { children: "difficult to navigate to, need use tab and arrow keys. This is easier done with voice over. Works well otherwise" }), y.jsx("td", { children: "diificult to access dropdown with keyboard. Once at dropdown, navigation through options is simple. Uses arrow keys to traverse options. " }), y.jsx("td", { children: "tab and keybaord makes it evry easy to transverse through options, but only in voice over. The keys otherwise do nothin/ provide scroll only. " })] }), y.jsxs("tr", { children: [y.jsx("td", { children: "touchpad" }), y.jsx("td", { children: 'Some of the buttons are diffult to press, specifcally the "Done" button and the "Clear" button. Otherwise, it works okay.' }), y.jsx("td", { children: "The misclicks do not have much consequences which is nice. There is a way to delete your options in this case, however there is a popup beforehand. The highlighting helps to know where you are clicking. " }), y.jsx("td", { children: "Things here are easily clickable, however due ot tiles not highlighting or geting darker when you are pressing, sometimes you don't know what you are pressing, which can make selection difficult. " })] })] })] }), y.jsxs("div", { className: "content", style: { backgroundColor: "#fff5e6" }, children: [y.jsxs("h1", { children: ["Part 2:", y.jsx("br", {}), "Output"] }), y.jsx("h2", { children: "Comparing Interactions" }), y.jsxs("p", { children: [" An input, whether a keybaord tap or a cursor hover, can cause an output. In this case, An output may be the appearance of new elements, items changing color or shade, emboldened borders or text, or a shift in element focus. Below, I create a comprehensive, in-depth analysis of several inputs and their respective outputs. The table allows the easy comparison of multi-select dropdowns from each application.", y.jsx("br", {}), " An asterick (*) represents any notations regarding the VoiceOver useage."] }), y.jsxs("table", { children: [y.jsxs("tr", { children: [y.jsx("th", { children: "Input Type" }), y.jsx("th", { children: " Google Maps" }), y.jsx("th", { children: " Google Calendar" }), y.jsx("th", { children: " Google Maps" })] }), y.jsxs("tr", { children: [y.jsx("td", { children: "Space Pressed" }), y.jsx("td", { children: "First checkbox in the dropdown is checked if dropbox is open. Space also opens the dropbox if closed. Otherwise needs to be pressed in conjunction with arrow keys (sometimes doesn’t work at all) *voice over tells you to use control+option space to open menu" }), y.jsx("td", { children: "Does not do anything in relevance to dropdown, needs to be pressed in conjunction with arrow keys, if used will check mark the other boxes" }), y.jsx("td", { children: "Spacebar scrolls down through the rest of the drop downs" })] }), y.jsxs("tr", { children: [y.jsx("td", { children: "Enter Pressed" }), y.jsx("td", { children: "Enter button has the same functionality as space button" }), y.jsx("td", { children: "Enter does nothing" }), y.jsx("td", { children: "Opens and closes dropdown if tab is navigated over toe dropdown; otherwise, nothing" })] }), y.jsxs("tr", { children: [y.jsx("td", { children: "Tab Pressed" }), y.jsx("td", { children: "If dropdown is pressed, tab will make an option gray. If pressed again, it will make the next option gray, unit tab is pressed on the last option, in which it will close out the dropdowns. *works well with voice over when navigating dropdowns and options, reads off options" }), y.jsx("td", { children: "Very difficult to navigate to multi-select dropdowns with tab. If tab is pressed while dropdowns are selected/recently have been pressed, the first option will be come gray (previously white) and a blue circle will surround the checkbox option. If pressing tab again from there, will go through rest of choices for the specific option, creating a blue circle around each. Eventually, tab gets off the dropbox option and then is no longer selecting options from the dropbox" }), y.jsx("td", { children: "A blue line appears above an below a dropdown/ dropdown option, and each time tab is pressed, it proceeds to the next option *tab can be helpful for navigating options but does not tell you you are on a dropdown." })] }), y.jsxs("tr", { children: [y.jsx("td", { children: "Arrow Keys Pressed" }), y.jsx("td", { children: "If the dropdown is opened, the top and left arrow keys will select options in an upward matter, shown by a blue line above  and below the option as well as the option becoming darker, or greyed. The down and right arrow keys will do the same but in a downwards matter. If it gets to the top or bottom of the dropdown, it will loop around to the top/bottom option. *each open is read through voice over when navigating with arrow keys, though usually causes dropdown options to close and doesn’t work well" }), y.jsx("td", { children: "Can navigate through the options, as shown by  a grayed, or darked options. Left and right arrow keys do nothing. *Voice over reads each option as you navigate through. It also tells you if it is checkmarked or not" }), y.jsx("td", { children: "Scrolls through the dropdowns, left and right arrows do nothing. *In regards to voice over, is very useful for navigating through options and reading all different parts of options" })] }), y.jsxs("tr", { children: [y.jsx("td", { children: " Number Keys Pressed" }), y.jsx("td", { children: "Nothing Happens" }), y.jsx("td", { children: "Shortcuts related to the calendar itself occur, but not related to the multi-select dropdown. " }), y.jsx("td", { children: "Nothing Happens" })] }), y.jsxs("tr", { children: [y.jsx("td", { children: " Double-click Option" }), y.jsx("td", { children: "Selects option, then unselects option, as denoted by check mark in square box appearing, and then disappearing" }), y.jsx("td", { children: "Selects option, then unselects option, as denoted by check mark in square box appearing, and then disappearing" }), y.jsx("td", { children: "Selects as normal, a check mark appears inside square box of option and the site reloads." })] }), y.jsxs("tr", { children: [y.jsx("td", { children: " Double-click Arrow / Title of Dropdown" }), y.jsx("td", { children: "If dropdown is open: makes the dropdown box flicker, twice. The drop down does not disappear. If the dropdown is closed: makes the dropdown open, then flicker once." }), y.jsx("td", { children: "If dropdown is closed: makes dropdown open, then close. The arrow flips twice while doing this. If dropdown is open: makes dropdown close, then open. The arrow flips twice while doing this." }), y.jsx("td", { children: "If dropdown is closed: makes dropdown start to open, then close. The arrow flips twice while doing this. If dropdown is open: makes dropdown start to close, then open. The arrow flips twice while doing this." })] }), y.jsxs("tr", { children: [y.jsx("td", { children: " Double-click Checkmark / Title of Option" }), y.jsx("td", { children: "If checkmark is checked: makes checkmark uncheck, then checks. If the checkmark is not checked: makes the checkmark check, then uncheck." }), y.jsx("td", { children: "If checkmark is checked: makes checkmark uncheck, then checks. If the checkmark is not checked: makes the checkmark check, then uncheck. (a sphere around the checkbox turns the color of the option in light opacity while being clicked)" }), y.jsx("td", { children: "Same functionality as checkmark being clicked once." })] }), y.jsxs("tr", { children: [y.jsx("td", { children: "Click once not on, but surrounding Dropdown" }), y.jsx("td", { children: "If open, closes the dropdown. *There are “done” and “clear” options that voice over covers" }), y.jsx("td", { children: "No affect" }), y.jsx("td", { children: "No affect" })] }), y.jsxs("tr", { children: [y.jsx("td", { children: " On Hover of Elements" }), y.jsx("td", { children: "On hover of dropdown title or arrow,  title darkens. One over of checkboxes or options, the options darken." }), y.jsx("td", { children: "On hover of dropdown title or arrow,  title darkens. One over of checkboxes or options, the options darken. If hover is on checkboxes, the checkbox will create a sphere around the checkbox that has a light opacity of the color of the option." }), y.jsx("td", { children: "Only an unmarked checkbox reacts to hover: the check mark box border becomes lighter" })] }), y.jsxs("tr", { children: [y.jsx("td", { children: " Click Arrow Dropdown Title Once" }), y.jsx("td", { children: "If dropdown is closed: opens dropdown. If dropdown is open, makes dropdown flicker. During press down, causes button to become dark. *voice over starts to read the first option" }), y.jsx("td", { children: "If drop down is closed, drop down options appear, and arrow points upward. If dropdown is opened, the dropdown options disappear and the arrow points downward. During press, the title of dropdown becomes darker. *Voice over tells you name of dropdown, and if you clicked on the expanded/ close button" }), y.jsx("td", { children: "If dropdown is closed, the arrow does an animation to point upwards and the options animate to “open.”If dropdown is open, the arrow does an animation to point downwards and the options animate to “closed.” *Voice Over is NOT helpful in this case. It does not tell you that you are currently selecting an option" })] }), y.jsxs("tr", { children: [y.jsx("td", { children: " Click box attched to Option" }), y.jsx("td", { children: "Blue box with white checkmark fills in check mark box/ disappears when is clicked if checkmarked *voice over tells you about the option clicked" }), y.jsx("td", { children: "Does an animation where a box of the option color with a white checkmark fills in check mark box/ an animation of the color and checkmark happens when clicked if checkmarked. Sphere around checkbox becomes darker during click *voice over tells you that you checked or unchecked the named option" }), y.jsx("td", { children: "Blue box with white checkmark fills in check mark box/ disappears when is clicked if checkmarked. Page reloads after click. *Voice over tells you that you checked or unchecked th named option, but because the page reloads it then proceeds to read off every ui element on the screen." })] }), y.jsxs("tr", { children: [y.jsx("td", { children: " Click Option Title" }), y.jsx("td", { children: "Blue box with white checkmark fills in check mark box/ disappears when is clicked if checkmarked *voice over tells you about the option clicked" }), y.jsx("td", { children: "Does an animation where a box of the option color with a white checkmark fills in check mark box/ an animation of the color and checkmark happens when clicked if checkmarked. *voice over tells you that you checked or unchecked the named option" }), y.jsx("td", { children: "Blue box with white checkmark fills in check mark box/ disappears when is clicked if checkmarked. Page reloads after click. *Voice over tells you that you checked or unchecked th named option, but because the page reloads it then proceeds to read off every ui element on the screen." })] })] })] }), y.jsxs("div", { className: "content", children: [y.jsxs("h1", { children: ["Part 3: ", y.jsx("br", {}), "State Models & Component Redesign"] }), y.jsx("h2", { children: "Redsigning Interaction" }), y.jsx("p", { children: "Even though the Bing Shoppping dropdown does have some important issues, I found that Google Maps Price Dorpdown had issues as well. Therefore, I decided that in order to investigate how to make the ideal dropdown, I first had to analyize the flow of interactions, and improve upon a current implementation. The Google Maps multi-select dropdown has some great features, but also some bad features. Below, I made an thorough state model of the Google Maps dropdown, when using both mouse and keyboard. Following those charts, I redesigned the state models in a way that would improve the current dropdown. I made these charts using Figma.  " }), y.jsx("h2", { style: { color: "#3C1518", paddingTop: "100px" }, children: " Original Flow State: Mouse" }), y.jsx("img", { src: "src/assets/Flow Chart Template (Copy).png", alt: "bad flow chart" }), y.jsx("h2", { style: { color: "#3C1518", paddingTop: "100px" }, children: " Original Flow State: Keyboard" }), y.jsx("img", { src: "src/assets/Flow Chart Template (Copy)-2.png", alt: "bad flow chart" }), y.jsx("h2", { style: { color: "#3C1518", paddingTop: "100px" }, children: " Redesigned Flow State: Mouse" }), y.jsx("img", { src: "src/assets/Flow Chart Template (Copy)-3.png", alt: "good flow chart" }), y.jsx("h2", { style: { color: "#3C1518", paddingTop: "100px" }, children: " Redesigned Flow State: Keyboard" }), y.jsx("img", { src: "src/assets/Flow Chart Template (Copy) copy.png", alt: "good flow chart" }), y.jsxs("p", { children: [`When making the redesigns, I had to think about some features that Google Maps did not have that Bing Shopping and Google Calendar had. With Google Maps, clicking on the title made the dropdown 'flicker', as in, disappear for half a second and then come back. It was important that when clicking on the title of the dropdown, the dropdown would close. This was also changed in the Keyboard Redesign as well. Now, you can focus the title and pressing space or enter will close the dropdown again. This allows for a more intutive interatcion between users and the dropdown. In VoiceOver, this would be called the "close [title of dropdown] Dropdown button". The main tradeoff here is that the 'Done' button becomes somewhat redundant. However, considering that Google Maps is used by a variety of people, the 'Done' button may be more accessible for some populations. `, y.jsx("br", {}), ' VoiceOver would also come into play with the "Done" and "Clear" buttons. In VoiceOver, the "Clear" Button would be called "clear [title of dropdown] button" and the "Done" Button would be called "close [title of dropdown] button". By making sure that the buttons are correctly labeled in VoiceOver, better accessiblity can be provided. ', y.jsx("br", {}), " It is also important that the title button is focused, even after openign the dropdown, rather than the first dropdown item as through the VoiceOver and keyboard interactions. This way, The user still knows they are on the dropdown. Although the User would not be immediately directed to the options, it allows the user to know that the dropdown can be closed again, and is more organized overall. ", y.jsx("br", {}), ' There is a third issue with the keyboard accessibility, and the issue has to do with the fact that pressign the down arrow key while focused on the clear button closes the dropdown. Closing the dropdown is not the responsibility of the "Clear" Button. What should happen instead is that you tab over to the "Done" Button then either press space, enter or down arrow key to close the dropdown. Although this maybe be seen as taking away a feature, I can see it as causing confusion when a user presses the down arrow key, just trying to navigate to other options in the dropdown. ', y.jsx("br", {}), ' Last but not least is the visual "flow." The dropdown provided here is very static and does not have any transition from one state to the next (fade, animation, etc). By including transitions between states, changes can become easier on the eyes and end up being more appealing. In addition, It allows for the User to see mroe clearly how their interaction is effecting the dropdown.'] }), y.jsx("p", { children: "Below, I made an annotated redesign of the Google Maps Dropdown in Figma. This annotated element expresses some of the changes I addressed above. " }), y.jsx("a", { href: "https://www.figma.com/proto/deKKXtx84t2C4axleYbV1d/Accessible-Redesign?node-id=14-281&t=TvcuVb3lvMHX7gKE-1&scaling=min-zoom&content-scaling=fixed&page-id=0%3A1&starting-point-node-id=14%3A281", style: { cursor: "pointer", fontSize: "40px", color: "black" }, children: "Click HERE to USE the prototype in Figma! (Demo is not complete)" }), y.jsx("img", { src: "src/assets/design annotation.jpg", alt: "design which makes good sense" })] }), y.jsxs("div", { className: "content", style: { backgroundColor: "#fff5e6" }, children: [y.jsxs("h1", { children: ["Part 4: ", y.jsx("br", {}), "Reflection"] }), y.jsx("h2", { children: "Overview" }), y.jsxs("p", { children: ["Questions for myself: ", y.jsx("br", {}), "Where did the components you observed do well in terms of usability and accessibility? How have you applied this to your design? When it came to voice over descriptions and navigation using tab and arrow keys, the components I observed succeeded in terms of accessibility. There were also common themes like arrows, darkening of itmes, and checkmarks, all of which I applied to my design.", y.jsx("br", {}), "Are there accessibility considerations that were not addressed that you accounted for in your own component design? Many accessibility considerations were made with the orginal componet designs. However, they all made it somewhat difficult to navigate to in the webpage, and in some cases voice over descriptions are simple. In the new design, I hope to make this easier.", y.jsx("br", {}), "How does the change you’ve made in your own design solve for a “mismatch” in our world? The main changes I made create a better match between the component and its users- both for people who are familiar with technology, as well as for people that have poor eyesight or need to use VoiceOver. I mentioned preivously in-depth at the end of Part 3 about how each change helps specifcially. In general, the changes make sure certain buttons have better descriptions, better flow between Ui elements, and make the title of the dropdown a button which helps people who are familiar with these intitive designs. Mismatches created because the compoennt is not as accessible for those who are more familair with technology, less familair with technology, and have blindness are solved from my changes.", y.jsx("br", {}), `How does the accessibility/inaccessibility of inputs or outputs from Part 1 and Part 2 impact users with impairments either positively or negatively, respectively. Being able to select, close, and open the dropdowns with the keyboard while using VoiceOver enables for people that are blind to be able to access informaiton and apps more easily. The outputs, such as the VoiceOver descriptions and the darkening of items when hovering over them also helps in this regard. Intuitive design when it comes to these inputs and outputs allows for more accessibility throughout different groups of people. Google Maps dropdown that I selected has a "done" button that many other dropdown components do not have. Though, this feature is definetly more accessible for those who aren't as familiar. In regards to inaccessibility, The Bing Shopping dropdown was pretty bad when it came to showing users what was clickable (through highlighting or darkening elements) and navigating with VoiceOver. Although it was descriptive, whenever you select an option, the focus and VoiceOver starts to run throughout the whole page without any further inputs. This completely loses the place of someone who is listenign to see where in the page they are.`, y.jsx("br", {}), "Between mouse, keyboard, touch/mobile, and screen reader users, which do you think are most commonly prioritized in the process of creating components? How might this impact the user experience? Mouse is most commonly prioritized in the process of creating components. This is because a significant majority of people that would benefit from these components, as well as the ones who design these components, are familiar with technology and do not have colorblindness or blindness. Therefore, the User exeperiecne will be signficantly poorer for those with blindness, colorblindness, or less familiarity with technology."] })] }), y.jsxs("div", { className: "content", children: [y.jsxs("h1", { children: ["Part 5: ", y.jsx("br", {}), "The Product"] }), y.jsx("h2", { children: "My Custom Element" }), y.jsx("p", { children: " I have made a dropdown inspired by my case study. Now, I can use it in my other projects too! There are a few things I still need to change, such as the shading when hovering over sections, but otherwise it is somewhat complete. Try using it below!" }), y.jsx(ZA, { title: "Price", options: s, selectedValues: i, onChange: a })] })] }) }) } function FA() { return y.jsxs("div", { children: [y.jsxs("div", { className: "content", children: [y.jsx("h1", { children: "Observing Interaction of a Public Interface" }), y.jsx("h2", { children: "Interviewing and Recording" }), y.jsx("p", { children: "My first step to this process is finding a public interface that I can observe. Below, I have sketched out my inteface. In particular, I watched a Vending machine used by Brown Students in the Science Library. " }), y.jsxs("div", { style: { justifyContent: "center" }, children: [y.jsx("img", { style: { objectFit: "contain", display: "block", width: "180vw", height: "130vh" }, src: "src/assets/vendor.png", alt: "Vending machine sketch" }), y.jsx("img", { style: { objectFit: "contain", display: "block", width: "180vw", height: "130vh" }, src: "src/assets/interface.png", alt: "Interface annotation" })] }), y.jsxs("p", { children: [" Some of my main observations are that: ", y.jsx("br", {}), "Many people swiped their Brown ID and continued interacting with the interface, but didn't end up buying anything and walked away. This was more common than people actually buying from the vending machine. ", y.jsx("br", {}), " A few people had to squat down in order to swipe their card in the interface. ", y.jsx("br", {}), " When interacting with the interface, nearly all people inputed the same number into the keyboard 2 or 3 times. ", y.jsx("br", {}), " No one paid with their Brown ID. "] }), y.jsx("p", { children: " Here are my summarized responses when it came to the questions I asked 3 students who used the vending machine: " }), y.jsx("h3", { children: "How would you describe your experience using this particular vending machine?" }), y.jsx("p", { children: "Medicore to frusterating to use." }), y.jsx("h3", { children: "Why do you use this vending machine?" }), y.jsx("p", { children: "Used this vending machine because I want to continue to stay in the Science Library (for convience) and because the other vending machines are out/ don't have what I want." }), y.jsx("h3", { children: "What payment method do you use?" }), y.jsx("p", { children: "Paid with credit card or Apple Pay." }), y.jsx("h3", { children: "In what way does the vending machine interface meet your expectations?" }), y.jsx("p", { children: "After interaction, I received food from the vending machien as standard." }), y.jsx("h3", { children: "Is there any step in the process of using the vending machine interface that is different from your expectations?" }), y.jsx("p", { children: "Although there is a label indicating that it accepts Brown ID cards, after swiping the brown ID, the payment interface tells the user to swipe with a different card, as the current card does not wok. Also, the sensor for Apple Pay works only sometimes." })] }), y.jsxs("div", { className: "content", style: { backgroundColor: "#fff5e6" }, children: [y.jsx("h1", { children: "Creating Personas" }), y.jsx("h2", { children: "Making an empathy map" }), y.jsx("p", { children: " Using the observations and interviews I collected my goal was to construct 2 personas by creating an empathy map, describing what users think, feel, say, and do, representing part of the spectrum of users I had observed. A good persona is one that someone can act out with confidence in different scenarios. My personas should be based on overarching trends I observed amongst all the users I interviewed from the previous section, while avoiding assumptions.  Below, I have created two personas that represent the people I interveiwed using the vending machine " }), y.jsx("img", { src: "src/assets/Ari_Persona.png", alt: "Persona Named Ari, is off the meal plan. Pays with apple pay, feel mediocore about interaction." }), y.jsx("img", { src: "src/assets/Sarah_persona.png", alt: "Persona named Sarah, is on the meal plan, tries to pay wih meal plan with Brown ID, and is frusterated because it does not accept Brown ID." })] }), y.jsxs("div", { className: "content", children: [y.jsx("h1", { children: "Drawing a Storyboard" }), y.jsx("h2", { children: "Mapping Interaction from Beginning to End" }), y.jsx("p", { children: "Some qualities of a good storyboard include thinking about presenting authenticity, emotion, and simplicity. I want to storyboard my persona's entire user journey from start to end. I should reflect the goals of my persona and include all the steps for using this interface. Using this storyboard, you should better identify the goals and characteristics of my personas." }), y.jsx("p", { children: "Below is my completed Story board of the Persona Sarah, using the Vending Machine." }), y.jsx("img", { src: "src/assets/storyboard.png", alt: "Storyboard of Sarah using the vending machine" })] })] }) } function JA() { return y.jsxs("div", { children: [y.jsxs("div", { className: "content", children: [y.jsx("h1", { children: "Identifying Usability Issues" }), y.jsx("h2", { children: "Analyzing and Identifying flaws in an Interface" }), y.jsx("p", { children: "I looked at websites of locations nearby, and found this particular website. It seems like an older website that uses some outdated designs, non-user friendly colors, and is a bit unorganized. I felt like I could definetly improve this website." }), y.jsxs("a", { href: "https://www.saintmarycranston.org", children: [y.jsx("p", { children: "The website of Saint Mary's Church, in Cranston Rhode Island." }), y.jsx("img", { src: "src/assets/resdesignweb.png", alt: "Saint Marry's Church, in Cranston RI, website." })] }), y.jsx("p", { children: "Here I describe the Usability of the website:" }), y.jsxs("table", { children: [y.jsxs("tr", { children: [y.jsx("th", { children: "Efficiency" }), y.jsx("th", { children: "Learnability" }), y.jsx("th", { children: "Memorability" })] }), y.jsxs("tr", { children: [y.jsx("td", { children: y.jsxs("ul", { children: [y.jsx("li", { children: "Many contrast and font color/ heading problems, makes it hard to read. " }), y.jsx("li", { children: "Many links go to outside sources instead of documents being natively accessible." }), y.jsx("li", { children: "Alternate text not available." })] }) }), y.jsx("td", { children: y.jsxs("ul", { children: [y.jsx("li", { children: "Difficult to learn where to find certain information." }), y.jsx("li", { children: '"Our Faith" and "Beliefs" are two different dropdowns despite being synonyms.' }), y.jsx("li", { children: "Buttons versus what is not a button is not intuitive. Too many different buttons." })] }) }), y.jsx("td", { children: y.jsxs("ul", { children: [y.jsx("li", { children: "Information is unorganized and therefore hard to remember." }), y.jsx("li", { children: "Everything stays in the same place upon reloading website, which helps for remembering." }), y.jsx("li", { children: "Changing the size of the window displaces buttons and text greatly, makign it hard to use. " })] }) })] })] }), y.jsx("p", { children: "When using WAVE, the web accesibility evaluation tool, it found that there were very significant amount of contrast problems, as well as almost none or all of the images did not have alternate text. It also found that there were many readibility errors, because of several different types of text and columns. There are also several links to documents that should be natively accessible. It also found many ARIA features, which are common for older websites. I definetly agree with WAVE in the reability and contrast problems this website has." }), y.jsx("p", { children: " These problems make it difficult to use the website, and negatively affect user experience. Users may not be able to naviagte around the website efficently or be able to read or understand the information present. Some users may feel as if the website was not made with them in consideration.  " })] }), y.jsxs("div", { className: "content", style: { backgroundColor: "#fff5e6" }, children: [y.jsx("h1", { children: "Visual Redesign" }), y.jsx("h2", { children: "Creating a visual design style guide and mockups" }), y.jsx("p", { children: 'Below, I have created a Visual Design Style Guide (made in Figma) to represent a guide to the changes I will make. I wanted to stay true to some of the original website, hence why I kept the font of the Church name as a logo and kept the original blue colors. I also stylized the image of the Church to serve as a nice "home" logo. The font design is now consistently Open Sans as to make the website more readible. The buttons are more rounded and have better contrast. The colors are now consistent and there are no gradient features in the website. The buttons are now similar to eachother with slight variations based on function. These redesigns make the website easier to use and make it more aesthetically pleasing.' }), y.jsx("img", { src: "src/assets/Visual Design Style Guide.png" }), y.jsxs("p", { children: [" Below I have made my comptuer redesign (made through Figma) Starting from top to bottom:", y.jsxs("ul", { children: [y.jsx("li", { children: "The navigation bar is centered" }), y.jsx("li", { children: "Navigation bar follows as user scrolls" }), y.jsx("li", { children: "Navigation options are merged and simplified" }), y.jsx("li", { children: "Website is split into sections" }), y.jsx("li", { children: "Relevant sections are moved closer to the top of the screen" }), y.jsx("li", { children: "Headers and fond is consistent" })] })] }), y.jsx("img", { src: "src/assets/Redesign_Computer.png" }), y.jsx("p", { children: " I wanted to make sure that, unlike the original website, the website could adjust to the window size. For my redesign in smaller window sizes, such as the Tablet or Iphone, I make buttons, pictures, icons, sections, and text smaller than in the computer version. I also align some text to the left and center instead of splitting text over multiple columns. In addition, instead of keeping the buttons in the navigation bar, I have an arrow that points upward when closed, and down when open. When open, the options of other pages are shown. The navigation bar with the logo follows you as you scroll." }), y.jsx("img", { src: "src/assets/Redesign_Tablet.png" }), y.jsx("img", { src: "src/assets/Redesign_Iphone.png" })] }), y.jsxs("div", { className: "content", children: [y.jsx("h1", { children: "Responsive Redesign" }), y.jsx("h2", { children: "Making a new and improved webpage" }), y.jsxs("p", { children: ["Click ", y.jsx(Ht, { to: "/redesign", style: { fontWeight: "bold", textDecoration: "underline" }, children: "Here" }), " to see my redesign of this webpage."] }), y.jsx("p", { children: "My redesign of the webpage is much more accessible when not on computer, allowing for users to be able to experience it on other devices. In addition, the website has less redudancy, is reasier to read, and has similar intutive buttons. Headers are cordinated and are easy to read. These and the changes mentioned above makes the website much more accessible to users, across platforms, ages, and abilties. " })] })] }) } function $A() { return y.jsxs("div", { style: { paddingTop: "10vh", backgroundColor: "white" }, children: [y.jsxs("div", { className: "intro", style: { backgroundImage: "url(src/assets/backgroundChurch.png)" }, children: [y.jsx("h1", { children: "Welcome to Saint Mary's Church, Cranston!" }), y.jsx("div", { style: { paddingLeft: "10vw", paddingBottom: "50px" }, children: y.jsx("a", { children: "Learn more" }) })] }), y.jsxs("div", { className: "mass", children: [y.jsx("h1", { children: "Mass Times" }), y.jsxs("div", { className: "holder", children: [y.jsxs("div", { style: { margin: "0px 40px" }, children: [y.jsx("h2", { children: "Weekend Mass:" }), y.jsxs("h3", { children: ["Saturday Vigil: 4:00pm ", y.jsx("br", {}), "Sunday: 8:00, 9:30 and 11:00am"] })] }), y.jsxs("div", { style: { margin: "0px 40px" }, children: [y.jsx("h2", { children: "Daily Mass:" }), y.jsxs("h3", { children: ["Tuesday- Friday 8:00am ", y.jsx("br", {}), "(Lower Church) ", y.jsx("br", {}), "*Rosary after Mass"] })] }), y.jsxs("div", { style: { margin: "0px 40px" }, children: [y.jsx("h2", { children: "Confessions are on:" }), y.jsxs("h3", { children: ["Fridays from 8:30am - 9:15am ", y.jsx("br", {}), "Saturdays from 3:00pm - 3:45pm"] })] })] }), y.jsx("p", { children: "We will be offering first Friday Confessions from 7:00am - 7:45am on the First Friday of every month beginning Friday, May 6th. (This new time is being offered on First Fridays in addition to the regular schedule of 8:30-9:15am.)" })] }), y.jsxs("div", { className: "events", children: [y.jsx("h1", { style: { fontSize: "250%" }, children: "Upcoming Events" }), y.jsxs("div", { style: { display: "flex", flexDirection: "column", justifyContent: "center", width: "100vw" }, children: [y.jsxs("div", { className: "dropdown", children: [y.jsx("span", { children: "Janurary 1st" }), y.jsxs("div", { className: "dropdown-content", children: [y.jsx("p", { children: "Mass 8:00am" }), y.jsx("p", { children: "Mass 9:30am" }), y.jsx("p", { children: "Mass 11:00am" })] })] }), y.jsxs("div", { className: "dropdown", children: [y.jsx("span", { children: "Janurary 3rd" }), y.jsxs("div", { className: "dropdown-content", children: [y.jsx("p", { children: "Mass 8:00am" }), y.jsx("p", { children: "Pastor Meet and Greet 11:00am" })] })] }), y.jsxs("div", { className: "dropdown", children: [y.jsx("span", { children: "Janurary 4th" }), y.jsx("div", { className: "dropdown-content", children: y.jsx("p", { children: "Mass 8:00am" }) })] }), y.jsxs("div", { className: "dropdown", children: [y.jsx("span", { children: "Janurary 5th" }), y.jsxs("div", { className: "dropdown-content", children: [y.jsx("p", { children: "Mass 8:00am" }), y.jsx("p", { children: "Confession 8:30am-9:15am" }), y.jsx("p", { children: "Aniversary Celebration 1:00pm " })] })] })] })] }), y.jsxs("div", { className: "resources", children: [y.jsx("h1", { style: { fontSize: "250%" }, children: "Resources" }), y.jsxs("div", { className: "holder", children: [y.jsx("a", { style: { backgroundImage: "linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.5)), url(src/assets/reading.jpg)" }, children: " Daily Reading" }), y.jsxs("a", { style: { backgroundImage: "linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.5)), url(src/assets/news.jpg)" }, children: [y.jsx("div", { className: "overlayRedesign" }), "Catholic News"] }), y.jsxs("a", { style: { backgroundImage: "linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.5)), url(src/assets/giving.jpg)" }, children: [y.jsx("div", { className: "overlayRedesign" }), "Online Givings"] })] })] }), y.jsxs("div", { className: "contact", children: [y.jsx("div", { className: "contact-church", children: y.jsx("img", { src: "src/assets/st-mary-cropped.jpg", style: { border: "none", borderRadius: "1vw" } }) }), y.jsxs("div", { className: "contact-text", children: [y.jsx("h1", { children: "Contact" }), y.jsxs("h3", { children: ["office@saintmarycranston.org ", y.jsx("br", {}), "1525 Cranston St, Cranston, RI, United States", y.jsx("br", {}), "(401) 942-1492"] }), y.jsx("img", { src: "src/assets/social.png", style: { border: "none", width: "150px" } })] })] })] }) } const WA = () => y.jsx(t1, { children: y.jsx(IA, {}) }), IA = () => { const i = Jn(); return y.jsxs("div", { children: [i.pathname !== "/redesign" && y.jsx("div", { className: "navigation", children: y.jsx("nav", { children: y.jsxs("ul", { children: [y.jsx("li", { children: y.jsx(Ht, { to: "/", children: "Home" }) }), y.jsx("li", { children: y.jsx(Ht, { to: "/projects", children: "Projects" }) }), y.jsx("li", { children: y.jsx(Ht, { to: "/resume", children: "Resume" }) })] }) }) }), i.pathname === "/redesign" && y.jsx("div", { className: "redesignNav", children: y.jsxs("nav", { children: [y.jsxs("ul", { children: [y.jsx("li", { children: y.jsx("img", { src: "src/assets/churchLogo.png", alt: "church logo" }) }), y.jsx("li", { children: y.jsx("img", { src: "src/assets/churchNameLogo.png", alt: "church name logo" }) })] }), y.jsxs("ul", { className: "nav_redesign", children: [y.jsx("li", { children: y.jsx(Ht, { to: "/redesign", children: "Home" }) }), y.jsx("li", { children: y.jsx(Ht, { to: "/redesign", children: "About" }) }), y.jsx("li", { children: y.jsx(Ht, { to: "/redesign", children: "Beliefs & Faith" }) }), y.jsx("li", { children: y.jsx(Ht, { to: "/redesign", children: "Forms" }) }), y.jsx("li", { children: y.jsx(Ht, { to: "/redesign", children: "Contact" }) })] }), y.jsx("div", { className: "nav_redesign collapsed", children: y.jsx("a", { href: "", children: "v" }) })] }) }), y.jsxs(Vx, { children: [y.jsx(Qn, { path: "/", element: y.jsx(h1, {}) }), y.jsx(Qn, { path: "/projects", element: y.jsx(f1, {}) }), y.jsx(Qn, { path: "/resume", element: y.jsx(d1, {}) }), y.jsx(Qn, { path: "/demo", element: y.jsx(PA, {}) }), y.jsx(Qn, { path: "/demo2", element: y.jsx(FA, {}) }), y.jsx(Qn, { path: "/demo3", element: y.jsx(JA, {}) }), y.jsx(Qn, { path: "/redesign", element: y.jsx($A, {}) })] })] }) }; Gb.createRoot(document.getElementById("root")).render(y.jsx(C.StrictMode, { children: y.jsx(WA, {}) }));
